<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Go 细节</title>
      <link href="/post/go-details.html"/>
      <url>/post/go-details.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自 <a href="https://go101.org/article/details.html" target="_blank" rel="noopener">Go Details 101</a> 版权@归原文所有.<p></p><h3 id="代码包"><a href="#代码包" class="headerlink" title="代码包"></a>代码包</h3><h4 id="一个包可以在源文件中多次导入"><a href="#一个包可以在源文件中多次导入" class="headerlink" title="一个包可以在源文件中多次导入"></a>一个包可以在源文件中多次导入</h4><p>Go 源文件可以多次导入相同的包, 但导入名称必须不同. 这些相同的包导入引用相同的包实例.</p><p>例如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"io"</span></span><br><span class="line"><span class="keyword">import</span> inout <span class="string">"io"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(&amp;inout.EOF == &amp;io.EOF) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="package-mypkg-后的注释-import-“x-y-z-mypkg”-对于-Go-编译器是有意义的"><a href="#package-mypkg-后的注释-import-“x-y-z-mypkg”-对于-Go-编译器是有意义的" class="headerlink" title="package mypkg 后的注释 // import “x.y.z.mypkg” 对于 Go 编译器是有意义的"></a>package mypkg 后的注释 // import “x.y.z.mypkg” 对于 Go 编译器是有意义的</h4><p>例如, 当导入此包的源文件由标准 Go 编译器编译时, 以下包的导入路径必须为 “x.y.z.mypkg”.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mypkg <span class="comment">// import "x.y.z.mypkg"</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="swith-和-select-中的-default-分支可以放在所有-case-分支之前-之后-或者之间"><a href="#swith-和-select-中的-default-分支可以放在所有-case-分支之前-之后-或者之间" class="headerlink" title="swith 和 select 中的 default 分支可以放在所有 case 分支之前, 之后, 或者之间."></a>swith 和 select 中的 default 分支可以放在所有 case 分支之前, 之后, 或者之间.</h4><p>与许多其他语言相比, 一个明显的区别在于 switch-case 控制流程块中默认分支的顺序可以是任意的. 例如, 以下三个 switch-case 控制流程块彼此等效.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> n := rand.Intn(<span class="number">3</span>); n &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: fmt.Println(<span class="string">"n == 0"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: fmt.Println(<span class="string">"n == 1"</span>)</span><br><span class="line"><span class="keyword">default</span>: fmt.Println(<span class="string">"n == 2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> n := rand.Intn(<span class="number">3</span>); n &#123;</span><br><span class="line"><span class="keyword">default</span>: fmt.Println(<span class="string">"n == 2"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: fmt.Println(<span class="string">"n == 0"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: fmt.Println(<span class="string">"n == 1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> n := rand.Intn(<span class="number">3</span>); n &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: fmt.Println(<span class="string">"n == 0"</span>)</span><br><span class="line"><span class="keyword">default</span>: fmt.Println(<span class="string">"n == 2"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: fmt.Println(<span class="string">"n == 1"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="延期匿名函数可以修改嵌套函数的命名返回结果"><a href="#延期匿名函数可以修改嵌套函数的命名返回结果" class="headerlink" title="延期匿名函数可以修改嵌套函数的命名返回结果"></a>延期匿名函数可以修改嵌套函数的命名返回结果</h4><p>例如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Triple</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">r += n <span class="comment">// modify the return value</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n + n <span class="comment">// &lt;=&gt; r = n + n; return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Triple(<span class="number">5</span>)) <span class="comment">// 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对于切片-s-循环-for-i-range-s-…-不等于-for-i-0-i-lt-len-s-i-…"><a href="#对于切片-s-循环-for-i-range-s-…-不等于-for-i-0-i-lt-len-s-i-…" class="headerlink" title="对于切片 s, 循环 for i = range s {…} 不等于 for i = 0; i &lt; len(s); i++ {…}"></a>对于切片 s, 循环 for i = range s {…} 不等于 for i = 0; i &lt; len(s); i++ {…}</h4><p>对于两个循环, 迭代变量 i 的相应最终值可能不同.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fa</span><span class="params">(s []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">i = n</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;&#125;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fb</span><span class="params">(s []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">i = n</span><br><span class="line"><span class="keyword">for</span> i = <span class="keyword">range</span> s &#123;&#125;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">fmt.Println(fa(s, <span class="number">-1</span>), fb(s, <span class="number">-1</span>)) <span class="comment">// 6 5</span></span><br><span class="line">s = <span class="literal">nil</span></span><br><span class="line">fmt.Println(fa(s, <span class="number">-1</span>), fb(s, <span class="number">-1</span>)) <span class="comment">// 0 -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-os-Exit-函数调用退出程序并使用-runtime-Goexit-函数调用退出-goroutine"><a href="#使用-os-Exit-函数调用退出程序并使用-runtime-Goexit-函数调用退出-goroutine" class="headerlink" title="使用 os.Exit 函数调用退出程序并使用 runtime.Goexit 函数调用退出 goroutine"></a>使用 os.Exit 函数调用退出程序并使用 runtime.Goexit 函数调用退出 goroutine</h4><p>我们可以通过调用 os.Exit 函数从任何函数中退出程序. os.Exit 函数调用取一个 int 码作为参数并且将该码返回给操作系统.</p><p>例如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exit-example.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go run a.go</span><br><span class="line">exit status 1</span><br><span class="line">$ echo $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>我们可以通过调用 runtime.Goexit 函数来退出一个 goroutine. runtime.Goexit 函数没有参数.</p><p>一个例子:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;c &lt;- <span class="number">1</span>&#125;()</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"Go"</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">runtime.Goexit()</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">"Java"</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="对于数值指针-p-表达式-p-相当于-p-如果-p-不是数值指针-则-p-编译不过"><a href="#对于数值指针-p-表达式-p-相当于-p-如果-p-不是数值指针-则-p-编译不过" class="headerlink" title="对于数值指针 p, 表达式 p++ 相当于 (p)++. 如果 p 不是数值指针, 则 *p++ 编译不过"></a>对于数值指针 p, 表达式 <em>p++ 相当于 (</em>p)++. 如果 p 不是数值指针, 则 *p++ 编译不过</h4><p>在 Go 中, 指针不能进行算术运算. 对于指针值 p, 语句 p++ 在 Go 中是非法的. 如果 p 是一个指向数值的指针, 那么 Go 编译器会将 *v++ 视为 (*v)++.</p><p>例如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="keyword">int64</span>(<span class="number">5</span>)</span><br><span class="line">p := &amp;a</span><br><span class="line"></span><br><span class="line"><span class="comment">// The following two lines don't compile.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">p++</span></span><br><span class="line"><span class="comment">p = (&amp;a) + 8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">*p++</span><br><span class="line">fmt.Println(*p, a)   <span class="comment">// 6 6</span></span><br><span class="line">fmt.Println(p == &amp;a) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如果两种类型的基本类型相同-则两个命名指针类型的值可以相互转换-两种指针类型的底层类型可能不同"><a href="#如果两种类型的基本类型相同-则两个命名指针类型的值可以相互转换-两种指针类型的底层类型可能不同" class="headerlink" title="如果两种类型的基本类型相同, 则两个命名指针类型的值可以相互转换. 两种指针类型的底层类型可能不同."></a>如果两种类型的基本类型相同, 则两个命名指针类型的值可以相互转换. 两种指针类型的底层类型可能不同.</h4><p>给定非接口值 x 和非接口类型 T, 假定 x 的类型为 Tx,</p><ul><li>如果 Tx 和 T 共享相同的底层类型(忽略结构体 tags), 那么 x 可以显示地转换为 T, 尤其当 Tx 或者 T 不是一个定义类型并且它们的底层类型相同(考虑结构体 tags), 那么 x 可以隐式地转换为 T.</li><li>如果 Tx 和 T 具有不同的底层类型, 但 Tx 和 T 都是<a href="https://go101.org/article/type-system-overview.html#non-defined-type" target="_blank" rel="noopener">非定义</a>的指针类型, 并且它们的基类型共享相同的底层类型(忽略结构体 tags), 则 x 可以(并且必须)可以显示地转换为 T.</li></ul><p>一般性例子:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// []int, IntSlice and MySlice share</span></span><br><span class="line"><span class="comment">// the same underlying type: []int</span></span><br><span class="line"><span class="keyword">type</span> IntSlice []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> MySlice  []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s  = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> is = IntSlice&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> ms = MySlice&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">struct</span>&#123;n <span class="keyword">int</span> <span class="string">`foo`</span>&#125;</span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">struct</span>&#123;n <span class="keyword">int</span> <span class="string">`bar`</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The two lines both fail to compile.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">is = ms</span></span><br><span class="line"><span class="comment">ms = is</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Must use explicit conversions here.</span></span><br><span class="line">is = IntSlice(ms)</span><br><span class="line">ms = MySlice(is)</span><br><span class="line">x = <span class="keyword">struct</span>&#123;n <span class="keyword">int</span> <span class="string">`foo`</span>&#125;(y)</span><br><span class="line">y = <span class="keyword">struct</span>&#123;n <span class="keyword">int</span> <span class="string">`bar`</span>&#125;(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implicit conversions are okay here.</span></span><br><span class="line">s = is</span><br><span class="line">is = s</span><br><span class="line">s = ms</span><br><span class="line">ms = s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针的例子:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> IntPtr *<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> MyIntPtr *MyInt</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pi = <span class="built_in">new</span>(<span class="keyword">int</span>) <span class="comment">// type is *int</span></span><br><span class="line"><span class="keyword">var</span> ip IntPtr = pi <span class="comment">// ok, same underlying type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var _ *MyInt = pi // can't convert implicitly</span></span><br><span class="line"><span class="keyword">var</span> _ = (*MyInt)(pi) <span class="comment">// ok, must explicitly</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var _ MyIntPtr = pi  // can't convert implicitly</span></span><br><span class="line"><span class="comment">// var _ = MyIntPtr(pi) // can't convert explicitly</span></span><br><span class="line"><span class="keyword">var</span> _ MyIntPtr = (*MyInt)(pi)  <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">var</span> _ = MyIntPtr((*MyInt)(pi)) <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var _ MyIntPtr = ip  // can't convert implicitly</span></span><br><span class="line"><span class="comment">// var _ = MyIntPtr(ip) // can't convert explicitly</span></span><br><span class="line"><span class="keyword">var</span> _ MyIntPtr = (*MyInt)((*<span class="keyword">int</span>)(ip))  <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">var</span> _ = MyIntPtr((*MyInt)((*<span class="keyword">int</span>)(ip))) <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不同零大小的值的地址可能相同也可能不同"><a href="#不同零大小的值的地址可能相同也可能不同" class="headerlink" title="不同零大小的值的地址可能相同也可能不同."></a>不同零大小的值的地址可能相同也可能不同.</h4><p>两个零大小值的地址是否相等取决于编译器和编译器版本.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">b := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">x := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">y := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">m := [<span class="number">10</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">n := [<span class="number">10</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">o := [<span class="number">10</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">p := [<span class="number">10</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(&amp;x, &amp;y, &amp;o, &amp;p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// For the standard Go compiler (1.10),</span></span><br><span class="line"><span class="comment">// x, y, o and p escape to heap,</span></span><br><span class="line"><span class="comment">// but a, b, m and n are allocated on stack.</span></span><br><span class="line"></span><br><span class="line">fmt.Println(&amp;a == &amp;b) <span class="comment">// false</span></span><br><span class="line">fmt.Println(&amp;x == &amp;y) <span class="comment">// true</span></span><br><span class="line">fmt.Println(&amp;a == &amp;x) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">fmt.Println(&amp;m == &amp;n) <span class="comment">// false</span></span><br><span class="line">fmt.Println(&amp;o == &amp;p) <span class="comment">// true</span></span><br><span class="line">fmt.Println(&amp;n == &amp;p) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的输出用于标准 Go 编译器 1.10.</p><h4 id="指针类型的基类型可能是指针类型本身"><a href="#指针类型的基类型可能是指针类型本身" class="headerlink" title="指针类型的基类型可能是指针类型本身"></a>指针类型的基类型可能是指针类型本身</h4><p>一个例子:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> P *P</span><br><span class="line"><span class="keyword">var</span> p P</span><br><span class="line">p = &amp;p</span><br><span class="line">p = **************p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样,</p><ul><li>切片类型的元素类型可以是切片类型本身,</li><li>映射类型的元素类型可以是映射类型本身,</li><li>管道类型的元素类型可以是管道类型本身,</li><li>函数类型的参数和结果类型可以是函数类型本身.</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> S []S</span><br><span class="line"><span class="keyword">type</span> M <span class="keyword">map</span>[<span class="keyword">string</span>]M</span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">chan</span> C</span><br><span class="line"><span class="keyword">type</span> F <span class="function"><span class="keyword">func</span><span class="params">(F)</span> <span class="title">F</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">s</span> := <span class="title">S</span></span>&#123;<span class="number">0</span>:<span class="literal">nil</span>&#125;</span><br><span class="line">s[<span class="number">0</span>] = s</span><br><span class="line">m := M&#123;<span class="string">"Go"</span>: <span class="literal">nil</span>&#125;</span><br><span class="line">m[<span class="string">"Go"</span>] = m</span><br><span class="line">c := <span class="built_in">make</span>(C, <span class="number">3</span>)</span><br><span class="line">c &lt;- c; c &lt;- c; c &lt;- c</span><br><span class="line"><span class="keyword">var</span> f F</span><br><span class="line">f = <span class="function"><span class="keyword">func</span><span class="params">(F)</span><span class="title">F</span></span> &#123;<span class="keyword">return</span> f&#125;</span><br><span class="line"></span><br><span class="line">_ = s[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">_ = m[<span class="string">"Go"</span>][<span class="string">"Go"</span>][<span class="string">"Go"</span>][<span class="string">"Go"</span>]</span><br><span class="line">&lt;-&lt;-&lt;-c</span><br><span class="line">f(f(f(f(f))))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于选择器的细节"><a href="#关于选择器的细节" class="headerlink" title="关于选择器的细节"></a>关于选择器的细节</h4><p>对于一个指针值, 不管其类型是否定义, 如果它的(指针)类型的基类型是一个结构体类型, 那么指针值可以访问它引用的结构体值的字段. 但是, 如果指针值的类型是定义的类型, 则该值无法访问其引用的值的方法.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">x <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span> <span class="title">m</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// T has one method.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P *T  <span class="comment">// a defined one-level pointer type.</span></span><br><span class="line"><span class="keyword">type</span> PP *P <span class="comment">// a defined two-level pointer type.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> t T</span><br><span class="line"><span class="keyword">var</span> tp = &amp;t</span><br><span class="line"><span class="keyword">var</span> tpp = &amp;tp</span><br><span class="line"><span class="keyword">var</span> p P = tp</span><br><span class="line"><span class="keyword">var</span> pp PP = &amp;p</span><br><span class="line">tp.x = <span class="number">12</span>  <span class="comment">// okay</span></span><br><span class="line">p.x = <span class="number">34</span>   <span class="comment">// okay</span></span><br><span class="line">pp.x = <span class="number">56</span>  <span class="comment">// error: type PP has no field or method x</span></span><br><span class="line">tpp.x = <span class="number">78</span> <span class="comment">// error: type **T has no field or method x)</span></span><br><span class="line"></span><br><span class="line">tp.m()  <span class="comment">// okay. Type *T also has a "m" method.</span></span><br><span class="line">p.m()   <span class="comment">// error: type P has no field or method m</span></span><br><span class="line">pp.m()  <span class="comment">// error: type PP has no field or method m</span></span><br><span class="line">tpp.m() <span class="comment">// error: type **T has no field or method m</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
            <tag> go101 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go 类型系统概述</title>
      <link href="/post/type-system-overview.html"/>
      <url>/post/type-system-overview.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自 <a href="https://go101.org/article/type-system-overview.html" target="_blank" rel="noopener">Overview Of Go Type System</a> 版权@归原文所有.<p></p><p>本文将介绍 Go 中的各种类型. Go 类型系统中的各种概念也将被引入. 如果不了解这些概念, 就很难对 Go 有透彻的理解.</p><h3 id="概念-基本类型"><a href="#概念-基本类型" class="headerlink" title="概念: 基本类型"></a>概念: 基本类型</h3><p>Go 中内置的基本类型已经在<a href="https://go101.org/article/basic-types-and-value-literals.html" target="_blank" rel="noopener">内置的基本类型和基本值字面量</a>中引入. 为了使本文完整, 这些内建的基本类型在这里重新列出.</p><ul><li>内建字符串类型: string.</li><li>内建布尔类型: bool.</li><li>内建数字类型:<ul><li>int8, uint8 (byte), int16, uint16, int32 (rune), uint32, int64, uint64, int, uint, uinptr.</li><li>float32, float64.</li><li>complex64, complex128.</li></ul></li></ul><p>除了<a href="https://go101.org/article/string.html" target="_blank" rel="noopener">字符串类型</a>, Go 101 系列文章不会在其他基本类型上作过多解释.</p><h3 id="概念-复合类型"><a href="#概念-复合类型" class="headerlink" title="概念: 复合类型"></a>概念: 复合类型</h3><p>Go 支持以下复合类型:</p><ul><li><a href="https://go101.org/article/pointer.html" target="_blank" rel="noopener">指针类型</a> - 和 C 指针一样.</li><li><a href="https://go101.org/article/struct.html" target="_blank" rel="noopener">结构体类型</a> - 和 C 结构体一样.</li><li><a href="https://go101.org/article/function.html" target="_blank" rel="noopener">函数类型</a> - 函数是 Go 的一等类型.</li><li><a href="https://go101.org/article/container.html" target="_blank" rel="noopener">容器类型</a>:<ul><li>数组类型 - 固定长度的容器类型.</li><li>切片类型 - 动态长度和动态容量的容器类型.</li><li>映射类型 - 映射是关联数组(或字典). 标准 Go 编译器将映射实现为哈希表.</li></ul></li><li><a href="https://go101.org/article/channel.html" target="_blank" rel="noopener">管道类型</a> - 管道(channels) 用于在 goroutine (Go 中的绿色线程) 之间同步数据.</li><li><a href="https://go101.org/article/interface.html" target="_blank" rel="noopener">接口类型</a> - 接口在反射和多态中起着关键作用.</li></ul><p>与基本类型不同, 复合类型可以表示为它们各自的类型字面量. 以下是各种复合类型的一些字面量表示示例.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Assume T is an arbitrary type and Tkey is</span></span><br><span class="line"><span class="comment">// a type supporting comparison (== and !=).</span></span><br><span class="line"></span><br><span class="line">*T         <span class="comment">// a pointer type</span></span><br><span class="line">[<span class="number">5</span>]T       <span class="comment">// an array type</span></span><br><span class="line">[]T        <span class="comment">// a slice type</span></span><br><span class="line"><span class="keyword">map</span>[Tkey]T <span class="comment">// a map type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a struct type</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a function type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">bool</span>, <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">an</span> <span class="title">interface</span> <span class="title">type</span></span></span><br><span class="line"><span class="function"><span class="title">interface</span></span> &#123;</span><br><span class="line">Method0(<span class="keyword">string</span>) <span class="keyword">int</span></span><br><span class="line">Method1() (<span class="keyword">int</span>, <span class="keyword">bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some channel types</span></span><br><span class="line"><span class="keyword">chan</span> T</span><br><span class="line"><span class="keyword">chan</span>&lt;- T</span><br><span class="line">&lt;-<span class="keyword">chan</span> T</span><br></pre></td></tr></table></figure><p>(下面将解释<a href="https://go101.org/article/type-system-overview.html#types-not-support-comparison" target="_blank" rel="noopener">哪些类型不支持比较</a>)</p><h3 id="事实-类型的种类"><a href="#事实-类型的种类" class="headerlink" title="事实: 类型的种类"></a>事实: 类型的种类</h3><p>上面提到的每种基本类型和复合类型都对应于一种类型. 除了这些类型, 引入 unsafe <a href="https://golang.org/pkg/unsafe" target="_blank" rel="noopener">标准库</a>的不安全类型 unsafe.Pointer 也是 Go 中的一种类型.</p><p>所以, 到现在为止(Go 1.10), Go 有 26 种类型.</p><h3 id="语法-类型定义"><a href="#语法-类型定义" class="headerlink" title="语法: 类型定义"></a>语法: 类型定义</h3><p>(类型定义, 或者类型定义声明, 在 Go 1.9 之前称为 <strong>类型声明</strong>. 从 Go 1.9 开始, 类型定义已经成为 Go 中两种类型声明中的一种.)</p><p>在 Go 中, 我们可以使用以下语法来定义新类型. 在下面的例子中, type 是一个关键字.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Define a solo new type.</span></span><br><span class="line"><span class="keyword">type</span> NewTypeName SourceType</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define multiple new types together.</span></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">NewTypeName1 SourceType1</span><br><span class="line">NewTypeName2 SourceType2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>新类型名称必须是标识符.</p><p>注意,</p><ul><li>类型定义中的新定义类型及其各自的源类型是两种截然不同的类型.</li><li>两种不同的定义类型总是两种不同的类型.</li><li>新定义的类型和源类型将共享相同的底层类型(请参阅下面的底层类型), 并且它们的值可以相互转换.</li><li>类型可以在函数体中定义.</li></ul><p>一些类型定义示例:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The following new defined and source types are all basic types.</span></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">MyInt <span class="keyword">int</span></span><br><span class="line">Age   <span class="keyword">int</span></span><br><span class="line">Text  <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The following new defined and source types are all composite types.</span></span><br><span class="line"><span class="keyword">type</span> IntPtr *<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span>&#123;author, title <span class="keyword">string</span>; pages <span class="keyword">int</span>&#125;</span><br><span class="line"><span class="keyword">type</span> Convert <span class="function"><span class="keyword">func</span><span class="params">(in0 <span class="keyword">int</span>, in1 <span class="keyword">bool</span>)</span><span class="params">(out0 <span class="keyword">int</span>, out1 <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">StringArray</span> [5]<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">StringSlice</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// The three defined types can be only used within the function.</span></span><br><span class="line"><span class="keyword">type</span> PersonAge <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> MessageQueue <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span>&#123;Read([]<span class="keyword">byte</span>) <span class="keyword">int</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语法-类型别名声明"><a href="#语法-类型别名声明" class="headerlink" title="语法: 类型别名声明"></a>语法: 类型别名声明</h3><p>(类型别名声明是 Go 1.9 引入的一种新的类型声明.)</p><p>如上所述, Go 中只有两个内置类型别名, byte(uint8 的别名)和 rune(int32 的别名). 他们是 Go 1.9 之前的唯一两种别名.</p><p>从 Go 1.9 开始, 我们可以使用以下语法来声明自定义类型别名. 别名声明的语法与类型定义非常类似, 但请注意每种类型别名声明中都有一个 <em>=</em> .</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">Name = <span class="keyword">string</span></span><br><span class="line">Age  = <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> table = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> Table = <span class="keyword">map</span>[Name]Age</span><br></pre></td></tr></table></figure><p>类型别名必须是标识符. 和类型定义一样, 类型别名也可以在函数体中声明.</p><p>通过上述的声明, Name 是 string 的别名, 他们表示相同的类型. 其他三对类型也是同样的关系.</p><ul><li>Age 和 int</li><li>table 和 map[string]int</li><li>Table 和 map[Name]Age</li></ul><p>事实上, map[string]int 和 map[Name]Age 也表示相同的类型. 所以涉及最后两个类型别名声明的四种类型都表示相同的类型.</p><p>注意, 尽管 table 和 Table 表示相同的类型, Table 是一个可导出类型, 所以它能被其他包引用, 而 table 不能.</p><h3 id="概念-命名类型-vs-非命名类型"><a href="#概念-命名类型-vs-非命名类型" class="headerlink" title="概念: 命名类型 vs 非命名类型"></a>概念: 命名类型 vs 非命名类型</h3><p>在 Go 中,</p><ul><li>如果一个类型有一个名称, 该名称必须是一个标识符, 并且它的名称不是空白标识符 <em>_</em> ,那么这种类型称为命名类型. 所有基本类型都是命名类型.</li><li>如果一个类型不能用一个纯粹的标识符来表示, 那么这个类型就是一个未命名的类型. 在上面的例子中, 由它们各自的类型字面量表示的复合类型都是未命名的类型.</li></ul><p>未命名类型必须是复合类型, 反之则不然, 因为复合类型可以是定义类型和别名类型.</p><h3 id="概念-定义类型-vs-非定义类型"><a href="#概念-定义类型-vs-非定义类型" class="headerlink" title="概念: 定义类型 vs 非定义类型"></a>概念: 定义类型 vs 非定义类型</h3><p>在 Go 1.9 之前, 只有一种类型声明. 这是当前的类型定义. 所以非常清楚的是, 一个命名类型必须是一个定义类型, 并且定义类型和命名类型在 Go 1.9 之前几乎是相同的概念. 但是, 从 Go 1.9 开始, 由于引入了类型别名, 事情变得有点复杂. 现在, 一个命名类型也可以是一个类型别名, 而一个别名类型可能是一个定义的类型或不是.</p><p>为了让许多解释变得简单明了, Go 101 采用了一种新的术语, 即非定义类型, 来表示未命名类型和未命名类型的别名. 这个术语在 Go 规范中没有.</p><p>所有基本类型都已定义. 非定义类型必须是复合类型.</p><p>在下面的例子中. 别名类型 C 和类型字面量 []string 都是非定义类型, 但类型 A 和别名类型 B 都是定义类型.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> B = A</span><br><span class="line"><span class="keyword">type</span> C = []<span class="keyword">string</span></span><br></pre></td></tr></table></figure><h3 id="概念-底层类型"><a href="#概念-底层类型" class="headerlink" title="概念: 底层类型"></a>概念: 底层类型</h3><p>在 Go 中, 每种类型都有一个底层类型. 规则是:</p><ul><li>对于内置的基本类型, 底层类型就是自身.</li><li>unsafe.Pointer 的底层类型是自身.</li><li>未命名类型的底层类型(它必须是复合类型)是自身.</li><li>在类型声明中, 新的声明类型和源类型具有相同的底层类型.</li></ul><p>例子:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The underlying types of the following ones are both int.</span></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">MyInt <span class="keyword">int</span></span><br><span class="line">Age   MyInt</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The following new types have different underlying types.</span></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">IntSlice   []<span class="keyword">int</span>   <span class="comment">// underlying type is []int</span></span><br><span class="line">MyIntSlice []MyInt <span class="comment">// underlying type is []MyInt</span></span><br><span class="line">AgeSlice   []Age   <span class="comment">// underlying type is []Age</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The underlying types of Ages and AgeSlice are both []Age.</span></span><br><span class="line"><span class="keyword">type</span> Ages AgeSlice</span><br></pre></td></tr></table></figure><p>如何跟踪给定用户定义类型的底层类型? 规则是, 当内建的基本类型, unsafe.Pointer 或未命名的类型被满足时, 跟踪将被停止. 以上面的类型声明为例, 我们来追踪一下它们的底层类型.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyInt → int</span><br><span class="line">Age → MyInt → int</span><br><span class="line">IntSlice → []int</span><br><span class="line">MyIntSlice → []MyInt → []int</span><br><span class="line">AgeSlice → []Age → []MyInt → []int</span><br><span class="line">Ages → AgeSlice → []Age → []MyInt → []int</span><br></pre></td></tr></table></figure><p>在 Go 中,</p><ul><li>底层类型为 bool 的类型称为布尔类型;</li><li>底层类型是任何内置整数类型的类型称为整数类型;</li><li>底层类型为 float32 或 float64 的类型称为浮点类型;</li><li>底层类型为 complex64 或 complex128 的类型称为复数类型;</li><li>整数, 浮点和复数类型也称为数字类型;</li><li>底层类型为字符串的类型称为字符串类型.</li></ul><p>底层类型的概念在 <a href="https://go101.org/article/value-conversions-assignments-and-comparisons.html" target="_blank" rel="noopener">Go 的值转换, 赋值和比较</a> 中扮演着重要的角色.</p><h3 id="概念-值"><a href="#概念-值" class="headerlink" title="概念: 值"></a>概念: 值</h3><p>一个类型的实例称为该类型的值. 一个类型可能有很多值, 但它只有一个零值. 相同类型的值共享一些共同属性.</p><p>每种类型都有一个零值, 可以将其视为该类型的默认值. 预定义的 nil 标识符可以用来表示切片, 映射, 函数, 管道, 指针(包括类型不安全的指针)和接口类型的零值. 关于 nil 的更多内容, 请稍后阅读 <a href="https://lingchao.xin/post/go-nils.html">Go 中的 nil</a> .</p><p>代码中有几种值的表示形式, 包括<a href="https://go101.org/article/basic-types-and-value-literals.html" target="_blank" rel="noopener">字面量</a>, <a href="https://go101.org/article/constants-and-variables.html#constant" target="_blank" rel="noopener">命名常量</a>, <a href="https://go101.org/article/constants-and-variables.html#variable" target="_blank" rel="noopener">变量</a>和<a href="https://go101.org/article/expressions-and-statements.html" target="_blank" rel="noopener">表达式</a>, 但前三者可以被视为后者的特例.</p><p>值可能是<a href="https://go101.org/article/constants-and-variables.html#untyped-value" target="_blank" rel="noopener">有类型或无类型</a>的. 除了预定义的 nil 之外, 复合类型的值都是有类型的. 无类型值都是基本值或预定义的 nil.</p><p>在文章<a href="https://go101.org/article/basic-types-and-value-literals.html" target="_blank" rel="noopener">基本类型和基本值字面量</a>中引入了所有类型的基本值字面量. 在 Go 中还有两种字面量, 复合字面量和函数字面量.</p><p>顾名思义, 函数字面量用于表示函数值. 实际上, 函数字面量并不陌生. <a href="https://go101.org/article/function-declarations-and-calls.html#declaration" target="_blank" rel="noopener">函数声明</a>由函数字面量和函数标识符组成. 换句话说, 函数声明只有一个部分, 即函数标识符部分, 而不是其对应的函数字面量部分. 每个函数字面量也是一个匿名函数. 函数字面量将在 <a href="https://go101.org/article/function.html" target="_blank" rel="noopener">Go 中的函数</a>中正式引入.</p><p>复合字面量用于表示结构体类型和容器类型(数组, 片和映射)的值, 请阅读 <a href="https://go101.org/article/struct.html" target="_blank" rel="noopener">Go中的结构体</a> 和 <a href="https://go101.org/article/container.html" target="_blank" rel="noopener">Go 中的容器</a>以获取详细信息.</p><p>没有字面量来表示指针, 管道和接口类型的值.</p><h3 id="概念-值部分"><a href="#概念-值部分" class="headerlink" title="概念: 值部分"></a>概念: 值部分</h3><p>当运行的时候, 许多值都存储在内存中的某处. 在 Go 中, 每个这样的值都有一个直接的部分, 然而, 其中的一些都有一个或多个间接部分. 每个值部分都占用连续的内存段. 值的间接底层部分由其直接部分通过指针引用.</p><p>Go 规范中未定义术语 <strong>值部分</strong>. 它仅在 Go 101 中用于简化一些解释并帮助 Go 程序员更好地理解 Go 类型和值. 请阅读文章 <a href="https://go101.org/article/value-part.html" target="_blank" rel="noopener">值部分</a> 来了解更多关于值部分的信息.</p><h3 id="概念-值大小"><a href="#概念-值大小" class="headerlink" title="概念: 值大小"></a>概念: 值大小</h3><p>当一个值存储在内存中时, 该值的直接部分占用的字节数称为该值的大小. 相同类型的所有值具有相同的值大小, 因此类型值的大小通常称为类型值大小的大小. 我们可以使用 unsafe 标准库中的 Sizeof 函数来获取任何值的大小.</p><p>Go 规范没有规定非数字类型的值大小要求. 文章 <a href="https://go101.org/article/basic-types-and-value-literals.html" target="_blank" rel="noopener">基本类型和基本值字面量</a> 中列出了各种基本数值类型的值大小要求.</p><h3 id="概念-接口值的动态类型和动态值"><a href="#概念-接口值的动态类型和动态值" class="headerlink" title="概念: 接口值的动态类型和动态值"></a>概念: 接口值的动态类型和动态值</h3><p>接口值是其类型为接口类型的值.</p><p>每个接口值都可以包含一个非接口值. 装入接口值中的值称为接口值的动态值. 动态值的类型称为接口值的动态类型. 接口值没有装任何东西是一个 nil 接口值.</p><p>关接口类型和值的更多信息, 请阅读<a href="https://go101.org/article/interface.html" target="_blank" rel="noopener">这篇文章</a>.</p><h3 id="概念-函数类型签名"><a href="#概念-函数类型签名" class="headerlink" title="概念: 函数类型签名"></a>概念: 函数类型签名</h3><p>函数类型的签名由函数的输入参数定义列表和输出结果定义列表组成.</p><p>函数名和函数体不是函数签名的组成部分. 参数和结果类型对函数签名很重要, 但参数和结果名称并不重要.</p><p>请阅读 <a href="https://go101.org/article/function.html" target="_blank" rel="noopener">Go 中的函数</a> 以获取有关函数类型和函数值的更多详细信息.</p><h3 id="概念-类型的方法和方法集"><a href="#概念-类型的方法和方法集" class="headerlink" title="概念: 类型的方法和方法集"></a>概念: 类型的方法和方法集</h3><p>在 Go 中, 有些类型可以有<a href="https://go101.org/article/method.html" target="_blank" rel="noopener">方法</a>. 方法也可以被称为成员函数.</p><p>类型的方法集由一个类型的所有方法组成. 如果一个类型的方法集是一个接口类型的方法集的超集, 我们说这个类型实现了该接口类型.</p><h3 id="概念-接口类型的字段"><a href="#概念-接口类型的字段" class="headerlink" title="概念: 接口类型的字段"></a>概念: 接口类型的字段</h3><p>结构体类型由成员变量的集合组成. 每个成员变量都称为结构体类型的字段. 例如, 以下结构体类型 Book 有三个字段, author, title 和 pages.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">author <span class="keyword">string</span></span><br><span class="line">title  <span class="keyword">string</span></span><br><span class="line">pages  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关结构类型和值的更多信息, 请阅读 <a href="https://go101.org/article/struct.html" target="_blank" rel="noopener">Go 中的结构体</a>.</p><p>在 Go 中, 我们可以通过将此类型<a href="https://go101.org/article/type-embedding.html" target="_blank" rel="noopener">嵌入</a>结构体类型来扩展满足某些条件的类型.</p><h3 id="概念-指针类型的基类型"><a href="#概念-指针类型的基类型" class="headerlink" title="概念: 指针类型的基类型"></a>概念: 指针类型的基类型</h3><p>对于指针类型, 假设它的底层类型可以用字面表示为 *T, 则 T 被称为指针类型的基类型.</p><p>有关指针类型和值的更多信息, 请阅读 <a href="https://go101.org/article/pointer.html" target="_blank" rel="noopener">Go 中的指针</a>.</p><h3 id="概念-容器类型"><a href="#概念-容器类型" class="headerlink" title="概念: 容器类型"></a>概念: 容器类型</h3><p>数组, 切片和映射可以视为正式的内置容器类型.</p><p>非正式地, 字符串和管道类型也可以被视为容器类型.</p><p>容器类型的每个值都有一个长度, 容器类型要么是正式的, 要么是非正式的.</p><p>有关容器类型和值的更多信息, 请阅读 <a href="https://go101.org/article/container.html" target="_blank" rel="noopener">Go 中的容器</a>.</p><h3 id="概念-映射类型的键类型"><a href="#概念-映射类型的键类型" class="headerlink" title="概念: 映射类型的键类型"></a>概念: 映射类型的键类型</h3><p>如果映射类型的底层类型可以表示为 map[Tkey]T, 那么 Tkey 被称为映射类型的键类型. Tkey 必须是可比较的类型.</p><h3 id="概念-容器类型的键类型和元素类型"><a href="#概念-容器类型的键类型和元素类型" class="headerlink" title="概念: 容器类型的键类型和元素类型"></a>概念: 容器类型的键类型和元素类型</h3><p>存储在容器中的元素的类型必须相同. 元素的标识类型被称为容器值的类型的元素类型.</p><ul><li>对于数组类型, 如果其底层类型为 [N]T, 则其元素类型为 T.</li><li>对于切片类型, 如果其底层类型为 []T, 则其元素类型为 T.</li><li>对于映射类型, 如果其底层类型是 map[Tkey]T, 则其元素类型是 T.</li><li>对于管道类型, 如果其底层类型是 chan T, chan&lt;- T 或 &lt;-chan T, 则其元素类型是 T.</li><li>任何字符串类型的元素类型总是 byte (又名 uint8).</li></ul><h3 id="概念-管道类型的方向"><a href="#概念-管道类型的方向" class="headerlink" title="概念: 管道类型的方向"></a>概念: 管道类型的方向</h3><p>管道值可以被视为同步的先进先出(FIFO)队列. 管道类型和值有方向.</p><ul><li>可发送和可接收的管道值称为双向管道. 它的类型称为双向管道类型. 双向管道类型在字面量中表示为 chan T.</li><li>仅可发送的管道值被称为发送专用管道. 它的类型被称为发送管道类型. 只发送管道类型在字面量中表示为 chan&lt;- T.</li><li>仅可接收的管道值被称为只收管道. 它的类型被称为只接收管道类型. 只接收管道类型在字面量中表示为 &lt;-chan T.</li></ul><p>有关管道类型和值的更多信息, 请阅读 <a href="https://go101.org/article/channel.html" target="_blank" rel="noopener">Go 中的管道</a>.</p><h3 id="事实-支持或不支持比较的类型"><a href="#事实-支持或不支持比较的类型" class="headerlink" title="事实: 支持或不支持比较的类型"></a>事实: 支持或不支持比较的类型</h3><p>目前(Go 1.10), 以下类型不支持比较(使用 == 和 != 运算符):</p><ul><li>切片类型</li><li>映射类型</li><li>函数类型</li><li>任何具有类型无法比较的字段的结构体类型以及任何元素类型无法比较的数组类型.</li></ul><p>以上列出的类型称为无法比较的类型. 编译器禁止比较两个不可比较类型的值.</p><p>所有基本类型, 指针类型, 管道类型和接口类型都是可比的. 但是, 如果两个接口值的动态类型都是相同的不可比较类型, 那么比较两个接口值可能会在运行时出现 panic.</p><p>不可比的类型的值称为无法比较的值. 一些可比较类型的值也可能无法比较. 例如, 具有不可比较的动态类型的接口值是一个无法比较的值. 比较一个无法比较类型可比较的值会在运行时引发 panic.</p><p>我们可以从文章 <a href="https://go101.org/article/value-conversions-assignments-and-comparisons.html" target="_blank" rel="noopener">Go 的值转换, 赋值和比较</a> 中详细了解比较的详细规则.</p><p>任何映射类型的键类型必须是可比较类型. 因此, 上面列出的类型不能用作映射的键类型.</p><h3 id="事实-Go-中的面向对象的编程"><a href="#事实-Go-中的面向对象的编程" class="headerlink" title="事实: Go 中的面向对象的编程"></a>事实: Go 中的面向对象的编程</h3><p>Go 不是一个全功能的面向对象编程语言, 但 Go 确实支持一些面向对象的编程风格. 有关详细信息, 请阅读以下列出的文章:</p><ul><li><a href="https://go101.org/article/method.html" target="_blank" rel="noopener">Go 中的方法</a>.</li><li><a href="https://go101.org/article/interface.html#implementation" target="_blank" rel="noopener">Go 中的接口实现</a>.</li><li><a href="https://go101.org/article/type-embedding.html" target="_blank" rel="noopener">Go 中的类型嵌入</a>.</li></ul><h3 id="事实-Go-中的范型"><a href="#事实-Go-中的范型" class="headerlink" title="事实: Go 中的范型"></a>事实: Go 中的范型</h3><p>Go 中的范型功能仅限于内置类型和函数. 截至目前(v1.10), Go 不支持自定义类型和自定义函数的范型. 有关详细信息, 请阅读 <a href="https://go101.org/article/generic.html" target="_blank" rel="noopener">Go 中的内置范型</a>.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
            <tag> go101 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go 的值拷贝代价</title>
      <link href="/post/go-value-copy-cost.html"/>
      <url>/post/go-value-copy-cost.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自 <a href="https://go101.org/article/value-copy-cost.html" target="_blank" rel="noopener">Go Value Copy Costs</a> 版权@归原文所有.<p></p><p>值拷贝在 Go 语言编程中普遍发生. 赋值, 参数传递, channel 值发送以及接收操作都会涉及值拷贝. 本文将讨论 Go 中的值拷贝代价.</p><h3 id="值大小"><a href="#值大小" class="headerlink" title="值大小"></a>值大小</h3><p>值的大小意味着该值(<a href="https://go101.org/article/value-part.html" target="_blank" rel="noopener">直接部分</a>)将在内存中占用多少字节. 值的间接底层部分不影响值的大小.</p><p>在 Go 中, 如果两个值的类型属于同一类型, 并且类型不是基本类型, 字符串类型, 接口类型, 数组类型和结构体类型, 那么这两个值的大小总是相等.</p><p>事实上, 对于标准的 Go 编译器/运行时, 两个字符串值的大小也总是相等, 对于两个接口值的大小也是一样的.</p><p>对于标准的 Go 编译器/运行时, 相同类型的值具有相同的值大小. 因此, 我们通常将值的大小称为值类型的大小.</p><p>数组类型的大小取决于元素类型的大小和数组类型的长度. 数组类型大小是数组元素类型大小与数组长度的乘积.</p><p>结构类型的大小取决于它的所有字段. 因为在两个相邻字段之间可能存在一些填充字节, 所以结构类型大小不小于(并且通常大于)结构字段的相应类型大小之和.</p><p>下表列出了各种类型的值大小. 在表中, 一个字表示一个本地字, 它在 32 位操作系统上是 4 字节, 在 64 位操作系统上是 8 字节.</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">Go 1.10 的值大小</th><th style="text-align:left">Go 规范要求</th></tr></thead><tbody><tr><td style="text-align:left">bool</td><td style="text-align:left">1 字节</td><td style="text-align:left">未明确</td></tr><tr><td style="text-align:left">int8, uint8(byte)</td><td style="text-align:left">1 字节</td><td style="text-align:left">1 字节</td></tr><tr><td style="text-align:left">int16, uint16</td><td style="text-align:left">2 字节</td><td style="text-align:left">2 字节</td></tr><tr><td style="text-align:left">int32 (rune), uint32, float32</td><td style="text-align:left">4 字节</td><td style="text-align:left">4 字节</td></tr><tr><td style="text-align:left">int64, uint64, float64, complex64</td><td style="text-align:left">8 字节</td><td style="text-align:left">8 字节</td></tr><tr><td style="text-align:left">complex128</td><td style="text-align:left">16 字节</td><td style="text-align:left">16 字节</td></tr><tr><td style="text-align:left">int, uint</td><td style="text-align:left">1 字</td><td style="text-align:left">体系结构相关, 4 或 8 个字节</td></tr><tr><td style="text-align:left">uintptr</td><td style="text-align:left">1 字</td><td style="text-align:left">足够大以存储指针值的未解释位</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">2 字</td><td style="text-align:left">未明确</td></tr><tr><td style="text-align:left">pointer</td><td style="text-align:left">1 字</td><td style="text-align:left">未明确</td></tr><tr><td style="text-align:left">slice</td><td style="text-align:left">3 字</td><td style="text-align:left">未明确</td></tr><tr><td style="text-align:left">map</td><td style="text-align:left">1 字</td><td style="text-align:left">未明确</td></tr><tr><td style="text-align:left">channel</td><td style="text-align:left">1 字</td><td style="text-align:left">未明确</td></tr><tr><td style="text-align:left">function</td><td style="text-align:left">1 字</td><td style="text-align:left">未明确</td></tr><tr><td style="text-align:left">interface</td><td style="text-align:left">2 字</td><td style="text-align:left">未明确</td></tr><tr><td style="text-align:left">struct</td><td style="text-align:left">所有字段的大小总和 + 填充字节数</td><td style="text-align:left">如果结构体类型不包含大于零的字段, 则其大小为零</td></tr><tr><td style="text-align:left">array</td><td style="text-align:left">(元素值大小) * (数组长度)</td><td style="text-align:left">如果数组的元素类型大小为零, 则其大小为零</td></tr></tbody></table><h3 id="值拷贝代价"><a href="#值拷贝代价" class="headerlink" title="值拷贝代价"></a>值拷贝代价</h3><p>一般来说, 拷贝值的成本与值的大小成正比. 但是, 值的大小并不是计算值拷贝的唯一因素. 不同的 CPU 体系结构可能会针对具有特定大小的值专门优化值拷贝. 在实践中, 我们可以将大小小于四个本地字的值视为小值. 拷贝小值的成本很小.</p><p>除了大型结构和数组类型的值(对于标准的 Go 编译器), Go 中的大部分值都是小值.</p><p>为避免参数传递和 channel 值发送和接收操作中的大值复制成本, 我们应该尽量避免使用大型结构和数组类型作为函数和方法参数类型(包括方法接收器类型) 并避免使用大型结构和数组类型作为 channel 元素类型. 我们可以使用基类型为大型结构和数组类型的指针类型来应对这种情况.</p><p>另一方面, 我们还应该考虑在运行时使用太多指针造成的垃圾回收的负面影响. 因此, 是否应该使用大型结构体和数组类型或其相应的指针类型取决于特定的场景.</p><p>通常, 我们不应该使用基类型为 slice, map, channel map, function, 字符串和接口类型的指针类型. 这些假定的基本类型的值拷贝的成本很小.</p><p>如果元素类型是大值类型, 我们还应该尝试避免使用两次迭代变量形式来迭代数组和切片元素, 因为每个元素值都将被复制到迭代过程中的第二个迭代变量(译注: for range 中的 v).</p><p>以下是一个示例, 用于对 slice 元素迭代的不同方式进行基准测试.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;a, b, c, d, e <span class="keyword">int64</span>&#125;</span><br><span class="line"><span class="keyword">var</span> sX, sY, sZ = <span class="built_in">make</span>([]S, <span class="number">1000</span>), <span class="built_in">make</span>([]S, <span class="number">1000</span>), <span class="built_in">make</span>([]S, <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">var</span> sumX, sumY, sumZ <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_Loop</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">sumX = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(sX); j++ &#123;</span><br><span class="line">sumX += sX[j].a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_Range_OneIterVar</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">sumZ = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> sY &#123;</span><br><span class="line">sumZ += sY[j].a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark_Range_TwoIterVar</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">sumY = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> sY &#123;</span><br><span class="line">sumY += v.a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试文件的目录中运行基准测试, 我们将得到类似于以下的结果:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Benchmark_Loop-4                500000   3228 ns/op</span><br><span class="line">Benchmark_Range_OneIterVar-4    500000   3203 ns/op</span><br><span class="line">Benchmark_Range_TwoIterVars-4   200000   6616 ns/op</span><br></pre></td></tr></table></figure><p>我们可以发现, 双迭代变量形式的效率远低于其他两种形式.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
            <tag> go101 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为什么 Go 会有 nil channels</title>
      <link href="/post/why-are-there-nil-channels-in-go.html"/>
      <url>/post/why-are-there-nil-channels-in-go.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自 <a href="https://medium.com/justforfunc/why-are-there-nil-channels-in-go-9877cc0b2308" target="_blank" rel="noopener">Why are there nil channels in Go</a> 版权@归原文所有.<p></p><p>每个写过 Go 的人都知道 channels. 我们大多数人也知道 channels 的默认值是 nil. 但是我们很多人都不知道这个 nil 值是有用的. (译注: 老实说读到这篇文章之前我也认为 nil channels 没什么用, 不仅没用, 我还觉得对 nil channels 的写入操作应该 panic 才对, 就像对 nil map 的写入是 panic 一样, 甚至认为这是 Go 的设计不一致问题)</p><p>我从一个学习 Go 的开发者的 twitter 上得到了同样的问题, 他想知道是否 Go nil channels 的存在仅仅是为了完整性.</p><p>想知道是否有用是有意义的, 因为它们的行为表现的截然相反.</p><p>给定一个 nil channel c:</p><ul><li>&lt;-c 从 c 接收将永远阻塞</li><li>c &lt;- v 发送值到 c 会永远阻塞</li><li>close(c) 关闭 c 引发 panic</li></ul><p>但我仍然坚持他们是有用的. 让我先介绍一个问题, 其解决方案起初看起来很明显, 但实际上并不像人们想象的那么容易, 实际上却从 nil channels 中受益.</p><h3 id="合并-channels"><a href="#合并-channels" class="headerlink" title="合并 channels"></a>合并 channels</h3><p>如果你选择接受它, 你的任务是编写一个函数, 给定两个 channels a 和 b 返回一个相同类型的 channel c. a 或 b 中收到的每个元素都将发送给 c, 并且一旦 a 和 b 都关闭, c 也将被关闭.</p><p><a href="/static/images/0_aKHj7JJ0UCDEYu23.png" class="gallery-item"><img src="/static/images/0_aKHj7JJ0UCDEYu23.png" width="700px" height="371px"></a></p><h3 id="一个辅助函数"><a href="#一个辅助函数" class="headerlink" title="一个辅助函数"></a>一个辅助函数</h3><p>在我们开始之前, 让我们编写一个函数来帮助我们测试我们的解决方案. 此函数返回一个 channel , 该 channel 最终将随机接收所有给定的值并通过关闭完成.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">asChan</span><span class="params">(vs ...<span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> vs &#123;</span><br><span class="line">c &lt;- v</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">1000</span>)) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数创建一个 channel c, 启动一个新的 goroutine, 将值发送到创建的 channel c, 最后返回 channel c.</p><p>在处理 channels 时这是很常见的模式, 因此在继续阅读之前, 请确保你了解它的工作原理.</p><h3 id="让我们开始吧"><a href="#让我们开始吧" class="headerlink" title="让我们开始吧"></a>让我们开始吧</h3><p>由于我们没有对 a 或 b 的偏好, 所以我们将避免通过选择我们应该首先 range 哪个 channel 来创建偏好.</p><p>相反我们会保持这种对称性, 并且使用一个无限循环来 select 这两个 channels.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(a, b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v := &lt;-a:</span><br><span class="line">c &lt;- v</span><br><span class="line"><span class="keyword">case</span> v := &lt;-b:</span><br><span class="line">c &lt;- v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这看起来不错, 让我们写一个快速测试并运行它.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := asChan(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line">b := asChan(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br><span class="line">c := merge(a, b)</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这应该以某种顺序打印 1 到 8 并成功结束. 让我们看看发生了什么.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; go run main.go</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">😱</span><br></pre></td></tr></table></figure><p>好吧, 很明显这不好, 因为该程序没有结束. 一旦它打印出从 1 到 8 的值, 它将开始永远打印 0.</p><h3 id="处理关闭的-channels"><a href="#处理关闭的-channels" class="headerlink" title="处理关闭的 channels"></a>处理关闭的 channels</h3><p>如果我们从一个关闭的 channel 接收会发生什么 ? 我们会得到 channel 类型的默认值. 在我们的例子中, 类型是 int, 所以值是 0.</p><p>我们可以通过与 0 比较来检查是否 channel 已经关闭, 但是如果我们接收到的其中一个值是 0, 会怎么样 ? 相反, 我们可以使用 “v, ok” 语法:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok := &lt;- c</span><br></pre></td></tr></table></figure><p>当使用这个语法时, ok 是一个布尔值, 只要 channel 是开着的, 它就是 true. 知道这一点, 我们可以避免将多余的 0 发送给 c .</p><p>在某一点上我们也应该停止迭代, 所以让我们也跟踪两个 channels 何时关闭.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(a, b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">adone, bdone := <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> !adone || !bdone &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-a:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">adone = <span class="literal">true</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">c &lt;- v</span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-b:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">bdone = <span class="literal">true</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">c &lt;- v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这看起来可能有用 ! 让我们来运行它.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; go run main.go</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line">goroutine 1 [chan receive]:</span><br><span class="line">main.main()</span><br><span class="line">        /Users/francesc/src/github.com/campoy/campoy.cat/site/static/code/nilchans/main.go:13 +0x186</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure><p>哎呀, 我们忘了一些事情. 是什么呢 ? 我们可以看到只有一个 goroutine 在运行, 并且它阻塞在第 13 行:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> c &#123;</span><br></pre></td></tr></table></figure><p>你能看出问题是什么吗 ? range 语句迭代 channel 中的所有值直到 channel 关闭. 但是谁关闭了这个 channel ?</p><p>我们忘了 ! 让我们在我们的 goroutine 中添加 defer 语句, 以确保该 channel 最终关闭.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(a, b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">adone, bdone := <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> !adone || !bdone &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-a:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">adone = <span class="literal">true</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">c &lt;- v</span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-b:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">bdone = <span class="literal">true</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">c &lt;- v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意, defer 语句位于新的 goroutine 中调用的匿名函数中, 而不是在 merge 中. 否则, 只要我们退出 merage, c 就会被关闭, 那么发送一个值给它将引发 panic.</p><p>让我们运行它, 看看会发生什么.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; go run main.go</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>这看起来很棒 … 但是是这样吗 ?</p><h3 id="繁忙的循环"><a href="#繁忙的循环" class="headerlink" title="繁忙的循环"></a>繁忙的循环</h3><p>我们迄今为止编写的代码非常好. 它在功能上是正确的, 但是如果你在生产中部署了它, 你最终可能会遇到性能问题.</p><p>为了向你显示问题所在, 让我们添加一些日志记录.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(a, b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">adone, bdone := <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> !adone || !bdone &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-a:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">                    log.Println(<span class="string">"a is done"</span>)</span><br><span class="line">adone = <span class="literal">true</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">c &lt;- v</span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-b:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">                    log.Println(<span class="string">"b is done"</span>)</span><br><span class="line">bdone = <span class="literal">true</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">c &lt;- v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们运行它, 看看会发生什么.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; go run main.go</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">a is done</span><br><span class="line">2018/01/14 20:47:22 b is done</span><br><span class="line">... 😱</span><br><span class="line">2018/01/14 20:47:23 b is done</span><br><span class="line">2018/01/14 20:47:23 a is done</span><br></pre></td></tr></table></figure><p>呃哦 ! 似乎一旦一个 channel 完成, 我们就不停地迭代 !</p><p>毕竟它确实有意义. 正如我们在开始时看到的, 从一个关闭的 channel 读取从不阻塞.</p><p>因此, 只要两个 channels 都处于打开状态, select 语句将会阻塞, 直到新元素准备就绪, 但是一旦其中一个关闭, 我们将迭代并浪费 CPU. 这也被称为繁忙的循环, 并不好.</p><h3 id="在-select-语句中禁用一个-case"><a href="#在-select-语句中禁用一个-case" class="headerlink" title="在 select 语句中禁用一个 case"></a>在 select 语句中禁用一个 case</h3><p>为了避免之前描述的繁忙循环, 我们希望禁用 select 语句的一部分. 具体来说, 当 a 关闭的时候我们想移除 (case v, ok := &lt;- a), b 也一样. 但是怎么做呢 ?</p><p>正如我们在开头提到的那样, 从 nil channels 接收数据会永远阻塞. 所以为了禁用一个从 channel 接收数据的 case, 我们可以简单将 channel 设置为 nil !</p><p>然后, 我们可以停止使用 adone 和 bdone, 而是检查 a 和 b 是否为 nil .</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(a, b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line"><span class="keyword">for</span> a != <span class="literal">nil</span> || b != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-a:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">"a is done"</span>)</span><br><span class="line">a = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">c &lt;- v</span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-b:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">"b is done"</span>)</span><br><span class="line">b = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">c &lt;- v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好, 希望这可以避免不必要的循环. 我们来试试吧.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; go run main.go</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">b is done</span><br><span class="line">a is done</span><br></pre></td></tr></table></figure><p>最终解决方案的代码在 <a href="https://github.com/campoy/justforfunc/blob/master/26-nil-chans/main.go" target="_blank" rel="noopener">GitHub</a> 上.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go 中的 nil</title>
      <link href="/post/go-nils.html"/>
      <url>/post/go-nils.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自 <a href="https://go101.org/article/nil.html" target="_blank" rel="noopener">nils In Go</a> 版权@归原文所有.<p></p><p>nil 是 Go 中一个熟悉而重要的预定义标识符. 它是很多类型零值(zero values)的字面量表示. 很多有一些其他流行语言经验的 Go 程序员新手视 nil 为其他语言 null(或者 NULL)的副本. 这是部分正确的, 但是 Go 中的 nil 和其他语言的 null(或者 NULL)有很多不同之处.</p><p>本文的剩余部分将列出与 nil 有关的各种事实和细节.</p><h3 id="Go-中的-nil-是一个预定义标识符"><a href="#Go-中的-nil-是一个预定义标识符" class="headerlink" title="Go 中的 nil 是一个预定义标识符"></a>Go 中的 nil 是一个预定义标识符</h3><p>你可以使用 nil 而不用声明它.</p><h3 id="nil-可以表示很多类型的零值"><a href="#nil-可以表示很多类型的零值" class="headerlink" title="nil 可以表示很多类型的零值"></a>nil 可以表示很多类型的零值</h3><p>在 Go 中, nil 可以表示以下类型的零值:</p><ul><li>pointer (包括类型不安全的)</li><li>map</li><li>slice</li><li>function</li><li>channel</li><li>interface</li></ul><p>换句话说, 在 Go 中, nil 可能是许多不同类型的值.</p><h3 id="nil-不是默认类型"><a href="#nil-不是默认类型" class="headerlink" title="nil 不是默认类型"></a>nil 不是默认类型</h3><p>Go 中的每个其他预定义标识符都有一个默认类型. 比如,</p><ul><li>true 和 false 的默认类型都是 bool 类型.</li><li>iota 的默认类型是 int.</li></ul><p>但是 nil 没有默认类型, 尽管它有很多可能的类型. 编译器必须有足够的信息来从上下文中推导出 nil 的类型.</p><p>例如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 以下代码行不能编译.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">v := nil</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器必须有足够的信息才可以推断 nil 的类型.</span></span><br><span class="line">_ = (*<span class="keyword">struct</span>&#123;&#125;)(<span class="literal">nil</span>)</span><br><span class="line">_ = []<span class="keyword">int</span>(<span class="literal">nil</span>)</span><br><span class="line">_ = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>(<span class="literal">nil</span>)</span><br><span class="line">_ = <span class="keyword">chan</span> <span class="keyword">string</span>(<span class="literal">nil</span>)</span><br><span class="line">_ = (<span class="function"><span class="keyword">func</span><span class="params">()</span>)<span class="params">(<span class="literal">nil</span>)</span></span></span><br><span class="line"><span class="function">_ = <span class="title">interface</span></span>&#123;&#125;(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些代码行和上面的代码行等价.</span></span><br><span class="line"><span class="keyword">var</span> _ *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> _ []<span class="keyword">int</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> _ <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> _ <span class="keyword">chan</span> <span class="keyword">string</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> _ <span class="function"><span class="keyword">func</span><span class="params">()</span> = <span class="title">nil</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> _ <span class="title">interface</span></span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go-中的-nil-不是一个关键字"><a href="#Go-中的-nil-不是一个关键字" class="headerlink" title="Go 中的 nil 不是一个关键字"></a>Go 中的 nil 不是一个关键字</h3><p>预定义的 nil 可以被覆盖(shadowed).</p><p>例如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="literal">nil</span> := <span class="number">123</span></span><br><span class="line">fmt.Println(<span class="literal">nil</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如下代码行会产生编译错误, 因为当前作用域 nil 代表一个 nil 值.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">var _ map[string]int = nil</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(顺便说一句, 在许多其他语言中的 null 和 NULL 也不是关键字.)</p><h3 id="不同类型的-nil-值的大小-Size-可能不一样"><a href="#不同类型的-nil-值的大小-Size-可能不一样" class="headerlink" title="不同类型的 nil 值的大小(Size)可能不一样"></a>不同类型的 nil 值的大小(Size)可能不一样</h3><p>一种类型的所有值的内存布局总是相同的. 该类型的 nil 值也不例外. nil 的大小总是与相同类型的非 nil 的大小相同. 因此, 表示不同类型的不同零值的 nil 标识符可能具有不同的大小.</p><p>例如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(p)) <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span> = <span class="literal">nil</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(s)) <span class="comment">// 24, 译注: slice 的实现包含一个 array(unsafe.Pointer 类型), 一个 len (int 类型) 以及一个 cap (int 类型), 所以 size 为 24, 参见: https://golang.org/src/runtime/slice.go#L11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span> = <span class="literal">nil</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(m)) <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">string</span> = <span class="literal">nil</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(c)) <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span> = <span class="title">nil</span></span></span><br><span class="line"><span class="function"><span class="title">fmt</span>.<span class="title">Println</span><span class="params">(unsafe.Sizeof(f)</span>) // 8</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">i</span> <span class="title">interface</span></span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(i)) <span class="comment">// 16, 译注: interface&#123;&#125; 的内部实现是一个 eface 类型, 包含一个 _type 指针类型 以及一个 data unsafe.Pointer 类型, 所以 size 为 16, 参见: https://golang.org/src/runtime/runtime2.go#L148</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大小是编译器和架构相关的. 上述打印结果适用于 64 位架构和标准 Go 编译器. 对于 32 位架构, 打印大小将减半. 对于标准的 Go 编译器, 不同种类的相同类型的两个 nil 值的大小总是相同的. 例如, 两个不同 slice 类型 []int 和 []string 的两个 nil 值的大小是相同的.</p><h3 id="两种不同类型的两个-nil-值可能不可比较"><a href="#两种不同类型的两个-nil-值可能不可比较" class="headerlink" title="两种不同类型的两个 nil 值可能不可比较"></a>两种不同类型的两个 nil 值可能不可比较</h3><p>例如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如下代码无法编译.</span></span><br><span class="line"><span class="keyword">var</span> _ = (*<span class="keyword">int</span>)(<span class="literal">nil</span>) == (*<span class="keyword">bool</span>)(<span class="literal">nil</span>)         <span class="comment">// error: mismatched types.</span></span><br><span class="line"><span class="keyword">var</span> _ = (<span class="keyword">chan</span> <span class="keyword">int</span>)(<span class="literal">nil</span>) == (<span class="keyword">chan</span> <span class="keyword">bool</span>)(<span class="literal">nil</span>) <span class="comment">// error: mismatched types.</span></span><br></pre></td></tr></table></figure><p>在 Go 中, 两种不同可比较类型的两个值仅当其中一个隐式的转化为另一个类型的时候才可以比较. 具体而言, 有三种情况不同可比较的两个值才可以比较:</p><ol><li>两个值中的一个的类型是另一个的底层类型.</li><li>两个值之一的类型实现另一个值的类型(必须是接口类型).</li><li>两个值中的一个的类型是定向 channel 类型, 另一个是双向 channel 类型, 两种类型具有相同的元素类型，并且两种类型中的一种不是定义的类型.</li></ol><p>nil 值也不例外.</p><p>下面例子中的代码行都可以编译.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IntPtr *<span class="keyword">int</span></span><br><span class="line"><span class="comment">// IntPtr 的底层类型是 *int.</span></span><br><span class="line"><span class="keyword">var</span> _ = IntPtr(<span class="literal">nil</span>) == (*<span class="keyword">int</span>)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go 中每一个类型都实现了空 interface&#123;&#125; 类型.</span></span><br><span class="line"><span class="keyword">var</span> _ = (<span class="keyword">interface</span>&#123;&#125;)(<span class="literal">nil</span>) == (*<span class="keyword">int</span>)(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定向 channel 类型的值可以转为一个具有相同元素类型的双向 channel 类型.</span></span><br><span class="line"><span class="keyword">var</span> _ = (<span class="keyword">chan</span> <span class="keyword">int</span>)(<span class="literal">nil</span>) == (<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">var</span> _ = (<span class="keyword">chan</span> <span class="keyword">int</span>)(<span class="literal">nil</span>) == (&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h3 id="相同类型的两个-nil-值可能也不可比较"><a href="#相同类型的两个-nil-值可能也不可比较" class="headerlink" title="相同类型的两个 nil 值可能也不可比较"></a>相同类型的两个 nil 值可能也不可比较</h3><p>在 Go 中, map, slice, function 类型不支持比较. 所以比较两个不可比较类型的两个 nil 是非法的.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下代码行无法通过编译.</span></span><br><span class="line"><span class="keyword">var</span> _ = ([]<span class="keyword">int</span>)(<span class="literal">nil</span>) == ([]<span class="keyword">int</span>)(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">var</span> _ = (<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)(<span class="literal">nil</span>) == (<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">var</span> _ = (<span class="function"><span class="keyword">func</span><span class="params">()</span>)<span class="params">(<span class="literal">nil</span>)</span> == <span class="params">(<span class="keyword">func</span>()</span>)<span class="params">(<span class="literal">nil</span>)</span></span></span><br></pre></td></tr></table></figure><p>但是, 上述无法比较的类型的任何值都可以与裸 nil 标识符进行比较. (<em>译注</em>: 这个地方有点难理解, 转化后的 nil 本质上已经具有类型了, 所以相当于两种具有相同类型的 nil 在比较, 在这里不可比较, 编译报错, 而一个零值类型与 nil 的比较是单纯的值比较)</p><h3 id="两个-nil-值可能不相等"><a href="#两个-nil-值可能不相等" class="headerlink" title="两个 nil 值可能不相等"></a>两个 nil 值可能不相等</h3><p>如果两个要比较的 nil 值之一是一个接口值, 另一个不是, 假设它们是可比较的, 那么比较结果总是 false 的. 原因是进行比较之前, 非接口值将被转换为接口值的类型. 转换的接口值具有一个具体的动态类型, 但其他接口值没有. 这就是为什么比较结果总是 false 的原因. (<em>译注</em>: 这个其实说的是比较的时候 (*int)(nil) 会转化为一个 interface {} 类型, 这样这个接口就具有了明确的类型和值 nil, 我们知道 go 的接口实现是类型和值两个部分, (interface{})(nil) 这个的类型和值都是 nil, 所以比较总是 false)</p><p>例如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println((<span class="keyword">interface</span>&#123;&#125;)(<span class="literal">nil</span>) == (*<span class="keyword">int</span>)(<span class="literal">nil</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="从-nil-map-检索元素不会-panic"><a href="#从-nil-map-检索元素不会-panic" class="headerlink" title="从 nil map 检索元素不会 panic"></a>从 nil map 检索元素不会 panic</h3><p>从 nil map 检索元素总是会返回元素类型的零值. (<em>译注</em>: map 是引用类型, nil map 不指向一个初始化的 map, 所以内存读会是零值, 写入一个 nil map 会 panic)</p><p>例如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println((<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)(<span class="literal">nil</span>)[<span class="string">"key"</span>]) <span class="comment">// 0</span></span><br><span class="line">fmt.Println((<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)(<span class="literal">nil</span>)[<span class="number">123</span>])     <span class="comment">// false</span></span><br><span class="line">fmt.Println((<span class="keyword">map</span>[<span class="keyword">int</span>]*<span class="keyword">int64</span>)(<span class="literal">nil</span>)[<span class="number">123</span>])   <span class="comment">// &lt;nil&gt;</span></span><br></pre></td></tr></table></figure><h3 id="遍历-nil-channel-map-slice-和-array-指针是合法的"><a href="#遍历-nil-channel-map-slice-和-array-指针是合法的" class="headerlink" title="遍历 nil channel, map, slice 和 array 指针是合法的"></a>遍历 nil channel, map, slice 和 array 指针是合法的</h3><p>遍历 nil map 和 slice 的循环次数是 0.</p><p>遍历一个 nil array 指针的循环次数是它对应数组类型的长度. (但是, 如果相应数组类型的长度不为 0, 并且迭代的第二个变量既不忽略也不省略, 那么迭代在运行时将会 panic. <em>译注</em>: 这个可以看下面的增加注解代码进行理解)</p><p>遍历一个 nil channel 将永久 block.</p><p>例如, 以下的代码将打印出 0, 1, 2, 3, 和 4, 然后将永远 block. Hello, word 和 Bye 不会打印出来.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> []<span class="keyword">int</span>(<span class="literal">nil</span>) &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>(<span class="literal">nil</span>) &#123;</span><br><span class="line">fmt.Println(<span class="string">"world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,_ := <span class="keyword">range</span> (*[<span class="number">5</span>]<span class="keyword">int</span>)(<span class="literal">nil</span>) &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译加: 以下代码将 panic</span></span><br><span class="line"><span class="comment">// for i, v := range (*[5]int)(nil) &#123;</span></span><br><span class="line"><span class="comment">// fmt.Println(i, v)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> <span class="keyword">chan</span> <span class="keyword">bool</span>(<span class="literal">nil</span>) &#123; <span class="comment">// 这里 block</span></span><br><span class="line">fmt.Println(<span class="string">"Bye"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过非接口-nil-参数调用方法将不会-panic"><a href="#通过非接口-nil-参数调用方法将不会-panic" class="headerlink" title="通过非接口 nil 参数调用方法将不会 panic"></a>通过非接口 nil 参数调用方法将不会 panic</h3><p>例如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice []<span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Slice)</span> <span class="title">Length</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Slice)</span> <span class="title">Modify</span><span class="params">(i <span class="keyword">int</span>, x <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">s[i] = x <span class="comment">// panic if s is nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Slice)</span> <span class="title">DoNothing</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Slice)</span> <span class="title">Append</span><span class="params">(x <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">*p = <span class="built_in">append</span>(*p, x) <span class="comment">// panic if p is nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 如下选择器将不会 panic.</span></span><br><span class="line">_ = ((Slice)(<span class="literal">nil</span>)).Length</span><br><span class="line">_ = ((Slice)(<span class="literal">nil</span>)).Modify</span><br><span class="line">_ = ((*Slice)(<span class="literal">nil</span>)).DoNothing</span><br><span class="line">_ = ((*Slice)(<span class="literal">nil</span>)).Append</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两行将不会 panic.</span></span><br><span class="line">_ = ((Slice)(<span class="literal">nil</span>)).Length()</span><br><span class="line">((*Slice)(<span class="literal">nil</span>)).DoNothing()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下两行将会 panic. 但是 panics 在调用方法时不会触发. 将在方法体内触发.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">((Slice)(nil)).Modify(0, true)</span></span><br><span class="line"><span class="comment">((*Slice)(nil)).Append(true)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如果类型-T-的零值可以表示为-nil-那么-new-T-和-nil-相等"><a href="#如果类型-T-的零值可以表示为-nil-那么-new-T-和-nil-相等" class="headerlink" title="如果类型 T 的零值可以表示为 nil, 那么 *new(T) 和 nil 相等"></a>如果类型 T 的零值可以表示为 nil, 那么 *new(T) 和 nil 相等</h3><p>例如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(*<span class="built_in">new</span>(*<span class="keyword">int</span>) == <span class="literal">nil</span>)         <span class="comment">// true</span></span><br><span class="line">fmt.Println(*<span class="built_in">new</span>([]<span class="keyword">int</span>) == <span class="literal">nil</span>)        <span class="comment">// true</span></span><br><span class="line">fmt.Println(*<span class="built_in">new</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>) == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">fmt.Println(*<span class="built_in">new</span>(<span class="keyword">chan</span> <span class="keyword">string</span>) == <span class="literal">nil</span>)  <span class="comment">// true</span></span><br><span class="line">fmt.Println(*<span class="built_in">new</span>(<span class="function"><span class="keyword">func</span><span class="params">()</span>) == <span class="title">nil</span>)       // <span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="title">fmt</span>.<span class="title">Println</span><span class="params">(*<span class="built_in">new</span>(<span class="keyword">interface</span>&#123;&#125;)</span> == <span class="title">nil</span>)  // <span class="title">true</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
            <tag> go101 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go errors 堆栈</title>
      <link href="/post/go-errors-stack-traces.html"/>
      <url>/post/go-errors-stack-traces.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">相对于 C 语言来说, Go 在处理传统的逻辑错误上确实略高一筹. 至少一个 func 返回 error, 我们知道需要处理并且偶尔会进行传递, 而不是干巴巴等着运行时崩溃.<p></p><h3 id="Errors-也是值"><a href="#Errors-也是值" class="headerlink" title="Errors 也是值"></a>Errors 也是值</h3><p>我们每个人在学习 Go 的时候都被这样说服: <a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">Errors are values</a>, 错误也是一种值, 就像其他任何类型的值一样.</p><p>我们先看一个简单的例子:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://play.golang.org/p/VFVX0fRKBnS</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, err := strconv.ParseInt(<span class="string">"abcd"</span>, <span class="number">10</span>, <span class="number">64</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// strconv.ParseInt: parsing "abcd": invalid syntax</span></span><br></pre></td></tr></table></figure><p>看起来好像还不错, 起码我们知道 3 个内容:</p><ul><li>错误发生的 func: strconv.ParseInt</li><li>发生错误 func 的参数: abcd</li><li>错误的原因: invalid syntax</li></ul><p>如果查看 <a href="https://golang.org/src/strconv/atoi.go?s=4086:4153#L146" target="_blank" rel="noopener">strconv.ParseInt</a> 的源码你会发现, 代码如标准库者依然没有使用最原始的 error 返回. 它之所以打印出上面的 3 个内容, 是因为使用了自定义的 NumError :</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A NumError records a failed conversion.</span></span><br><span class="line"><span class="keyword">type</span> NumError <span class="keyword">struct</span> &#123;</span><br><span class="line">Func <span class="keyword">string</span> <span class="comment">// the failing function (ParseBool, ParseInt, ParseUint, ParseFloat)</span></span><br><span class="line">Num  <span class="keyword">string</span> <span class="comment">// the input</span></span><br><span class="line">Err  error  <span class="comment">// the reason the conversion failed (e.g. ErrRange, ErrSyntax, etc.)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *NumError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"strconv."</span> + e.Func + <span class="string">": "</span> + <span class="string">"parsing "</span> + Quote(e.Num) + <span class="string">": "</span> + e.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们领会了 Errors are values 的精神, 基本上能写出这样的错误处理已经很符合 <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">不要仅仅检查 errors, 优雅的处理它们</a> 的宗旨了. 本文在这里也可能就结束了, 然后将标题改为: Go errors 指南 \ (•◡•) /.</p><h3 id="Errors-堆栈跟踪"><a href="#Errors-堆栈跟踪" class="headerlink" title="Errors 堆栈跟踪"></a>Errors 堆栈跟踪</h3><p>不, 这不够啊, 对于标准库可能每个错误都像那样模版式搞个花式自定义 error . 如果我们用过 Python 或者 Java 的 try, 不会不知道异常(可能有人在这里跟我掰 Go 里面 errors 不是异常)发生的时候, 打印行号等关键信息有多重要吧.</p><p>上面的 ParseInt 例子只是个简单的不能再简单的例子, 如果我们的工程和代码复杂度都上一个层次, 一个 func 里面可能需要处理多个第三方 func 返回的 errors. 一个简单的 errors 信息对于程序的调试并不友好. 当然你如果确保了像标准库那样给出了那样翔实的 errors 内容, 倒也不错. 即便是这样, 我觉得依然没有发生 errors 时给出文件和行号来得实用一些.</p><p>实现这个功能需要用到 Go 强大的 runtime 包, 我们尝试自己实现一个简单的自定义 errors 堆栈跟踪:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://play.golang.org/p/-tesfXuy9fc</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callers</span><span class="params">()</span> []<span class="title">uintptr</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> pcs [<span class="number">32</span>]<span class="keyword">uintptr</span></span><br><span class="line">n := runtime.Callers(<span class="number">3</span>, pcs[:])</span><br><span class="line">st := pcs[<span class="number">0</span>:n]</span><br><span class="line"><span class="keyword">return</span> st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> trace <span class="keyword">struct</span> &#123;</span><br><span class="line">m <span class="keyword">string</span></span><br><span class="line">s []<span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *trace)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b strings.Builder</span><br><span class="line">b.WriteString(e.m)</span><br><span class="line">b.WriteString(<span class="string">"\n\n"</span>)</span><br><span class="line">b.WriteString(<span class="string">"Traceback:"</span>)</span><br><span class="line"><span class="keyword">for</span> _, pc := <span class="keyword">range</span> e.s &#123;</span><br><span class="line">fn := runtime.FuncForPC(pc)</span><br><span class="line">b.WriteString(<span class="string">"\n"</span>)</span><br><span class="line">f, n := fn.FileLine(pc)</span><br><span class="line">b.WriteString(fmt.Sprintf(<span class="string">"%s:%d"</span>, f, n))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTrace creates a simple traceable error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTrace</span><span class="params">(message <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;trace&#123;m: message, s: callers()&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> NewTrace(<span class="string">"ooops"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(f())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// goplay 输出</span></span><br><span class="line"><span class="comment">// ooops</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Traceback:</span></span><br><span class="line"><span class="comment">// /tmp/sandbox315155193/main.go:41</span></span><br><span class="line"><span class="comment">// /tmp/sandbox315155193/main.go:45</span></span><br><span class="line"><span class="comment">// /usr/local/go/src/runtime/proc.go:207</span></span><br><span class="line"><span class="comment">// /usr/local/go/src/runtime/asm_amd64p32.s:968</span></span><br></pre></td></tr></table></figure><p>虽然简单粗糙了一些, 但确实实现了我们要的简单 errors 堆栈跟踪.</p><h3 id="社区实现-pkg-errors"><a href="#社区实现-pkg-errors" class="headerlink" title="社区实现(pkg/errors)"></a>社区实现(pkg/errors)</h3><p>我们当然不打算在平常的代码中使用这样一个简单的实现, 我们这里介绍一下社区已经存在的 <a href="https://github.com/pkg/errors" target="_blank" rel="noopener">pkg/errors</a> 库.</p><p>对于标准库或者第三方库的 errors 返回我们需要一个简单的 wrap, 以便在同样使用 pkg/errors 的地方可以获取一致的 errors 体验:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, err := ioutil.ReadAll(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.Wrap(err, <span class="string">"read failed"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看怎样使用 pkg/errors 得到的 errors:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/pkg/errors"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseArgs</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Errorf(<span class="string">"not enough arguments, expected at least 3, got %d"</span>, <span class="built_in">len</span>(args))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := parseArgs(os.Args[<span class="number">1</span>:])</span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// not enough arguments, expected at least 3, got 0</span></span><br></pre></td></tr></table></figure><p>什么 ? 没有堆栈信息打印 ? pkg/errors 默认的 flag 是不打印堆栈信息的(虽然一直包含). 我们施展一下 Go Formatter 的魔法:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := parseArgs(os.Args[<span class="number">1</span>:])</span><br><span class="line">fmt.Printf(<span class="string">"%+v\n"</span>, err) <span class="comment">// 没错, 加个 `+` flag</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// not enough arguments, expected at least 3, got 0</span></span><br><span class="line"><span class="comment">// main.parseArgs</span></span><br><span class="line"><span class="comment">// /Users/xxx/.go/src/github.com/gorocks/snippets/go/cmd/gosnippets/main.go:12</span></span><br><span class="line"><span class="comment">// main.main</span></span><br><span class="line"><span class="comment">// /Users/xxx/.go/src/github.com/gorocks/snippets/go/cmd/gosnippets/main.go:18</span></span><br><span class="line"><span class="comment">// runtime.main</span></span><br><span class="line"><span class="comment">// /usr/local/Cellar/go/1.10.1/libexec/src/runtime/proc.go:198</span></span><br><span class="line"><span class="comment">// runtime.goexit</span></span><br><span class="line"><span class="comment">// /usr/local/Cellar/go/1.10.1/libexec/src/runtime/asm_amd64.s:2361</span></span><br></pre></td></tr></table></figure><p>之所以会有这个效果是因为 pkg/errors 实现了 <a href="https://golang.org/pkg/fmt/#Formatter" target="_blank" rel="noopener">Formatter</a> 接口:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fundamental)</span> <span class="title">Format</span><span class="params">(s fmt.State, verb <span class="keyword">rune</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> verb &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line"><span class="keyword">if</span> s.Flag(<span class="string">'+'</span>) &#123;</span><br><span class="line">io.WriteString(s, f.msg)</span><br><span class="line">f.stack.Format(s, verb)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">io.WriteString(s, f.msg)</span><br><span class="line"><span class="keyword">case</span> <span class="string">'q'</span>:</span><br><span class="line">fmt.Fprintf(s, <span class="string">"%q"</span>, f.msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 Formatter 的一个好处是, 我们可以如使用标准库般始终如一, 没有多余的任何 func 调用.</p><h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><p>pkg/errors 堆栈跟踪不是没有运行时开销的, <a href="https://github.com/pkg/errors/issues/72" target="_blank" rel="noopener">官方</a>给出的指标是每个操作大约 1000-3000 ns.</p><p>一般来说这不会构成性能忧虑. 如果超过了你的性能预期, 可以定制成调试模式启用.</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">Errors are values</a></li><li><a href="https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package" target="_blank" rel="noopener">Stack traces and the errors package</a></li><li><a href="https://github.com/pkg/errors" target="_blank" rel="noopener">pkg/errors</a></li></ul></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SICP 准备</title>
      <link href="/post/sicp-quickstart.html"/>
      <url>/post/sicp-quickstart.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">买了很久的 SICP (英文: <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html" target="_blank" rel="noopener">Structure and Interpretation of Computer Programs</a>, 中文译作: 计算机程序的构造和解释)一直在吃灰, 趁着假期捡起来.<p></p><h3 id="一种-Scheme-实现"><a href="#一种-Scheme-实现" class="headerlink" title="一种 Scheme 实现"></a>一种 Scheme 实现</h3><p>刷 SICP 不局限于特定的 Scheme 实现, 虽然 MIT-Scheme 是 MIT 出的. 然而 MIT 自己都废掉了它而指定 DrScheme 为默认课程支持版本. 本文基于的 Scheme 实现是 <a href="http://www.call-cc.org/" target="_blank" rel="noopener">Chicken</a>.</p><p>macOS 下安装很简单:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install chicken</span><br></pre></td></tr></table></figure><h3 id="一个编辑器"><a href="#一个编辑器" class="headerlink" title="一个编辑器"></a>一个编辑器</h3><p>对于Scheme来说, 恐怕支持最好的就是 Emacs 了. 同样本文基于 Emacs 的定制配置版本 <a href="https://github.com/syl20bnr/spacemacs" target="_blank" rel="noopener">Spacemacs</a>.</p><p>Spacemacs 本身就有一个 Scheme 的 Layer 可供使用, 我使用了一个基于它, 自己定制的 Layer(<a href="https://github.com/douglarek/.spacemacs.d/tree/master/layers/x-scheme" target="_blank" rel="noopener">x-scheme</a>).</p><p>x-scheme 依赖于 <a href="https://github.com/jaor/geiser" target="_blank" rel="noopener">Geiser</a> 提供 REPL 等各种便利的功能, 它使用了 Chicken 的某些扩展, 可以通过以下命令安装:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chicken-install chicken-doc apropos sicp <span class="comment"># 包含 sicp 支持</span></span><br><span class="line">$ <span class="built_in">cd</span> `csi -p <span class="string">'(chicken-home)'</span>`</span><br><span class="line">$ curl http://3e8.org/pub/chicken-doc/chicken-doc-repo.tgz | tar zx</span><br></pre></td></tr></table></figure><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>Chicken 通过 sicp 扩展对 SICP 提供某些便利的支持, 比如一些 SICP 默认已经有了的过程(average 等). 例如 SICP 练习第一章1.7:</p><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name">use</span> sicp) <span class="comment">;; sicp 扩展</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">sqrt</span></span> x)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">improve</span> guess x)</span><br><span class="line">    (<span class="name">average</span> guess (<span class="name"><span class="builtin-name">/</span></span> x guess)))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">good-enough?</span> guess last-guess)</span><br><span class="line">    (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> guess last-guess)) guess) <span class="number">0.001</span>))</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sqrt-iter</span> guess last-guess x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">good-enough?</span> guess last-guess)</span><br><span class="line">        last-guess</span><br><span class="line">        (<span class="name">sqrt-iter</span> last-guess (<span class="name">improve</span> last-guess x)</span><br><span class="line">                   x)))</span><br><span class="line">  (<span class="name">sqrt-iter</span> <span class="number">1.0</span> x x))</span><br></pre></td></tr></table></figure><h3 id="SICP-实用性"><a href="#SICP-实用性" class="headerlink" title="SICP 实用性"></a>SICP 实用性</h3><p>我们做一件事情的时候有时很喜欢考虑这个东西实用不实用, 做了有什么收益. 这没什么问题, 特别是别人问你刷 SICP 有什么用的时候, 很难回答. 因为你工作或生活中确实没有用它的场景, 甚至是产品. SICP 中文版序前有段话挺好的, 在这里分享一下:</p><blockquote><p>我认为, 在计算机科学中保持计算中的趣味性是特别重要的事情. 这一学科在起步时饱含着趣味性. 当然, 那些付钱的客户们时常觉得受了骗. 一段时间之后, 我们开始严肃地看待他们的抱怨. 我们开始感觉到, 自己真的像是要负起成功地、无差错地、完美地使用这些机器的责任. 我不认为我们可以做到这些. 我认为我们的责任是去拓展这一领域, 将其发展到新的方向, 并在自己的家里保持趣味性. 我希望计算机科学的领域绝不要丧失其趣味意识. 最重要的是, 我希望我们不要变成传道士, 不要认为你是兜售圣经的人, 世界上这种人已经太多了. 你所知道的有关计算的东西, 其他人也都能学到. 绝不要认为似乎成功计算的钥匙就掌握在你的手里. 你所掌握的, 也是我认为并希望的, 也就是智慧: 那种看到这一机器比你第一次站在它面前时能做得更多的能力, 这样你才能将它向前推进. Alan J. Perlis</p></blockquote></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> sicp </tag>
            
            <tag> scheme </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go 中的内存泄漏</title>
      <link href="/post/memory-leaking.html"/>
      <url>/post/memory-leaking.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自(<a href="https://go101.org/article/memory-leaking.html" target="_blank" rel="noopener">Memory Leaking</a>)版权@归原文所有.<p></p><p>当使用带有垃圾回收器(GC)的语言编程时, 通常我们不需要关心内存泄漏问题, 因为语言运行时(runtime)会定期收集未使用的内存. 但是, 我们确实需要了解一些可能导致轻微的或者真正的内存泄漏的特殊场景. 本文剩下的部分将列出几个这样的情况.</p><h3 id="求子字符串-Substrings-导致的轻微内存泄露"><a href="#求子字符串-Substrings-导致的轻微内存泄露" class="headerlink" title="求子字符串(Substrings)导致的轻微内存泄露"></a>求子字符串(Substrings)导致的轻微内存泄露</h3><p>Go 规范没有指定在子字符串表达式中涉及的结果字符串和基本字符串是否应共享相同的底层内存块，该内存块托管两个字符串的底层字节序列. Go 标准编译器/运行时确实会让它们共享相同的底层内存块. 这是一个很好的设计, 这既是内存也是 CPU 消耗的明智之举. 但它可能会导致内存泄漏.</p><p>例如, 调用下面的函数 f 后, 将有 1M 字节的内存泄漏(轻微), 直到其他地方修改了包级(package-level)变量 s0.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s0 <span class="keyword">string</span> <span class="comment">// package level variable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(s1 <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 假设 s1 是一个长度大于 50 的字符串.</span></span><br><span class="line">    s0 = s1[:<span class="number">50</span>]</span><br><span class="line">    <span class="comment">// 现在, s0 和 s1 共享相同的底层内存块.</span></span><br><span class="line">    <span class="comment">// s1 现在不存活了, 但是 s0 依然存活.</span></span><br><span class="line">    <span class="comment">// 尽管仅有 50 个字节在内存块中,</span></span><br><span class="line">    <span class="comment">// s0 仍旧存活的事实阻止了这 1M 字节的内存块被回收.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免这种轻微的内存泄漏, 我们可以将子字符串转换为一个 []byte 值, 然后将 []byte 值转换回 string.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(s1 <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">s0 = <span class="keyword">string</span>([]<span class="keyword">byte</span>(s1[:<span class="number">50</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述避免这种轻微内存泄漏方法的缺点是在转换过程中发生了 50 字节的复制, 其中一个是不必要的.</p><p>我们可以使用 Go 标准编译器进行的<a href="https://go101.org/article/string.html#conversion-optimizations" target="_blank" rel="noopener">一种优化</a>来避免一次复制, 并且伴随着浪费一个字节的小的额外成本.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(s1 <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">s0 = (<span class="string">" "</span> + s1[:<span class="number">50</span>])[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法的缺点是编译器优化可能会在以后失效，并且优化可能不适用于其他编译器.</p><p>避免类型内存泄漏的第三种方法是使用直到 Go 1.10 才开始支持的 strings.Builder .</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(s1 <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b strings.Builder</span><br><span class="line">b.Grow(<span class="number">50</span>)</span><br><span class="line">b.WriteString(s1[:<span class="number">50</span>])</span><br><span class="line">s0 = b.String()</span><br><span class="line"><span class="comment">// b.Reset() // 如果 b 在其他地方会用到, 那么它必须在这里重置掉.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种方式的缺点是有点冗长(通过比较前两种方式).</p><h3 id="求子切片-Subslices-导致的轻微内存泄露"><a href="#求子切片-Subslices-导致的轻微内存泄露" class="headerlink" title="求子切片(Subslices)导致的轻微内存泄露"></a>求子切片(Subslices)导致的轻微内存泄露</h3><p>与求子串类似, 求子切片也可能导致轻微的内存泄漏. 在下面的代码中, 调用 g 函数后, 承载 s1 元素的内存块占用的大部分内存将会丢失(如果没有更多值引用内存块).</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s0 []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">(s1 []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 假设 s1 的长度远远大于 30.</span></span><br><span class="line">s0 = s1[<span class="built_in">len</span>(s1)<span class="number">-30</span>:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想避免这种轻微的内存泄漏, 我们必须复制 s0 的 30 个元素, 以便 s0 的存活不会阻止 s1 元素的内存块被回收.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">(s1 []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s0 = <span class="built_in">append</span>([]<span class="keyword">int</span>(<span class="literal">nil</span>), s1[<span class="built_in">len</span>(s1)<span class="number">-30</span>:]...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不存活切片元素未重置指针导致的轻微内存泄露"><a href="#不存活切片元素未重置指针导致的轻微内存泄露" class="headerlink" title="不存活切片元素未重置指针导致的轻微内存泄露"></a>不存活切片元素未重置指针导致的轻微内存泄露</h3><p>在下面的代码中, 调用 g 函数之后, 分配给切片 s 的第一个元素的内存块会丢失. 如果最后一个元素以后从未用作任何切片的元素, 则为最后一个元素分配的内存块也会丢失.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span> []*<span class="title">int</span></span> &#123;</span><br><span class="line">s := []*<span class="keyword">int</span>&#123;<span class="built_in">new</span>(<span class="keyword">int</span>), <span class="built_in">new</span>(<span class="keyword">int</span>), <span class="built_in">new</span>(<span class="keyword">int</span>), <span class="built_in">new</span>(<span class="keyword">int</span>)&#125;</span><br><span class="line"><span class="keyword">return</span> s[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果返回的切片仍然存活, 那么它将阻止收集 s 的元素的底层内存块, 从而防止从 s 的第一个元素到最后一个元素分配的两个内存块被收集, 尽管两个元素已经不存活了.</p><p>如果我们想避免这种轻微内存泄漏, 我们必须重置不存活元素中的指针(这里, 在函数 h 被调用后, 第一个和最后一个元素被视为不存活元素).</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">h</span><span class="params">()</span> []*<span class="title">int</span></span> &#123;</span><br><span class="line">s := []*<span class="keyword">int</span>&#123;<span class="built_in">new</span>(<span class="keyword">int</span>), <span class="built_in">new</span>(<span class="keyword">int</span>), <span class="built_in">new</span>(<span class="keyword">int</span>), <span class="built_in">new</span>(<span class="keyword">int</span>)&#125;</span><br><span class="line">s1 := s[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">s[<span class="number">0</span>] = <span class="literal">nil</span>; s[<span class="built_in">len</span>(s)<span class="number">-1</span>] = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> s1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们经常需要重置<a href="https://go101.org/article/container.html#slice-manipulations" target="_blank" rel="noopener">切片元素删除操作</a>中不存活元素的指针.</p><h3 id="迷失的-Goroutines-导致的内存泄露"><a href="#迷失的-Goroutines-导致的内存泄露" class="headerlink" title="迷失的 Goroutines 导致的内存泄露"></a>迷失的 Goroutines 导致的内存泄露</h3><p>有时, 对于代码设计中的一些逻辑失误, 一个或多个 goroutine 会永远处于阻塞状态, 这将导致这些 goroutine 中使用的许多代码块永远无法进行垃圾收集. 这是真正的内存泄漏.</p><p>例如, 如果将以下函数作为 goroutine 的启动函数并将一个 nil channel 参数传递给它, 则 goroutine 将永远阻塞. Go 运行时认为 goroutine 仍然存活, 所以为 s 分配的内存块将永远不会被收集.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">k</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int64</span>, <span class="number">1e6</span>)</span><br><span class="line"><span class="keyword">if</span> &lt;-c &#123; <span class="comment">// 如果 c 为 nil, 这里将永远阻塞</span></span><br><span class="line">_ = s</span><br><span class="line"><span class="comment">// 使用 s, ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们应该避免这种逻辑失误.</p><h3 id="终结器-Finalizers"><a href="#终结器-Finalizers" class="headerlink" title="终结器(Finalizers)"></a>终结器(Finalizers)</h3><p>为循环引用组内的成员设置 finalizer <a href="https://golang.org/pkg/runtime/#SetFinalizer" target="_blank" rel="noopener">可能会阻止为这个循环引用组分配的所有内存块被收集</a>. 这不是轻微而是真正的内存泄露.</p><p>在下列函数被调用并退出之后, 为 x 和 y 分配的内存块不保证在未来会被垃圾收集器回收.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">memoryLeaking</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">v [<span class="number">1</span>&lt;&lt;<span class="number">20</span>]<span class="keyword">int</span></span><br><span class="line">t *T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> finalizer = <span class="function"><span class="keyword">func</span><span class="params">(t *T)</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">"finalizer called"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y T</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetFinalizer 会使 x 逃逸到堆上.</span></span><br><span class="line">runtime.SetFinalizer(&amp;x, finalizer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下语句将导致 x 和 y 变得无法收集.</span></span><br><span class="line">x.t, y.t = &amp;y, &amp;x <span class="comment">// y 也逃逸到了 堆上.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以, 请避免为循环引用组中的值设置终结器(finalizers).</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
            <tag> go101 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go 中的同步队列</title>
      <link href="/post/synchronization-queues-in-golang.html"/>
      <url>/post/synchronization-queues-in-golang.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自 <a href="https://medium.com/golangspec/synchronization-queues-in-golang-554f8e3a31a4" target="_blank" rel="noopener">Synchronization queues in Golang</a> 版权@归原文所有.<br><a id="more"></a><p></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>假设我们正在运作一家雇佣程序员和测试人员的 IT 公司. 为了让人们有机会认识对方并放松一下, 我们买了一张乒乓桌, 并制定了以下规则:</p><ul><li>正好两个人可以同时玩,</li><li>下一对只能在前一个完成时才能开始他们的比赛, 所以不允许切换一个球员,</li><li>测试人员只能与程序员一起工作, 反之亦然(不能两个测试人员或两个程序员一起). 如果程序员或测试人员想玩游戏, 那么需要分别等待测试人员或程序员建立有效的配对.</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> programmer()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> tester()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">select</span> &#123;&#125; <span class="comment">// long day at work...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">programmer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        code()</span><br><span class="line">        pingPong()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tester</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        test()</span><br><span class="line">        pingPong()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将通过 time.Sleep 模拟测试, 编码, 以及打乒乓球.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    work()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">code</span><span class="params">()</span></span> &#123;</span><br><span class="line">    work()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Sleep up to 10 seconds.</span></span><br><span class="line">    time.Sleep(time.Duration(rand.Intn(<span class="number">10000</span>)) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pingPong</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Sleep up to 2 seconds.</span></span><br><span class="line">    time.Sleep(time.Duration(rand.Intn(<span class="number">2000</span>)) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">programmer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        code()</span><br><span class="line">        fmt.Println(<span class="string">"Programmer starts"</span>)</span><br><span class="line">        pingPong()</span><br><span class="line">        fmt.Println(<span class="string">"Programmer ends"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tester</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        test()</span><br><span class="line">        fmt.Println(<span class="string">"Tester starts"</span>)</span><br><span class="line">        pingPong()</span><br><span class="line">        fmt.Println(<span class="string">"Tester ends"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的程序发出如下消息流:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; go run pingpong.go</span><br><span class="line">Tester starts</span><br><span class="line">Programmer starts</span><br><span class="line">Programmer starts</span><br><span class="line">Tester ends</span><br><span class="line">Programmer ends</span><br><span class="line">Programmer starts</span><br><span class="line">Programmer ends</span><br><span class="line">Programmer ends</span><br></pre></td></tr></table></figure><p>但是按照规则打乒乓球, 我们的信息流可以只包含这样的 4 行长的序列(以任何顺序和重复的任意次数):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tester starts</span><br><span class="line">Programmer starts</span><br><span class="line">Tester ends</span><br><span class="line">Programmer ends</span><br><span class="line">Tester starts</span><br><span class="line">Programmer starts</span><br><span class="line">Programmer ends</span><br><span class="line">Tester ends</span><br><span class="line">Programmer starts</span><br><span class="line">Tester starts</span><br><span class="line">Tester ends</span><br><span class="line">Programmer ends</span><br><span class="line">Programmer starts</span><br><span class="line">Tester starts</span><br><span class="line">Programmer ends</span><br><span class="line">Tester ends</span><br></pre></td></tr></table></figure><p>所以, 无论是测试人员还是程序员都要接近桌子. 之后合作伙伴加入(相应的程序员或测试人员). 在离开游戏时, 他们可以以任何顺序进行. 这就是我们有 4 个有效序列的原因.</p><p>以下是两种解决方案. 一个是基于互斥量的, 第二个是使用独立的 worker 协调整个过程, 确保所有事情都按照政策进行.</p><h3 id="方案-1"><a href="#方案-1" class="headerlink" title="方案 #1"></a>方案 #1</h3><p>两种方案都使用在接近桌子之前排队的数据结构. 当至少有一个有效对(Dev + QA)时, 允许该对玩乒乓球.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tester</span><span class="params">(q *queue.Queue)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        test()</span><br><span class="line">        q.StartT()</span><br><span class="line">        fmt.Println(<span class="string">"Tester starts"</span>)</span><br><span class="line">        pingPong()</span><br><span class="line">        fmt.Println(<span class="string">"Tester ends"</span>)</span><br><span class="line">        q.EndT()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">programmer</span><span class="params">(q *queue.Queue)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        code()</span><br><span class="line">        q.StartP()</span><br><span class="line">        fmt.Println(<span class="string">"Programmer starts"</span>)</span><br><span class="line">        pingPong()</span><br><span class="line">        fmt.Println(<span class="string">"Programmer ends"</span>)</span><br><span class="line">        q.EndP()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    q := queue.New()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> programmer(q)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> tester(q)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>queue 包定义如下:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> queue</span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">    mut                   sync.Mutex</span><br><span class="line">    numP, numT            <span class="keyword">int</span></span><br><span class="line">    queueP, queueT, doneP <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Queue</span></span> &#123;</span><br><span class="line">    q := Queue&#123;</span><br><span class="line">        queueP: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">        queueT: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">        doneP:  <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;q</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">StartT</span><span class="params">()</span></span> &#123;</span><br><span class="line">    q.mut.Lock()</span><br><span class="line">    <span class="keyword">if</span> q.numP &gt; <span class="number">0</span> &#123;</span><br><span class="line">        q.numP -= <span class="number">1</span></span><br><span class="line">        q.queueP &lt;- <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q.numT += <span class="number">1</span></span><br><span class="line">        q.mut.Unlock()</span><br><span class="line">        &lt;-q.queueT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">EndT</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &lt;-q.doneP</span><br><span class="line">    q.mut.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">StartP</span><span class="params">()</span></span> &#123;</span><br><span class="line">    q.mut.Lock()</span><br><span class="line">    <span class="keyword">if</span> q.numT &gt; <span class="number">0</span> &#123;</span><br><span class="line">        q.numT -= <span class="number">1</span></span><br><span class="line">        q.queueT &lt;- <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q.numP += <span class="number">1</span></span><br><span class="line">        q.mut.Unlock()</span><br><span class="line">        &lt;-q.queueP</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">EndP</span><span class="params">()</span></span> &#123;</span><br><span class="line">    q.doneP &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Queue 包含互斥量 mut 有两个目的:</p><ul><li>同步对共享计数器(numT 和 numP)的访问</li><li>扮演游戏中的雇员阻止其他人加入乒乓桌的令牌</li></ul><p>程序员和测试人员正在使用无缓冲 channels 来等待他们的乒乓伙伴.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;-q.queueP</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;-q.queueT</span><br></pre></td></tr></table></figure><p>如果没有伙伴可用, 从这些 channels 读取将会阻塞 goroutine. </p><p>我们来分析一下由测试人员执行的 StartT :</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">StartT</span><span class="params">()</span></span> &#123;</span><br><span class="line">    q.mut.Lock()</span><br><span class="line">    <span class="keyword">if</span> q.numP &gt; <span class="number">0</span> &#123;</span><br><span class="line">        q.numP -= <span class="number">1</span></span><br><span class="line">        q.queueP &lt;- <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q.numT += <span class="number">1</span></span><br><span class="line">        q.mut.Unlock()</span><br><span class="line">        &lt;-q.queueT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 numP 大于 0 (至少有一个程序员在等待游戏), 那么等待的程序员的数量减少一个, 等待的程序员中的一个将被允许加入该乒乓桌(q.queueP &lt;-1). 有趣的是, 在这个过程中, 互斥量不会被释放, 所以它将作为一个令牌独占访问乒乓球桌.</p><p>如果没有等待的程序员, 则 numT (等待测试者的数量)增加并且 goroutine 在 &lt;-q.queueT 上阻塞.</p><p>StartP 基本上是相同的, 但由程序员执行.</p><p>在游戏过程中, 互斥量将被锁定, 因此需要由程序员或测试人员释放. 只有当双方完成游戏时才释放互斥量, 则会使用屏障 doneP:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">EndT</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &lt;-q.doneP</span><br><span class="line">    q.mut.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">EndP</span><span class="params">()</span></span> &#123;</span><br><span class="line">    q.doneP &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果程序员仍在玩并且测试人员已完成, 那么测试人员将阻塞在 &lt;-q.doneP. 一旦程序员到达 q.doneP &lt;- 1, 屏障将打开, 互斥量将被释放, 以允许这些员工重新开始工作.</p><p>如果测试者仍在游戏, 那么程序员将在 q.doneP &lt;- 1 上阻塞. 当测试者完成时, 它从屏障 &lt;-q.doneP 中读取, 这将解除对程序员的阻塞, 并且将释放互斥量以释放该乒乓桌.</p><p>这里有趣的是, 不管测试人员还是程序员都可能锁定互斥量, 测试人员总是会释放互斥量. 这也是该解决方案初看起来可能不那么明显的原因之一.</p><h3 id="方案-2"><a href="#方案-2" class="headerlink" title="方案 #2"></a>方案 #2</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> queue</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    msgPStart = <span class="literal">iota</span></span><br><span class="line">    msgTStart</span><br><span class="line">    msgPEnd</span><br><span class="line">    msgTEnd</span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">    waitP, waitT   <span class="keyword">int</span></span><br><span class="line">    playP, playT   <span class="keyword">bool</span></span><br><span class="line">    queueP, queueT <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">    msg            <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Queue</span></span> &#123;</span><br><span class="line">    q := Queue&#123;</span><br><span class="line">        msg:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">        queueP: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">        queueT: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> n := &lt;-q.msg:</span><br><span class="line">                <span class="keyword">switch</span> n &#123;</span><br><span class="line">                <span class="keyword">case</span> msgPStart:</span><br><span class="line">                    q.waitP++</span><br><span class="line">                <span class="keyword">case</span> msgPEnd:</span><br><span class="line">                    q.playP = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">case</span> msgTStart:</span><br><span class="line">                    q.waitT++</span><br><span class="line">                <span class="keyword">case</span> msgTEnd:</span><br><span class="line">                    q.playT = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> q.waitP &gt; <span class="number">0</span> &amp;&amp; q.waitT &gt; <span class="number">0</span> &amp;&amp; !q.playP &amp;&amp; !q.playT &#123;</span><br><span class="line">                    q.playP = <span class="literal">true</span></span><br><span class="line">                    q.playT = <span class="literal">true</span></span><br><span class="line">                    q.waitT--</span><br><span class="line">                    q.waitP--</span><br><span class="line">                    q.queueP &lt;- <span class="number">1</span></span><br><span class="line">                    q.queueT &lt;- <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> &amp;q</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">StartT</span><span class="params">()</span></span> &#123;</span><br><span class="line">    q.msg &lt;- msgTStart</span><br><span class="line">    &lt;-q.queueT</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">EndT</span><span class="params">()</span></span> &#123;</span><br><span class="line">    q.msg &lt;- msgTEnd</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">StartP</span><span class="params">()</span></span> &#123;</span><br><span class="line">    q.msg &lt;- msgPStart</span><br><span class="line">    &lt;-q.queueP</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">EndP</span><span class="params">()</span></span> &#123;</span><br><span class="line">    q.msg &lt;- msgPEnd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有一个中央协调员在独立的 goroutine 内部运行, 它协调整个过程. 调度器获取想要放松的新员工的信息, 或者是否有人通过 msg channel 打乒乓球. 接收调度器的任何消息状态时都会更新:</p><ul><li>等待的 Devs 或 QAs 的数量会增加</li><li>关于游戏员工的信息会更新</li></ul><p>在接收到任何已定义的消息之后, 调度器将检查是否允许另一对开始游戏:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> q.waitP &gt; <span class="number">0</span> &amp;&amp; q.waitT &gt; <span class="number">0</span> &amp;&amp; !q.playP &amp;&amp; !q.playT &#123;</span><br></pre></td></tr></table></figure><p>如果是这样, 则相应地更新状态, 并且一个测试人员和一个程序员被解锁.</p><p>我们现在不再使用互斥量(如解决方案 1 中的方法)来管理对共享数据的访问, 而是通过单独的 goroutine 与外部世界进行通信. 这将使我们编写更多的惯用的 Go 程序.</p><blockquote><p>不要通过共享内存进行通信, 通过通信共享内存.</p></blockquote><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><ul><li>Allen B. Downey “The Little Book of Semaphores”</li><li><a href="https://medium.com/golangspec/reusable-barriers-in-golang-156db1f75d0b" target="_blank" rel="noopener">Reusable barriers in Golang</a></li><li><a href="https://blog.golang.org/share-memory-by-communicating" target="_blank" rel="noopener">Share Memory By Communicating</a></li></ul></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>理解 Go defer, panic, recover</title>
      <link href="/post/go-defer-panic-and-recover.html"/>
      <url>/post/go-defer-panic-and-recover.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">不像 Go 的其他流程控制(if, for, switch, goto, go) 一样, defer, panic 和 recover 用的比较少.<br><a id="more"></a><p></p><h3 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h3><p>defer 语句会将函数调用放入一个列表. 当外围的函数执行返回后列表内保存的函数调用会被执行. defer 像 Python 的 with, finally 一样都具有类似资源情理的作用. 当然 defer 在这方面更灵活.</p><p>defer 的行为遵循 3 个简单的原则:</p><ul><li><p>一个 defer 函数的参数在放入待调用列表的时候被立即求值. 比如:</p>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(i) <span class="comment">// @1</span></span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个例子中, @1 中的 i 会被立即求值, 所以 a 函数调用返回时, 会打印出 “0” 而不是 “1”.</p></li><li><p>defer 函数在外围函数返回时遵循 <strong>先进后出</strong> 的调用顺序.</p>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Print(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  b 函数将会打印出 “3210”.</p></li><li><p>defer 函数会读取并且赋值外围函数的命名返回值(named return values).</p>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; i++ &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个例子中 i 的值会 在 defer 被调用时执行加 1 操作, 所以 c 将返回 2. 这对于修改一个函数的 error 返回值很方便.</p></li></ul><h3 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h3><p>panic 是一个内置的函数用来阻断一般的控制流程. Go spec 对于 panic 有一段<a href="https://golang.org/ref/spec#Handling_panics" target="_blank" rel="noopener">描述</a>:</p><blockquote><p>当执行函数 F 时, 一个明确的 panic 调用或者<a href="https://golang.org/ref/spec#Run_time_panics" target="_blank" rel="noopener">运行时 panic</a>(数组越界访问等)会终止 F 的执行. F 所属的任何 defer 函数继续执行. 紧接着, 任何 F 调用者的 defer 函数运行, 而且对于执行中的 goroutine 中的任何顶层 defer 函数也是如此. 到那时, 程序终止并且报错(错误包含在 panic 参数中). 该终止序列被称为 <strong>panicking</strong>.</p></blockquote><h3 id="Recover"><a href="#Recover" class="headerlink" title="Recover"></a>Recover</h3><p>recover 是一个内建函数用来恢复一个 panicking 的 goroutine. Go spec 对于 recover 有一段<a href="https://golang.org/ref/spec#Handling_panics" target="_blank" rel="noopener">描述</a>:</p><blockquote><p>设想有一个函数 G, 有一个 defer 函数会调用 recover 并且和 G 在同一 goroutine 的函数发生了 panic. 当运行到 defer 函数 D 调用的时候, D 调用 recover 的返回值是 panic 调用时传入的值. 如果 D 正常返回, 没有开启一个新的 panic, panicking 序列会终止. 在这种情况下, G 和 panic 之间的函数调用状态被废弃, 并且正常的调用恢复. 然后 G 中任何在 D 之前的 defer 函数会执行, 并且 G 的执行通过返回到它的调用者而终止.</p></blockquote><p>以下情况中 recover 的返回值为 nil:</p><ul><li>panic 参数为 nil;</li><li>当前 goroutine 没有发生 panicking;</li><li>recover 没有被一个 defer 函数直接调用.</li></ul><p>以下示例程序演示了 panic 和 defer 的原理:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f()</span><br><span class="line">    fmt.Println(<span class="string">"Returned normally from f."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Recovered in f"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">"Calling g."</span>)</span><br><span class="line">    g(<span class="number">0</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Returned normally from g."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Panicking!"</span>)</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"%v"</span>, i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"Defer in g"</span>, i)</span><br><span class="line">    fmt.Println(<span class="string">"Printing in g"</span>, i)</span><br><span class="line">    g(i + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数返回:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Calling g.</span><br><span class="line">Printing in g 0</span><br><span class="line">Printing in g 1</span><br><span class="line">Printing in g 2</span><br><span class="line">Printing in g 3</span><br><span class="line">Panicking!</span><br><span class="line">Defer in g 3</span><br><span class="line">Defer in g 2</span><br><span class="line">Defer in g 1</span><br><span class="line">Defer in g 0</span><br><span class="line">Recovered in f 4</span><br><span class="line">Returned normally from f.</span><br></pre></td></tr></table></figure><p>如果我们移除 f 中 defer 将输出:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Calling g.</span><br><span class="line">Printing in g 0</span><br><span class="line">Printing in g 1</span><br><span class="line">Printing in g 2</span><br><span class="line">Printing in g 3</span><br><span class="line">Panicking!</span><br><span class="line">Defer in g 3</span><br><span class="line">Defer in g 2</span><br><span class="line">Defer in g 1</span><br><span class="line">Defer in g 0</span><br><span class="line">panic: 4</span><br><span class="line"></span><br><span class="line">panic PC=0x2a9cd8</span><br><span class="line">[stack trace omitted]</span><br></pre></td></tr></table></figure><p><em>Go 标准库中的约定是</em>, 即使一个包在内部使用 panic, 其外部 API 仍会给出明确的错误返回值(真实的例子可以参见标准库 <a href="http://golang.org/src/pkg/encoding/json/decode.go" target="_blank" rel="noopener">json 包</a>). 这是很好的使用原则, 尤其当我们写自己库的时候, 难免需要处理来自第三方的包返回的各种 error, 如果不需要处理, 简单的一个 panic 会是很好的方案.</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>到这里可能就是你所能看到的关于 defer, panic 和 recover 的所有”坑”(我一向不觉得文档中有的你没看到的东西叫坑). 下面的内容可以不看了, 但是你看了, 保证没坏处.</p><p>当然可能有人说 recover 不能恢复所有的 panic, 比如如下的程序:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"recovered"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">v := i</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">m[v] = v</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果运行该程序, 那么会得到如下的输出:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal error: concurrent map writes</span><br><span class="line">fatal error: concurrent map writes</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><em>其实这个不叫 panic</em>, 按官方文档的说法叫: 崩溃(crash) 和 内存腐败(memory corruption). 由于程序无视 <a href="https://golang.org/ref/mem/" target="_blank" rel="noopener">Go 内存模型</a> 而导致的数据竞争(data race).</p><p>当然对于以上程序来说, 运行程序崩溃是显而易见的, 然而有的程序运行时不会显式的的崩溃, 如:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">m[<span class="string">"1"</span>] = <span class="string">"a"</span></span><br><span class="line">c &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line">m[<span class="string">"2"</span>] = <span class="string">"b"</span></span><br><span class="line">&lt;-c</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 b</span><br><span class="line">1 a</span><br></pre></td></tr></table></figure><p>为了检测和预防这种崩溃, Go 内建了数据竞争探测器(data race detector), 可以通过传递 flag: -race 给 go 命令来启用:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -race mypkg</span><br><span class="line">$ go run -race mysrc.go</span><br><span class="line">$ go build -race mycmd</span><br><span class="line">$ go install -race mypkg</span><br></pre></td></tr></table></figure><p>我们再次对上面的程序使用命令: go run -race main.go, 那么数据探测器可以检测到:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Write at 0x00c420090180 by goroutine 6:</span><br><span class="line">  runtime.mapassign_faststr()</span><br><span class="line">      /usr/local/Cellar/go/1.10/libexec/src/runtime/hashmap_fast.go:694 +0x0</span><br><span class="line">  main.main.func1()</span><br><span class="line">      /Users/a/.go/src/github.com/gorocks/snippets/go/cmd/gosnippets/main.go:9 +0x5d</span><br><span class="line"></span><br><span class="line">Previous write at 0x00c420090180 by main goroutine:</span><br><span class="line">  runtime.mapassign_faststr()</span><br><span class="line">      /usr/local/Cellar/go/1.10/libexec/src/runtime/hashmap_fast.go:694 +0x0</span><br><span class="line">  main.main()</span><br><span class="line">      /Users/a/.go/src/github.com/gorocks/snippets/go/cmd/gosnippets/main.go:12 +0xc9</span><br><span class="line"></span><br><span class="line">Goroutine 6 (running) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      /Users/a/.go/src/github.com/gorocks/snippets/go/cmd/gosnippets/main.go:8 +0x9a</span><br><span class="line">==================</span><br><span class="line">1 a</span><br><span class="line">2 b</span><br><span class="line">Found 1 data race(s)</span><br><span class="line">exit status 66</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://blog.golang.org/defer-panic-and-recover" target="_blank" rel="noopener">Defer, Panic, and Recover</a></li><li><a href="https://golang.org/ref/spec" target="_blank" rel="noopener">Go spec</a></li><li><a href="https://golang.org/ref/mem/" target="_blank" rel="noopener">The Go Memory Model</a></li><li><a href="https://golang.org/doc/articles/race_detector.html" target="_blank" rel="noopener">Data Race Detector</a></li></ul></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>定义 Go 模块</title>
      <link href="/post/vgo-module.html"/>
      <url>/post/vgo-module.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自 <a href="https://research.swtch.com/vgo-module" target="_blank" rel="noopener">Defining Go Modules</a>, <a href="https://lingchao.xin/tag/vgo.html">Go &amp; Versioning</a> 的第 6 部分, 版权@归原文所有.<br><a id="more"></a><p></p><p>正如在<a href="https://lingchao.xin/post/vgo-intro.html">概述文章</a>中介绍的, Go 模块是作为一个版本化的软件包集合单元, 连同列出其他所需模块的 go.mod 文件. 转向模块是我们重新审视和修正 go 命令如何管理源代码的许多细节的机会. 在我们打算使用模块弃用当前的 go get 模型时, 10 年已经过去了. 我们需要确保模块设计将在未来十年为我们提供良好的服务. 尤其是:</p><ul><li>我们希望鼓励更多的开发人员为他们的软件包打标签(tag), 而不是期望用户只会选择一个对他们来说看起来很好的提交哈希. 标记显式发布清楚地表明了对别人有用的以及正在开发的东西. 同时, 它仍然可以 - 尽管可能不方便 - 请求特定的提交.</li><li>我们想脱离版本控制工具如 bzr, fossil, git, hg, 以及 svn 来下载源代码. 因为这些破坏了生态系统: 例如, 使用 Bazaar 或 Fossil 开发的软件包对于不能或不选择安装这些工具的用户而言是不可用的. 版本控制工具也是<a href="https://golang.org/issue/22131" target="_blank" rel="noopener">激动人心的</a> <a href="https://www.mercurial-scm.org/wiki/WhatsNew/Archive#Mercurial_3.2.3_.282014-12-18.29" target="_blank" rel="noopener">安全</a> <a href="https://git-blame.blogspot.com/2014/12/git-1856-195-205-214-and-221-and.html" target="_blank" rel="noopener">问题</a>的来源. 将它们移到安全边界之外是一件好事.</li><li>我们希望允许在单个源代码库中开发多个模块, 但版本保持独立. 尽管大多数开发人员可能会继续使用每个代码库作为一个模块, 但大型项目可能会因在一个代码库中拥有多个模块而受益. 例如, 我们希望将 golang.org/x/text 保留为单个代码库, 但能够将从既定软件包分离出去的实验性新软件包分别版本化.</li><li>我们希望让个人和公司能够轻松地将缓存代理放在 go get 之前进行下载, 无论是否可用(使用本地副本以确保明天下载依然工作)或是否安全(包在公司使用之前进行验证).</li><li>我们希望在将来的某个时候, 为 Go 社区引入一个共享代理, 类似于 Rust, Node 和其他语言所使用的代理. 同时, 设计必须在没有假设代理或注册的情况下运行良好.</li><li>我们希望消除 vendor 目录. 它们是为了可重复性和可用性而推出的, 但我们现在拥有更好的机制. 可重现性由正确的版本控制处理, 可用性由缓存代理处理.</li></ul><p>这篇文章介绍了解决这些问题的 vgo 设计的部分内容. 这里的一切都是初步的: 如果我们发现它不正确, 我们会改变设计.</p><h3 id="版本化发布"><a href="#版本化发布" class="headerlink" title="版本化发布"></a>版本化发布</h3><p>抽象界限让项目规模化. 最初, 所有的 Go 软件包都可以被所有其他的 Go 软件包导入. 我们在 Go 1.4 中引入了内部(internal)目录约定, 以消除开发人员选择构造一个包含多个软件包的程序的问题, 因为需要担心其他用户导入内部辅助软件包, 这些辅助软件包并不公用.</p><p>Go 社区现在与代码库提交有类似的可见性问题. 今天, 用户通过提交标识符(通常是 Git 哈希) 来识别包版本是非常普遍的, 其结果是, 将工作组织为一系列提交的开发人员需要担心, 至少在他们的想法背后, 用户固定的这些提交可能并不为公开使用. (译注: 作者的意思是说对于 Git 这种来说某一个 commit 有可能只是实验性质的提交, 本质上说不是为了公用.) 我们需要改变 Go 开源社区的期许, 以确立作者标签发布和用户所喜欢的规范.</p><p>我不认同这一点: 用户应该从作者发布的版本中进行选择, 而不是从 Git 历史记录中挑选单独的提交, 这一点尤其有争议. 困难的部分正在改变规范. 我们需要让作者易于标记提交并方便用户使用这些标记.</p><p>作者今天共享代码的最常用方式是代码托管网站, 尤其是 GitHub. 对于 GitHub 上的代码, 所有作者需要做的是标记提交并推送标签. 我们还计划提供一个工具(可能称为 go release)来比较不同版本的模块在类型级别的 API 兼容性,  以捕获类型系统中可见的意外破坏性更改, 以及帮助作者在发布的时候做出决定是次要版本(因为它增加了新的 API 或更改了许多行代码)还是只是一个补丁版本.</p><p>对于用户来说, vgo 本身完全是根据标签版本来运作的. 然而, 我们知道, 至少在从旧实践向新实践过渡的过程中, 也许无限期地作为引导新项目的一种方式, 为了允许指定提交, 必须有一个逃生舱口. (译注: 原文作者戏虐的说法, 其实就是变通方案.) 这在 vgo 中是可能的, 但它的设计是为了让用户更倾向于明确标记的版本.</p><p>具体来说, vgo 理解特殊的伪版本 v0.0.0-yyyymmddhhmmss-commit 引用给定的提交标识符, 它通常是一个缩短的 Git 哈希, 并且必须具有与(UTC)时间戳匹配的提交时间. 这种形式是 v0.0.0 预发布的有效语义版本字符串. 例如, 节选自 Gopkg.toml 的一段:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[projects]]</span><br><span class="line">  name = &quot;google.golang.org/appengine&quot;</span><br><span class="line">  packages = [</span><br><span class="line">    &quot;internal&quot;,</span><br><span class="line">    &quot;internal/base&quot;,</span><br><span class="line">    &quot;internal/datastore&quot;,</span><br><span class="line">    &quot;internal/log&quot;,</span><br><span class="line">    &quot;internal/remote_api&quot;,</span><br><span class="line">    &quot;internal/urlfetch&quot;,</span><br><span class="line">    &quot;urlfetch&quot;</span><br><span class="line">  ]</span><br><span class="line">  revision = &quot;150dc57a1b433e64154302bdc40b6bb8aefa313a&quot;</span><br><span class="line">  version = &quot;v1.0.0&quot;</span><br><span class="line"></span><br><span class="line">[[projects]]</span><br><span class="line">  branch = &quot;master&quot;</span><br><span class="line">  name = &quot;github.com/google/go-github&quot;</span><br><span class="line">  packages = [&quot;github&quot;]</span><br><span class="line">  revision = &quot;922ceac0585d40f97d283d921f872fc50480e06e&quot;</span><br></pre></td></tr></table></figure><p>对应于这些 go.mod 行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require (</span><br><span class="line">&quot;google.golang.org/appengine&quot; v1.0.0</span><br><span class="line">&quot;github.com/google/go-github&quot; v0.0.0-20180116225909-922ceac0585d</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>选择伪版本形式以便标准的 semver 优先级规则按提交时间比较两个伪版本, 因为时间戳编码使字符串比较匹配时间比较. 这种形式还可以确保 vgo 始终优先使用带标签的语义版本而不使用未标记的伪版本, 即使 v0.0.1 非常旧, 它的优先级比任何 v0.0.0 预发布版本都要高. (还要注意, 这与dep向项目添加新依赖项时所做的选择相匹配.) 当然, 伪版本字符串很难使用: 它们在 go.mod 文件里, 也可以 vgo list -m 输出. 所有这些不便之处都有助于鼓励作者和用户更喜欢明确标记的版本, 有点像不得不写 import “unsafe” 这种额外的步骤一样鼓励开发人员倾向于编写安全的代码.</p><h3 id="go-mod-文件"><a href="#go-mod-文件" class="headerlink" title="go.mod 文件"></a>go.mod 文件</h3><p>模块版本由源文件树定义. go.mod 文件描述了该模块, 并且还指出了根目录. 当 vgo 运行在一个目录中时, 它会查看当前目录, 然后查找连续父目录, 以找到标记根目录的 go.mod.</p><p>文件格式是面向行的, 只通过 “//“ 注释. 每行保存单个指令, 该指令是单个动词(module, require, exclude, 或者 replace, 由<a href="https://research.swtch.com/vgo-mvs" target="_blank" rel="noopener">最小版本选择</a>所定义), 随后是参数:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module &quot;my/thing&quot;</span><br><span class="line">require &quot;other/thing&quot; v1.0.2</span><br><span class="line">require &quot;new/thing&quot; v2.3.4</span><br><span class="line">exclude &quot;old/thing&quot; v1.2.3</span><br><span class="line">replace &quot;bad/thing&quot; v1.4.5 =&gt; &quot;good/thing&quot; v1.4.5</span><br></pre></td></tr></table></figure><p>顶头的动词可以从临近的行里分解出来, 自成一个块, 就像 Go 导入包一样:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">require (</span><br><span class="line">&quot;new/thing&quot; v2.3.4</span><br><span class="line">&quot;old/thing&quot; v1.2.3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我对文件格式的目标是 (1) 清晰和简单, (2) 易于人们阅读, 编辑, 操作和比较, (3) 易于 vgo 等程序读取, 修改和回写, 保留评论和总体结构, 以及 (4) 有限的未来增长空间. 我看了 JSON, TOML, XML 和 YAML, 但他们没有一个似乎同时拥有这四个属性. 例如, Gopkg.toml 上面使用的方法为每个依赖书写三行, 这使得它们更难以浏览, 排序和比较. 相反, 我设计了一个最小格式, 让人联想到 Go程序的头部, 但希望没有足够接近让人困惑. 我改写了一个已存在的注释友好的解析器.</p><p>最终集成的 go 命令可能会更改文件格式, 甚至采用更标准的框架, 但对于兼容性, 我们将保持继续阅读今天 go.mod 文件的能力, 就如同 vgo 还可以从 GLOCKFILE, Godeps/Godeps.json, Gopkg.lock, dependencies.tsv, glide.lock, vendor.conf, vendor.yml, vendor/manifest, 以及 vendor/vendor.json 文件中读取依赖信息一样.</p><h3 id="从代码库到模块"><a href="#从代码库到模块" class="headerlink" title="从代码库到模块"></a>从代码库到模块</h3><p>开发人员在版本控制系统中工作, 显然 vgo 必须尽可能简单. 例如, 期望开发人员自己准备模块存档(archives)是不合理的. 相反, vgo 可以按照一些基本的, 不显眼的约定, 从任何版本控制库直接导出模块.</p><p>首先, 创建一个代码库并用类似于 v0.1.0 这样的一个 semver 格式标记一个提交, 就足够了. 顶头的 v 是必需的, 并且还需要三个数字. 虽然 vgo 它自己接受命令行中 v0.1 的简写形式, 但规范形式 v0.1.0 必须在代码库标记中使用, 以避免歧义. 只有标签是必需的. 为了不使用 vgo 的时候也可以使用提交, 在这一点上一个 go.mod 文件要求并不严格. 创建新的标记提交可创建新的模块版本. 简单.</p><p>当开发人员到达 v2 时, 语义导入版本控制意味着 /v2/ 在模块根前缀的末尾添加了一个导入路径: my/thing/v2/sub/pkg. 正如<a href="https://research.swtch.com/vgo-import" target="_blank" rel="noopener">前面的文章</a>中所述, 这个约束有很好的理由, 但是它仍然偏离现有的工具. 意识到这一点, vgo 如果不先检查 go.mod 文件中有主版本的模块路径声明(例如, module “my/thing/v2”) 就不会使用源码库中的 v2 或更高标记版本. Vgo 使用该声明作为作者使用语义导入版本控制来命名该模块中的包的证据. 这对多包模块来说尤其重要, 因为模块中的导入路径必须包含 /v2/ 元素以避免引用回 v1 模块.</p><p>我们预计大多数开发人员会更喜欢遵循通常的 “主分支” 约定, 其中不同的主版本存在于不同的分支中. 在这种情况下, v2 分支中的根目录将有一个表明 v2 的 go.mod, 如下所示:</p><p><a href="/static/images/gitmod-1@2x.png" class="gallery-item"><img src="/static/images/gitmod-1@2x.png" width="591px" height="416px"></a></p><p>这大致是大多数开发人员已在工作的(流程). 在图中, v1.0.0 标签指向一个早于 vgo 的提交. 它根本没有 go.mod 文件, 而且工作正常. 在提交标记 v1.0.1 中, 作者添加了一个 go.mod module “my/thing”.<br>然而, 在那个提交之后, 作者分叉了一个新的 v2 开发分支. 除了任何更改代码提示 V2 (包括更换 bar 用 quux)时, go.mod 在新的分支更新为 module “my/thing/v2”. 分支可以独立前进. 事实上, vgo 真的不知道分支(的存在). 它只是将标签解析为提交, 然后在提交中查看 go.mod 文件. 同样, 该 go.mod 文件是 v2 及更高版本所必需的, 以便 vgo 可以使用该文件中的 module 行作为代码使用了语义导入版本控制的标志, 所以 foo 导入的是 my/thing/v2/foo/quux, 不是 my/thing/foo/quux.</p><p>作为替代方案, vgo 还支持 “主子目录” 约定, 在子目录中开发了 V1 以上的主要版本:</p><p><a href="/static/images/gitmod-2@2x.png" class="gallery-item"><img src="/static/images/gitmod-2@2x.png" width="376px" height="768px"></a></p><p>在这种情况下, v2.0.0 不是通过将整个树分叉为单独的分支而是通过将其复制到子目录中来创建的. 再次 go.mod 更新为 “my/thing/v2”. 之后, v1.x.x 标记指向根目录文件的提交, 不包含 v2/, 而 v2.x.x 标记仅指向 v2/ 子目录的提交. go.mod 文件可以使 vgo 区分这两种情况. 将 v1.x.x 和 v2.x.x 标记指向相同的提交也是有意义的: 它们将处理提交的不同子树.</p><p>我们期望开发者可能会强烈地选择一种或另一种约定. vgo 同时支持这两种. 请注意, 对于 v2 以上的主版本, 主子目录方案可能会为 go get 用户提供优雅的过渡. 另一方面, dep 或 vendoring 工具的用户应该能够使用任何约定之一来使用代码库. 当然, 我们会确保 dep 可以.</p><h3 id="多模块代码库"><a href="#多模块代码库" class="headerlink" title="多模块代码库"></a>多模块代码库</h3><p>开发人员也可能发现在单个源代码库中维护一组模块是很有用的. 我们想让 vgo 支持这种可能性. 总的来说, 不同的开发人员, 团队, 项目和公司应用源代码控制的方式已经有很大差异, 我们认为将 “单一代码库等同于一个模块” 这样的单一映射强加给所有开发人员并不是很有成效. 在这方面有一定的灵活性也应该有助于 vgo 适应围绕源码控制的最佳实践不断变化.</p><p>在主子目录约定中, v2/ 包含模块 “my/thing/v2”. 一个自然的扩展允许没有为主版本命名的子目录. 例如, 我们可以添加一个 blue/ 包含 “my/thing/blue” 模块的子目录, 并由具有该模块路径 blue/go.mod 的文件确认. 在这种情况下, 处理该模块的源代码控制提交标签将采用这种形式 blue/v1.x.x. 同样, 标签 blue/v2.x.x 将处理 blue/v2/ 子目录. blue/go.mod 文件的存在将 blue/ 树从外部 my/thing 模块中排除.</p><p>在 Go 项目中, 我们打算探索使用这个约定来允许像 golang.org/x/text 这样的代码库定义多个独立的模块. 这让我们保留了粗粒度源码控制的便利, 但仍然在不同的时间将不同的子树提升到 v1.</p><h3 id="已过时的版本"><a href="#已过时的版本" class="headerlink" title="已过时的版本"></a>已过时的版本</h3><p>作者还需要能够弃用一个版本, 以表明它不应该再被使用. 这还没有在 vgo 原型中实现, 但它可以工作的一种方式是在代码托管站点上定义一个标记 v1.0.0+deprecated (理想情况下指向与 v1.0.0 相同的提交)将表明该提交已被弃用. 当然重要的是不要完全删除标签, 因为这会破坏构建. 弃用的模块会以某种方式在 vgo list -m -u 输出中高亮显示(“显示我的模块和有关更新的信息”), 以便用户知道要更新.</p><p>另外, 因为程序可以在运行时访问自己的模块列表和版本, 所以程序也可以配置为根据某些选定的权限检查自己的模块版本, 并在运行弃用版本时以某种方式自行报告. 同样, 这里的细节还没有解决, 但是一旦开发人员和工具共享描述版本的词汇表, 这就是一个很好的例子.</p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>给定一个源代码控制库, 开发人员需要能够以 vgo 可以使用的形式发布它. 在一般情况下, 我们将提供一个命令, 作者运行它们将其源代码控制代码库转换为通过任何静态文件 web 服务器提供给 vgo 使用的文件树. 与当前 go get 类似, vgo 需要一个带有 <meta> 标签的页面来帮助将模块名称转换为该模块的文件树. 例如, 要查找 swtch.com/testmod, vgo 命令将这样获取通常的页面:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -sSL &apos;https://swtch.com/testmod?go-get=1&apos;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;meta name=&quot;go-import&quot; content=&quot;swtch.com/testmod mod https://storage.googleapis.com/gomodules/rsc&quot;&gt;</span><br><span class="line">Nothing to see here.</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>mod 服务器类型表明模块通过该基本 URL 上的文件数提供. storage.googleapis.com/gomodules/rsc 中这个简单案例中的相关文件是:</p><ul><li><a href="https://storage.googleapis.com/gomodules/rsc/swtch.com/testmod/@v/list" target="_blank" rel="noopener">.../swtch.com/testmod/@v/list</a></li><li><a href="https://storage.googleapis.com/gomodules/rsc/swtch.com/testmod/@v/v1.0.0.info" target="_blank" rel="noopener">.../swtch.com/testmod/@v/v1.0.0.info</a></li><li><a href="https://storage.googleapis.com/gomodules/rsc/swtch.com/testmod/@v/v1.0.0.mod" target="_blank" rel="noopener">.../swtch.com/testmod/@v/v1.0.0.mod</a></li><li><a href="https://storage.googleapis.com/gomodules/rsc/swtch.com/testmod/@v/v1.0.0.zip" target="_blank" rel="noopener">.../swtch.com/testmod/@v/v1.0.0.zip</a></li></ul><p>这些 URL 的确切含义在后面的 “下载协议” 一节中讨论.</p><h3 id="代码托管网站"><a href="#代码托管网站" class="headerlink" title="代码托管网站"></a>代码托管网站</h3><p>对于代码托管网站上巨大数量的开发, 我们希望 vgo 尽可能顺利地融入进来. 而不希望开发人员在其他地方发布模块, 然后让 vgo 支持使用基于 HTTP 的API 直接从这些站点读取所需信息. 一般来说, 档案下载可以比现有版本控制签出快得多. 例如, 在使用千兆互联网连接的笔记本电脑上工作时, 需要 10 秒钟将 <a href="https://github.com/cockroachdb/cockroach" target="_blank" rel="noopener">CockroachDB 源码树</a>作为 GitHub 的 zip 文件下载, 但需要大约 4 分钟的时间进行 git clone. 网站只需提供一个可以通过简单的 HTTP GET 获取的任何形式的存档. 例如, Gerrit 服务器仅支持下载 gzipped 归档文件. Vgo 将下载的档案转换为标准形式.</p><p>最初的原型只包括对 GitHub 和 Go 项目的 Gerrit 服务器的支持, 但是在进入 Go 主工具链之前, 我们也会增加对 Bitbucket 和其他主要托管站点的支持.</p><p>通过轻量级代码库约定(主要与开发人员已经在做的事情相匹配)以及对已知代码托管站点的支持相结合, 我们预计大多数开源活动都不会受到向模块转移的影响，而只是简单地在每个代码库里面添加 go.mod.</p><p>使用旧版本 go get (直接使用 git 和其他源码控制工具)的公司需要进行调整. 也许编写一个满足 vgo 期望但使用版本控制工具的代理是有意义的. 然后, 公司可以运行其中的一种产生类似使用开源托管站点的体验.</p><h3 id="模块档案"><a href="#模块档案" class="headerlink" title="模块档案"></a>模块档案</h3><p>从代码库到模块的映射有点复杂, 因为开发人员使用源代码控制的方式各不相同. 最终目标是将所有复杂性映射到代理或其他代码使用者(例如 godoc.org 或任何代码检查工具)使用的 Go 模块的通用单一格式.</p><p>vgo 原型中的标准格式是 zip 档案, 其中所有路径都以模块路径和版本开头. 例如, 运行 rsc.io/quoteV1.5.2 的 vgo get 后, 你可以在 vgo 的下载缓存里找到 zip 文件:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ unzip -l $GOPATH/src/v/cache/rsc.io/quote/@v/v1.5.2.zip</span><br><span class="line">     1479  00-00-1980 00:00   rsc.io/quote@v1.5.2/LICENSE</span><br><span class="line">      131  00-00-1980 00:00   rsc.io/quote@v1.5.2/README.md</span><br><span class="line">      240  00-00-1980 00:00   rsc.io/quote@v1.5.2/buggy/buggy_test.go</span><br><span class="line">       55  00-00-1980 00:00   rsc.io/quote@v1.5.2/go.mod</span><br><span class="line">      793  00-00-1980 00:00   rsc.io/quote@v1.5.2/quote.go</span><br><span class="line">      917  00-00-1980 00:00   rsc.io/quote@v1.5.2/quote_test.go</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>我使用了 zip, 因为它是精心指定的, 广泛支持的, 并且如果需要可以干净地扩展, 并允许随机访问单个文件. (相比之下, tar 文件是另一个显而易见的选择, 但是都不满足这些特点.)</p><h3 id="下载协议"><a href="#下载协议" class="headerlink" title="下载协议"></a>下载协议</h3><p>要下载有关模块的信息以及模块本身, vgo 原型仅发出简单的 HTTP GET 请求. 一个关键的设计目标是使得可以从静态托管站点提供模块, 因此请求没有 URL 查询参数.</p><p>正如我们前面看到的, 自定义域可以指定模块托管在特定的基本 URL. 像 vgo 今天实现的那样(但是, vgo 的所有这些可能会发生变化), 该模块托管服务器必须提供四种请求格式:</p><ul><li>GET baseURL/module/@v/list 获取所有已知版本的列表, 每行一个.</li><li>GET baseURL/module/@v/version.info 获取有关该版本的 JSON 格式的元数据.</li><li>GET baseURL/module/@v/version.mod 获取该版本的 go.mod 文件.</li><li>GET baseURL/module/@v/version.zip 获取该版本的 zip 文件.</li></ul><p>以 version.info 形式提供的 JSON 信息可能会演化, 但现在它对应于此结构:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type RevInfo struct &#123;</span><br><span class="line">Version string    // version string</span><br><span class="line">Name    string    // complete ID in underlying repository</span><br><span class="line">Short   string    // shortened ID, for use in pseudo-version</span><br><span class="line">Time    time.Time // commit time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vgo list -m -u 命令通过使用 Time 字段显示每个可用更新的提交时间.</p><p>一个通用的模块托管服务器也可以有选择地响应非 semver 版本的 version.info 请求. 像这样的 vgo 命令:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vgo get my/thing/v2@1459def</span><br></pre></td></tr></table></figure><p>将获取 1459def.info 并使用 Time 和 Short 字段派生伪版本.</p><p>还有两种可选的请求形式:</p><ul><li>GET baseURL/module/@t/yyyymmddhhmmss 在给定的时间戳之前返回或返回最新版本的 .info JSON.</li><li>GET baseURL/module/@t/yyyymmddhhmmss/branch 同上, 但将搜索限制在给定分支上的提交.</li></ul><p>这些支持在 vgo 使用未标记的提交. 如果 vgo 正在添加一个模块却根本找不到标签提交, 它将使用第一种形式来查找截至目前的最新提交. 它在查找可用更新时也是如此, 假定仍然没有标记提交. 分支限制形式用于 gopkg.in 的内部模拟. 这些形式也支持命令行语法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vgo get my/thing/v2@2018-02-01T15:34:45</span><br><span class="line">vgo get my/thing/v2@2018-02-01T15:34:45@branch</span><br></pre></td></tr></table></figure><p>这可能是一个失误, 但他们在今天的原型, 所以我提到他们.</p><h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>个人和公司都可能更喜欢从代理服务器下载 Go 模块, 无论是为了效率, 可用性, 安全性, 许可证合规性还是任何其他原因. 如前两节所述, 使用标准的 Go 模块格式和标准的下载协议使得引入对代理的支持变得微不足道. 如果 $GOPROXY 设置了环境变量, vgo 则从给定的基础 URL 获取服务器中的所有模块, 而不是从其通常的位置获取. 为了便于调试, $GOPROXY 甚至可以是指向本地文件树的 file:/// URL.</p><p>我们打算编写一个基于 vgo 本地缓存的基本代理服务器, 根据需要下载新模块. 在一组计算机中共享这样的代理将有助于减少来自代理用户的冗余下载, 但更重要的是确保将来的可用性, 即使原始副本消失. 代理也可以选择不允许下载新模块. 在此模式下, 代理会将可用模块限制到代理管理员列入白名单的那些模块. 这两种代理模式都是企业环境中经常需要的功能.</p><p>也许有一天, 建立 go get 默认使用的分布式代理服务器集合是有意义, 以确保全球 Go 开发者的模块可用性和快速下载. 但还没准备好. 今天, 我们专注于确保 go get 无需假设任何类型的集中式代理服务器即可运行.</p><h3 id="Vendoring-的结束"><a href="#Vendoring-的结束" class="headerlink" title="Vendoring 的结束"></a>Vendoring 的结束</h3><p>Vendor 目录有两个目的. 首先, 他们通过其内容指定在 go build 过程中使用的依赖关系的确切版本. 其次, 即使原始副本消失, 它们也可确保这些依赖项的可用性. 另一方面，vendor 目录也很难管理和膨胀它们出现的代码库. 通过 go.mod 文件指定要在 vgo build 使用的依赖关系的确切版本, 以及代理服务器确保可用性, vendor 目录现在几乎完全是冗余的. 但是, 它们可以为最终目的服务: 实现向新版本世界的平稳过渡.</p><p>在构建模块时 vgo (和稍后 go) 将完全忽略 vendored 的依赖; 这些依赖也不会包含在模块的 zip 文件中. 为了能够让作者迁移到 vgo 与 go.mod, 同时仍然支持没有完成转换的用户, 新的 vgo vendor 命令通过填充模块的 vendor 目录中用户使用的包来产生基于 vgo 的构建.</p><h3 id="接下来呢"><a href="#接下来呢" class="headerlink" title="接下来呢 ?"></a>接下来呢 ?</h3><p>这里的细节可能会被修改, 但今天的 go.mod 文件将被任何未来的工具所理解. 请开始使用发布标签标记你的软件包; 请添加 go.mod 文件使你的项目有意义.</p><p>本系列的下一篇文章将介绍对 go 工具命令行体验的更改.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
            <tag> vgo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>可复制, 可验证, 已验证的构建</title>
      <link href="/post/vgo-repro.html"/>
      <url>/post/vgo-repro.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自 <a href="https://research.swtch.com/vgo-repro" target="_blank" rel="noopener">Reproducible, Verifiable, Verified Builds</a>, <a href="https://lingchao.xin/tag/vgo.html">Go &amp; Versioning</a> 的第 5 部分, 版权@归原文所有.<br><a id="more"></a><p></p><p>一旦 Go 开发人员和工具都共享了包版本控制的词汇表, 那么在工具链中添加可复制, 可验证以及已验证的构建就相对简单了. 事实上, 这基本上已经在 vgo 原型中了.</p><p>由于人们有时对这些术语的确切定义不一致，让我们来建立一些基本的术语. 针对这篇文章:</p><ul><li>一个可复制的构建, 当重复构建时, 会产生相同的结果.</li><li>一个可验证的构建, 记录足够的信息以精确地描述如何重复它.</li><li>一个已验证的构建, 可以检查是否使用了预期的源代码.</li></ul><p>Vgo 在默认情况下提供可复制的构建. 生成的二进制文件是可验证的, 因为它们记录了进入构建的确切源代码的版本. 并且可以配置你的代码库, 以便用户重新构建你的软件, 验证他们的构建与你的构建匹配, 使用加密的哈希, 无论它们如何获得依赖项.</p><h3 id="可复制-重复-的构建"><a href="#可复制-重复-的构建" class="headerlink" title="可复制(重复)的构建"></a>可复制(重复)的构建</h3><p>至少, 我们希望确保在你构建我的程序时, 构建系统决定使用相同的代码版本. 最小版本选择在默认情况下交付该属性. 仅使用 go.mod 文件就足以确定应该使用哪个模块版本(假设依赖关系可用), 而且即使将模块的新版本引入到生态系统中, 这个决策也是稳定的. 这与大多数其他系统不同, 后者自动地采用新版本, 并且需要限制来生成可复制的构建. 我在 最小版本选择 文章中提到过这个, 但它是一个重要的, 微妙的细节, 所以我将尝试在这里简短地重复一下.</p><p>为了使这个具体化, 让我们看看来自 Rust的包管理器 Cargo 的几个真正的包. 很明显，我不是在挑剔 Cargo, 我认为 Cargo 是包管理当前艺术水平的一个例子, 并且有很多可以从中学习. 如果我们能让 Go 的包管理像 Cargo 一样平稳, 那么我很开心. 但我也认为, 在选择版本时, 我们是否会从选择不同的默认值中受益, 这是值得探讨的.</p><p>Cargo 更喜欢以下意义上的最大版本. 当我写这篇文章时, crates.io 上最新的 <a href="https://crates.io/crates/toml" target="_blank" rel="noopener">toml</a> 版本是 0.4.5. 它列出了对 serde 1.0 或更高版本的依赖; 最新的 serde 是 1.0.27. 如果你启动一个新项目并添加对 toml 0.4.1 或更高版本的依赖, Cargo 可以作出选择. 根据约束, 0.4.1, 0.4.2, 0.4.3, 0.4.4 或 0.4.5 中的任何一个都是可接受的. 在所有其他条件相同的情况下, Cargo 倾向于使用<a href="https://research.swtch.com/cargo-newest.html" target="_blank" rel="noopener">最新的可接受版本</a> 0.4.5. 同样, 从 1.0.0 到 1.0.27 的任何一个 serde 都是可以接受的, Cargo 选择 1.0.27. 这些选择随着新版本的推出而改变. 如果今晚发布了 serde 1.0.28, 并且明天我将 toml 0.4.5 添加到了项目中, 那么我将得到 1.0.28 而不是 1.0.27. 正如迄今为止所描述的, Cargo 的构建是不可复制的. Cargo 对这个问题的(完全合理的)答案是不仅有一个约束文件 (manifest, Cargo.toml), 而且还有一个在构建中使用的确切组件(artifacts)的列表(lock 文件 Cargo.lock). lock 文件阻止将来的升级; 一旦写入, 即使 1.0.28 发布, 你的构建仍然保留在 serde 1.0.27 上.</p><p>相比之下, 最小版本选择偏好允许的最小版本, 这是项目中某些 go.mod 所要求的确切版本. 这个答案不会随着新版本的添加而改变. 对比 Cargo 示例中给出的选择, vgo 会选择 toml 0.4.1 (你要求的), 然后选择 serde 1.0 (toml 要求的). 这些选择是稳定的, 没有 lock 文件. 这就是我说 vgo 的构建默认可复制的意思.</p><h3 id="可验证的构建"><a href="#可验证的构建" class="headerlink" title="可验证的构建"></a>可验证的构建</h3><p>Go 的二进制文件一直包含一个字符串, 表示它们的 Go 版本. 去年, 我编写了一个工具 rsc.io/goversion, 它从给定的可执行文件或可执行文件树中获取这些信息. 例如, 在我的 Ubuntu Linux 笔记本电脑上, 我可以看看哪些系统实用程序是 Go 实现的:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go get -u rsc.io/goversion</span><br><span class="line">$ goversion /usr/bin</span><br><span class="line">/usr/bin/containerd go1.8.3</span><br><span class="line">/usr/bin/containerd-shim go1.8.3</span><br><span class="line">/usr/bin/ctr go1.8.3</span><br><span class="line">/usr/bin/go go1.8.3</span><br><span class="line">/usr/bin/gofmt go1.8.3</span><br><span class="line">/usr/bin/kbfsfuse go1.8.3</span><br><span class="line">/usr/bin/kbnm go1.8.3</span><br><span class="line">/usr/bin/keybase go1.8.3</span><br><span class="line">/usr/bin/snap go1.8.3</span><br><span class="line">/usr/bin/snapctl go1.8.3</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>现在 vgo 原型可以理解模块版本, 它也将这些信息包含在最终的二进制文件中, 并且新的 goversion -m 标志将其打印出来. 使用我们来自 <a href="https://lingchao.xin/post/vgo-tour.html">tour</a> 的 “hello, world” 程序:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go get -u rsc.io/goversion</span><br><span class="line">$ goversion ./hello</span><br><span class="line">./hello go1.10</span><br><span class="line">$ goversion -m hello</span><br><span class="line">./hello go1.10</span><br><span class="line">path  github.com/you/hello</span><br><span class="line">mod   github.com/you/hello  (devel)</span><br><span class="line">dep   golang.org/x/text     v0.0.0-20170915032832-14c0d48ead0c</span><br><span class="line">dep   rsc.io/quote          v1.5.2</span><br><span class="line">dep   rsc.io/sampler        v1.3.0</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>主模块 github.com/you/hello, 没有版本信息, 因为它是本地开发副本, 而不是我们下载的特定版本. 但是如果我们直接从有版本的模块构建命令, 那么列表会报告所有模块的版本:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo build -o hello2 rsc.io/hello</span><br><span class="line">vgo: resolving import &quot;rsc.io/hello&quot;</span><br><span class="line">vgo: finding rsc.io/hello (latest)</span><br><span class="line">vgo: adding rsc.io/hello v1.0.0</span><br><span class="line">vgo: finding rsc.io/hello v1.0.0</span><br><span class="line">vgo: finding rsc.io/quote v1.5.1</span><br><span class="line">vgo: downloading rsc.io/hello v1.0.0</span><br><span class="line">$ goversion -m ./hello2</span><br><span class="line">./hello2 go1.10</span><br><span class="line">path  rsc.io/hello</span><br><span class="line">mod   rsc.io/hello       v1.0.0</span><br><span class="line">dep   golang.org/x/text  v0.0.0-20170915032832-14c0d48ead0c</span><br><span class="line">dep   rsc.io/quote       v1.5.2</span><br><span class="line">dep   rsc.io/sampler     v1.3.0</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>当我们集成版本进 Go 工具链时, 我们将添加 API 以从运行时库访问此信息, 就像 <a href="https://golang.org/pkg/runtime/#Version" target="_blank" rel="noopener">runtime.Version</a> 提供了受限的 Go 版本信息访问.</p><p>为了尝试重构二进制文件, 通过 goversion -m 列出的信息就足够了: 将版本放入 go.mod 文件并构建在路径行上命名的目标. 但如果结果不是相同的二进制文件, 你可能想知道如何缩小不同的方法. 什么改变了 ?</p><p>当 vgo 下载每个模块时, 它会计算与该模块相对应的文件树的哈希值. 该哈希也包含在二进制文件中, 并附有版本信息, 而且 goversion -mh 也可以打印出它:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ goversion -mh ./hello</span><br><span class="line">hello go1.10</span><br><span class="line">path  github.com/you/hello</span><br><span class="line">mod   github.com/you/hello  (devel)</span><br><span class="line">dep   golang.org/x/text     v0.0.0-20170915032832-14c0d48ead0c  h1:qgOY6WgZOaTkIIMiVjBQcw93ERBE4m30iBm00nkL0i8=</span><br><span class="line">dep   rsc.io/quote          v1.5.2                              h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3Y=</span><br><span class="line">dep   rsc.io/sampler        v1.3.1                              h1:F0c3J2nQCdk9ODsNhU3sElnvPIxM/xV1c/qZuAeZmac=</span><br><span class="line">$ goversion -mh ./hello2</span><br><span class="line">hello go1.10</span><br><span class="line">path  rsc.io/hello</span><br><span class="line">mod   rsc.io/hello       v1.0.0                              h1:CDmhdOARcor1WuRUvmE46PK91ahrSoEJqiCbf7FA56U=</span><br><span class="line">dep   golang.org/x/text  v0.0.0-20170915032832-14c0d48ead0c  h1:qgOY6WgZOaTkIIMiVjBQcw93ERBE4m30iBm00nkL0i8=</span><br><span class="line">dep   rsc.io/quote       v1.5.2                              h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3Y=</span><br><span class="line">dep   rsc.io/sampler     v1.3.0                              h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>h1: 前缀指示正在报告哪个哈希. 今天, 只有 “hash 1”, 文件列表的 SHA-256 哈希及其内容的 SHA-256 哈希. 如果我们需要稍后更新一个新的哈希, 这个前缀将帮助我们从新的哈希中告诉旧的.</p><p>我必须强调这些哈希是由构建系统自我报告的. 如果某人在构建信息中为您提供了具有特定哈希值的二进制文件, 则无法保证其准确性. 它们是支持以后验证的非常有用的信息, 而不是自己可以信任的签名.</p><h3 id="已验证的构建"><a href="#已验证的构建" class="headerlink" title="已验证的构建"></a>已验证的构建</h3><p>以源代码形式发布程序的作者可能希望让用户验证他们是否正在使用预期的依赖构建它. 我们知道 vgo 会做出与使用哪个版本的依赖相同的决定, 但仍然存在将 v1.5.2 等版本映射到实际源码树的问题. 如果 v1.5.2 的作者将标签(tag)更改为指向不同的文件树, 该怎么办 ? 如果恶意中间件拦截下载请求并提供不同的 zip 文件会怎么样 ? 如果用户不小心编辑了 v1.5.2 的本地副本中的源文件, 该怎么办 ? vgo 原型也支持这种验证.</p><p>最终形式可能有所不同, 但如果你在 go.mod 旁边创建一个名为 go.modverify 的文件, 那么构建将使用特定版本的模块的已知哈希使该文件保持最新:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &gt;go.modverify</span><br><span class="line">$ vgo build</span><br><span class="line">$ tcat go.modverify  # go get rsc.io/tcat, or use cat</span><br><span class="line">golang.org/x/text  v0.0.0-20170915032832-14c0d48ead0c  h1:qgOY6WgZOaTkIIMiVjBQcw93ERBE4m30iBm00nkL0i8=</span><br><span class="line">rsc.io/quote       v1.5.2                              h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3Y=</span><br><span class="line">rsc.io/sampler     v1.3.0                              h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>go.modverify 文件是所有有史以来遇到的版本的哈希日志: 只添加行, 不删除. 如果我们将 rsc.io/sampler 更新为 v1.3.1, 则日志现在将包含两个版本的哈希值:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo get rsc.io/sampler@v1.3.1</span><br><span class="line">$ tcat go.modverify</span><br><span class="line">golang.org/x/text  v0.0.0-20170915032832-14c0d48ead0c  h1:qgOY6WgZOaTkIIMiVjBQcw93ERBE4m30iBm00nkL0i8=</span><br><span class="line">rsc.io/quote       v1.5.2                              h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3Y=</span><br><span class="line">rsc.io/sampler     v1.3.0                              h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=</span><br><span class="line">rsc.io/sampler     v1.3.1                              h1:F0c3J2nQCdk9ODsNhU3sElnvPIxM/xV1c/qZuAeZmac=</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>当 go.modverify 存在时, vgo 将检查给定内部版本中使用的所有下载模块是否与文件中已有的条目一致. 例如, 如果我们将 rsc.io/quote 散列的第一个数字从 w 更改为 v:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo build</span><br><span class="line">vgo: verifying rsc.io/quote v1.5.2: module hash mismatch</span><br><span class="line">downloaded:   h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3Y=</span><br><span class="line">go.modverify: h1:v5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3Y=</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>或者假设我们修复了那个, 但是修改了 v1.3.0 哈希. 现在我们的构建成功了, 因为构建版本没有使用 v1.3.0, 所以它的行被(正确地)忽略了. 但是, 如果我们尝试降级到 v1.3.0, 那么构建验证将失败:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo build</span><br><span class="line">$ vgo get rsc.io/sampler@v1.3.0</span><br><span class="line">vgo: verifying rsc.io/sampler v1.3.0: module hash mismatch</span><br><span class="line">downloaded:   h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=</span><br><span class="line">go.modverify: h1:8uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>希望确保其他人使用与他们完全相同的源重建其程序的开发人员可以将 go.modverify 存储在其代码库中. 然后其他构建使用相同的代码库会自动获得验证构建. 目前, 只有构建的顶级模块中的 go.modverify 适用. 但请注意, go.modverify 会列出所有依赖关系, 包括间接依赖关系, 因此整个构建都会被验证.</p><p>go.modverify 特性可帮助检测不同机器下载的依赖之间的不匹配情况. 它比较 go.modverify 中的哈希值和模块下载时计算和保存的哈希值. 还可以检查下载的模块是否在本地机器上有没有发生更改. 这不是关于安全性的攻击, 更多的是关于避免错误. 例如, 因为源文件路径出现在堆栈跟踪中, 所以在调试时打开这些文件是很常见的. 如果你在调试过程中意外地(或者我认为是故意地)修改文件, 那么稍后能够检测到它将是很好的. vgo verify 命令执行此操作:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go get -u golang.org/x/vgo  # fixed a bug, sorry! :-)</span><br><span class="line">$ vgo verify</span><br><span class="line">all modules verified</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>如果源文件更改, vgo verify 会通知:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &gt;&gt;$GOPATH/src/v/rsc.io/quote@v1.5.2/quote.go</span><br><span class="line">$ vgo verify</span><br><span class="line">rsc.io/quote v1.5.2: dir has been modified (/Users/rsc/src/v/rsc.io/quote@v1.5.2)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>如果我们恢复文件, 一切都很好:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gofmt -w $GOPATH/src/v/rsc.io/quote@v1.5.2/quote.go</span><br><span class="line">$ vgo verify</span><br><span class="line">all modules verified</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>如果下载后修改了缓存的 zip 文件, vgo verify 也会通知, 尽管我无法合理解释可能发生的情况:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zip $GOPATH/src/v/cache/rsc.io/quote/@v/v1.5.2.zip /etc/resolv.conf</span><br><span class="line">  adding: etc/resolv.conf (deflated 36%)</span><br><span class="line">$ vgo verify</span><br><span class="line">rsc.io/quote v1.5.2: zip has been modified (/Users/rsc/src/v/cache/rsc.io/quote/@v/v1.5.2.zip)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>由于 vgo 在解压缩后会保留原始 zip 文件, 因此如果 vgo verify 确定只有 zip 文件和目录树中的一个已被修改, 则甚至可以打印这两者的差异.</p><h3 id="接下来呢"><a href="#接下来呢" class="headerlink" title="接下来呢 ?"></a>接下来呢 ?</h3><p>这已经在 vgo 中实现. 你可以尝试一下并使用它. 与 vgo 的其他部分一样, 对于哪些工作不正常(或工作出色)的反馈表示感激.</p><p>这里展示的功能更多的是一些东西的开始, 而不是一个完成的功能. 文件树的加密哈希是一个构建块. 建立在它之上的 go.modverify 检查开发人员是否都使用完全相同的依赖构建特定的模块, 但是在下载新版本的模块时没有验证(除非其他人已经将其添加到 go.modverify), 模块之间也没有共享预期的哈希值.</p><p>如何解决这两个缺点的确切细节并不明显. 允许某种类型的文件树的加密签名是有意义的, 并且要验证升级发现的版本与上一个版本的密钥相同. 或者, 在更新框架(<a href="https://theupdateframework.github.io/" target="_blank" rel="noopener">TUF</a>)中采用一种方法是有意义的, 尽管直接使用它们的网络协议是不实际的. 或者, 不要使用每个代码库 go.modverify 日志, 建立某种共享的全局日志可能有意义, 有点像<a href="https://www.certificate-transparency.org/" target="_blank" rel="noopener">证书透明度</a>, 或者使用一个类似 <a href="https://upspin.io/" target="_blank" rel="noopener">Upspin</a> 的公共身份服务器. 我们可能会探索很多途径, 但这些都有点超前了. 目前, 我们的重点是成功地将版本控制集成到 go 命令中.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
            <tag> vgo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最小版本选择</title>
      <link href="/post/vgo-mvs.html"/>
      <url>/post/vgo-mvs.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自 <a href="https://research.swtch.com/vgo-mvs" target="_blank" rel="noopener">Minimal Version Selection</a>, <a href="https://lingchao.xin/tag/vgo.html">Go &amp; Versioning</a> 的第 4 部分, 版权@归原文所有.<br><a id="more"></a><p></p><p><a href="https://lingchao.xin/post/vgo-intro.html">版本化的 Go 命令</a>必须决定在每个版本中使用哪个模块版本. 我把指定构建中用到的模块和版本列表称之为构建列表. 为了稳定开发, 今天的构建列表也必须是明天的构建列表. 但是, 开发人员也必须允许更改构建列表: 升级所有模块, 升级一个模块或降级一个模块.</p><p>因此<em>版本选择</em>问题是定义其意义并给出算法实现, 构建列表中的 4 个操作为:</p><ol><li>构造当前的构建列表.</li><li>将所有模块升级到最新版本.</li><li>将一个模块升级到特定的较新版本.</li><li>将一个模块降级到特定的旧版本.</li></ol><p>最后两个操作指定一个模块升级或降级, 但这样做可能需要升级, 降级, 添加或删除其他模块, 理想情况下应尽可能少, 以满足依赖性.</p><p>这篇文章介绍了最小版本选择, 这是一种新的, 简单的版本选择问题. 最小版本的选择很容易理解和预测, 这应该使其易于使用. 它还可以生成高保真构建, 其中用户构建的依赖关系尽可能的接近包作者开发用的依赖关系. 它的实现效率也很高, 不需要比递归图遍历更复杂, 因此 Go 中的完整的最小版本选择实现只有几百行代码.</p><p>最小版本选择假定每个模块声明自己的依赖性需求: 其他模块的最低版本列表. 假设模块遵循导入<a href="https://lingchao.xin/post/vgo-import.html">兼容性规则</a> - 任何较新版本中的包应该和旧版一样工作 - 所以依赖性需求只给出最低版本, 而不是最高版本或不兼容的更高版本的列表.</p><p>那么这四个操作的定义是:</p><ol><li>构建给定目标的构建列表: 使用目标本身启动列表, 然后追加每个需求的构建列表. 如果一个模块多次出现在列表中, 仅保留最新版本.</li><li>要将所有模块升级到最新版本: 构造构建列表, 但要读取每个需求(requirement), 就好像它请求了最新的模块版本一样.</li><li>要将一个模块升级到特定的较新版本: 构造未升级的构建列表, 然后添加新模块的构建列表. 如果一个模块多次出现在列表中, 仅保留最新版本.</li><li>要将一个模块降级到特定的旧版本: 倒回每个顶级需求的所需版本, 直到该需求的构建列表不再引用降级模块的较新版本.</li></ol><p>这些操作简单, 高效且易于实现.</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在我们更详细地测试最小版本选择之前, 让我们看看为什么需要新的方法. 在整篇文章中, 我们将使用以下一组模块作为运行示例:</p><p><a href="/static/images/version-select-1@2x.png" class="gallery-item"><img src="/static/images/version-select-1@2x.png" width="463px" height="272px"></a></p><p>该图显示了具有一个或多个版本的七个模块(虚线框)的模块需求图. 在语义版本控制之后, 给定模块的所有版本都共享一个主版本号. 我们正在开发模块 A 1, 我们将运行命令来更新其依赖性要求. 该图显示了 A 1 的当前需求和由各个版本的已发布模块 B 1 至 F 1 声明的需求.</p><p>因为主版本是模块标识符的一部分, 所以我们必须知道我们正在处理 A 1 而不是 A 2, 但是 A 的确切版本未指定 - 我们的工作未发布. 同样, 不同的主版本只是不同的模块: 就这些算法而言, B 1 与 B 2 的关系不如 C 1. 我们可以用 A 2 到 A 7 替代图中的 B1 到 F1, 但明显损失很大, 但对于算法如何处理这个例子没有任何改变. 由于示例中的所有模块都具有主版本 1, 因此从现在开始我们将尽可能省略主版本, 将 A 1 缩短为 A. 我们目前的 A 版本需要 B 1.2 和 C 1.2. B 1.2 依次要求 D 1.3. 早期版本 B 1.1 需要 D 1.1. 等等. 请注意, F 1.1 需要 G 1.1, 但 G 1.1 也需要 F 1.1. 当单个功能从一个模块移动到另一个时, 声明这种循环可能很重要. 我们的算法不能假定模块需求图是非循环的.</p><h3 id="低保真构建"><a href="#低保真构建" class="headerlink" title="低保真构建"></a>低保真构建</h3><p>Go 的当前版本选择算法很简单, 提供了两种不同的版本选择算法, 但都是不正确的.</p><p>第一种算法是 go get 的默认行为: 如果你有本地版本, 请使用该版本, 否则请下载并使用最新版本. 这种模式可以使用太旧的版本: 如果你已经安装了 B 1.1 并运行 go get 下载 A, 那么 go get 就不会更新到 B 1.2, 从而导致构建失败或有 bug 的构建.</p><p>第二种算法是 go get -u 的行为: 下载并使用所有包的最新版本. 此模式由于使用的版本太新而失败: 如果运行 go get -u 下载 A, 它将正确更新到 B 1.2, 但它也会更新到 C 1.3 和 E 1.3, 这不是 A 所需要的, 可能没有经过测试, 可能无法正常工作.</p><p>我将这些结果称为低保真构建: 被视为试图重现 A 的作者所使用的构建, 这些构建因没有理由而有所不同(译注: 此处不太好翻译). 在我们看到最小版本选择算法的细节后, 我们将看到它们为什么会生成高保真构建.</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>现在我们来看看更详细的算法.</p><h4 id="算法-1-构造构建列表"><a href="#算法-1-构造构建列表" class="headerlink" title="算法 1: 构造构建列表"></a>算法 1: 构造构建列表</h4><p>有两种有用的(和等价的)方法来定义构建列表的构造: 作为递归过程和图形遍历.</p><p>构建列表构造的递归定义如下. 通过启动一个空列表, 添加 M, 然后为 M 的每个需求附加构建列表, 构建 M 的粗略构建列表. 通过仅保留任何列出模块的最新版本, 简化粗略构建列表以生成最终构建列表.</p><p><a href="/static/images/version-select-list@2x.png" class="gallery-item"><img src="/static/images/version-select-list@2x.png" width="467px" height="278px"></a></p><p>构建列表的递归构造主要用作心理模型. 该定义的字面量实现效率太低, 可能需要非循环模块需求图的大小的时间指数, 并且在循环图上永远运行.</p><p>一个等效的, 更高效的构造基于图可达性. M 的粗略构建列表也仅仅是从 M 开始的后续箭头所需的所有模块的列表.<br>这可以通过对图的简单递归遍历来计算, 注意不要访问已经访问过的节点. 例如, A 的粗略构建列表是从 A 处开始并在高亮箭头后面找到的突出显示的模块版本.</p><p><a href="/static/images/version-select-2@2x.png" class="gallery-item"><img src="/static/images/version-select-2@2x.png" width="463px" height="272px"></a></p><p>(从粗略构建列表到最终构建列表的简化仍然相同)</p><p>注意, 这个算法只访问一次粗略构建列表中的每个模块, 由于只访问那些模块, 因此执行时间与粗略构建列表大小成正比 |B| , 加上必须遍历的箭头数(最多 |B|<sup>2</sup>). 该算法完全忽略粗略构建列表中的版本: 例如, 它加载关于 D 1.3, D 1.4 和 E 1.2 的信息, 但它不加载关于 D 1.2, E 1.1 或 E 1.3 的信息. 在依赖管理设置中, 加载关于每个模块版本的信息可能意味着单独的网络往返, 避免不必要的模块版本是一个重要的优化.</p><h4 id="算法2-升级所有模块"><a href="#算法2-升级所有模块" class="headerlink" title="算法2. 升级所有模块"></a>算法2. 升级所有模块</h4><p>升级所有模块可能是构建列表最常见的修改. 这是今天 get -u 所做的.</p><p>我们通过升级模块需求图并应用先前的算法来计算升级的构建列表. 升级后的模块需求图中指向模块的任何版本的每个箭头都被一个指向该模块的最新版本的指针取代. (也可以从图中丢弃所有旧版本, 但构建列表构造无论如何都不会查看它们, 因此不需要清理图.)</p><p>例如, 以下是升级后的模块需求图, 原始构建列表仍以黄色标记, 而升级的构建列表现在标记为红色:</p><p><a href="/static/images/version-select-3@2x.png" class="gallery-item"><img src="/static/images/version-select-3@2x.png" width="463px" height="272px"></a></p><p>虽然这告诉我们升级的构建列表, 但它还没有告诉我们如何使未来的构建使用构建列表而不是旧构建列表(仍以黄色标记).<br>为了升级图表, 我们改变了所有模块的需求. 但是模块 A 开发过程中的升级必须以某种方式记录在 A 的需求列表中(在 A 的 go.mod 文件中), 使算法 1 生成我们想要的构建列表, 挑选红色模块而不是黄色模块.<br>为了搞定什么添加到 A 的需求列表中可以达到这种效果, 我们引入了一个助手算法 R.</p><h4 id="算法-R-计算最小需求列表"><a href="#算法-R-计算最小需求列表" class="headerlink" title="算法 R. 计算最小需求列表"></a>算法 R. 计算最小需求列表</h4><p>给定一个与目标下面的模块需求图相兼容的构建列表, 我们想为目标计算一个需求列表, 以便产生该构建列表. 列出构建列表中除目标本身之外的每个模块总是足够的. 例如, 我们上面考虑的升级可以将 C 1.3 (替换 C 1.2), D 1.4, E 1.3, F 1.1 和 G 1.1 添加到 A 的需求列表中. 但总的来说, 并非所有这些添加都是必要的, 我们希望列出尽可能少的附加模块. 例如, F 1.1 意味着 G 1.1 (反之亦然), 所以我们不需要列出两者. 乍一看, 通过添加标记为红色但不是黄色的模块版本(在新列表中, 但从旧列表中缺失)开始似乎很自然. 那种启发法会错误地丢弃 D 1.4, 这是旧的需求 C 1.2 所暗示的, 而不是新的需求 C 1.3.</p><p>相反, 以反向后序访问模块是正确的, 也就是说, 只有在考虑到所有指向它的模块后才访问模块, 并且只有在模块没有被已访问的模块暗示的情况下才保留模块.</p><p>对于非循环图, 结果是唯一的, 最小的一组添加. 对于循环图, 反向后序遍历必须打破循环, 然后对于不参与循环的模块, 添加集是唯一且最小的. 只要结果是正确和稳定的, 我们就会在循环的情况下接受非最小的答案. 在本例中, 升级需要添加 C 1.3 (替换 C 1.2), D 1.4 和 E 1.3. 它可以丢弃 F 1.1 (由 C 1.3 暗示) 和 G 1.1 (也由 C 1.3 暗示).</p><h4 id="算法-3-升级一个模块"><a href="#算法-3-升级一个模块" class="headerlink" title="算法 3. 升级一个模块"></a>算法 3. 升级一个模块</h4><p>谨慎的开发人员通常只需升级一个模块, 而不必升级所有模块, 只需尽可能少地更改构建列表. 例如, 我们可能想要升级到 C 1.3, 并且我们不希望该操作进行不必要的更改, 例如升级到 E 1.3. 和算法 2 一样, 我们可以升级一个模块, 方法是升级需求图, 从中构造出一个构建列表(算法 1), 然后将该列表还原为顶层模块(算法 R)的一组需求. 为了升级需求图, 我们从顶层模块添加一个新箭头到升级后的模块版本.</p><p>例如, 如果我们想更改 A 的构建以升级到 C 1.3, 则此处为升级后的需求图:</p><p><a href="/static/images/version-select-4@2x.png" class="gallery-item"><img src="/static/images/version-select-4@2x.png" width="463px" height="272px"></a></p><p>像以前一样, 新的构建列表的模块被标记为红色, 而旧的构建列表是黄色.</p><p>升级对构建列表的影响是进行升级的唯一最低限度的方式, 增加了新的模块版本以及任何隐含的要求, 但没有其他要求. 请注意, 在构建升级后的图表时, 我们只能添加新箭头, 而不能替换或删除旧箭头. 例如, 如果从 A 到 C 1.3 的新箭头将旧箭头从 A 更换为 C 1.2, 则升级后的构建列表将省略 D 1.4. 也就是说, C 的升级会降级 D, 这是一个意外的, 不需要的和非最小的变化. 一旦我们计算了升级的构建列表, 我们就可以运行(上面的)算法 R 来决定如何更新需求列表.<br>在这种情况下, 我们最终会用 C 1.3 替换 C 1.2, 但是也会在 D 1.4 上添加一个新的需求, 以避免 D 的意外降级. 请注意, 该选择性升级只会将其他模块更新为 C 的最低需求: C 的升级不会简单地获取每个 C 的最新依赖项.</p><h4 id="算法-4-降级一个模块"><a href="#算法-4-降级一个模块" class="headerlink" title="算法 4. 降级一个模块"></a>算法 4. 降级一个模块</h4><p>我们也可能会在升级所有模块后发现, 最新的模块版本有问题, 这必须避免. 在这种情况下, 我们需要能够降级到早期版本的模块. 降级一个模块可能需要降级其他模块, 但我们希望降级尽可能少的其他模块. 像升级一样, 降级必须通过修改目标的需求列表对其进行更改. 与升级不同, 降级必须通过删除需求来实现, 而不是添加它们. 这个想法引出了一个非常简单的降级算法, 它可以单独考虑每个目标的需求. 如果需求与建议的降级不兼容(即, 如果需求的构建列表包含现在不允许的模块版本), 则依次尝试较早的版本, 直至找到与降级兼容的版本.</p><p>例如, 从原始构建图开始, 假设我们发现 D 1.4 存在问题, 实际上是在 D 1.3 中引入的, 因此我们决定降级到 D 1.2. 我们的目标模块 A 依赖于 B 1.2 和 C 1.2. 要从 D 1.4 降级到 D 1.2, 我们必须找到早期版本的 B 和 C, 它们不需要(直接或间接的)晚于 D 1.2 版本.</p><p>虽然我们可以分别考虑每个需求, 但将模块需求图作为一个整体来考虑会更高效. 在我们的例子中, 降级规则相当于删除 D 的不可用版本, 然后从不可用模块向后的箭头查找和删除其他不可用的模块. 最后, 剩下的 A 的需求的最新版本可以记录为新的需求.</p><p><a href="/static/images/version-select-5@2x.png" class="gallery-item"><img src="/static/images/version-select-5@2x.png" width="463px" height="272px"></a></p><p>在这种情况下, 降级到 D 1.2 意味着降级到 B 1.1 和 C 1.1. 为了避免不必要的降级到 E 1.1, 我们还必须在 E 1.2 上添加新的需求. 我们可以应用算法 R 来找到写入 go.mod 的最小需求集合.</p><p>请注意, 如果我们先升级到 C 1.3, 那么降级到 D 1.2 将继续使用 C 1.3, 它根本不使用任何版本的 D. 但降级仅限于降级软件包, 而不是升级软件包; 如果需要在降级前进行升级, 用户必须明确要求.</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>最小版本选择非常简单. 它通过消除关于答案是什么的所有灵活性来实现简单性: 构建列表正好是需求中指定的版本. 真正的系统需要更大的灵活性, 例如排除某些模块版本或替换其他模块的能力. 在我们添加之前, 值得研究当前系统简单性的理论基础, 因此我们要理解哪种扩展保留简单性, 哪些不必.</p><p>如果您熟悉大多数其他系统处理版本选择的方式, 或者你还记得我一年前发布的 <a href="https://research.swtch.com/version-sat" target="_blank" rel="noopener">Version SAT</a> 文章, 可能最小版本选择最显著的特征是它不能解决一般的布尔可满足性(Boolean satisfiability)或 SAT. 正如我在之前的文章中解释的那样, 版本搜索很少用于解决 SAT; 在这些系统中的版本搜索, 本质上是复杂的问题, 我们不知道这些问题是否有高效的解决方案. 如果我们想避免这种命运, 我们需知道边界在哪里, 在我们探索设计空间的时候, 哪里不该走. 方便地是, Schaefer 的二分法定理精确地描述了这些边界. 它确定了六个布尔公式的限制类, 其可满足性可以在多项式时间内确定, 然后证明对于超出这些类的任何一类公式, 可满足性是 NP 完备的. 为了避免 NP 完备性, 我们需要将版本选择问题限制在 Schaefer 的某一限制类中.</p><p>事实证明, 最小版本选择位于六个易处理的 SAT 子问题中的三个交集: 2-SAT, Horn-SAT 和 Dual-Horn-SAT. 与最小版本选择构建相对应的公式是一组子句的 AND, 其中每个子句都是单个正文本(此版本必须安装, 例如在升级期间), 单个负文本(此版本不可用, 例如在降级期间), 或者一个负面和一个正面文字的 OR (暗示: 如果安装了此版本, 则还必须安装此其他版本). 该公式是一个 2-CNF 公式, 因为每个子句至多有两个变量. 该公式也是一个 Horn 公式, 因为每个子句最多只有一个正文本. 该公式也是双重 Horn 公式, 因为每个子句最多只有一个负文本. 也就是说, 最小版本选择带来的每个可满足性问题都可以通过选择三种不同的高效算法来解决. 正如我们上面所做的那样, 利用这些问题的非常有限的结构来进一步专业化更加简单和高效.</p><p>虽然 2-SAT 是 SAT 子问题最有名的例子, 并且有一个有效的解决方案, 但这些问题都是 Horn 和双重 Horn 公式的事实更有趣. 每个 Horn 公式都有一个独特的令人满意的分配, 最少的变量设置为 true. 这证明了构造构建列表以及每次升级都有唯一的最小答案. 除非绝对必要, 否则独特的最小升级不会使用给定模块的较新版本. 相反, 每个双重 Horn 公式也具有独特的令人满意的分配, 其中最少的变量设置为 false. 这证明每个降级都有一个唯一的最小答案. 除非绝对必要, 否则独特的最低级别降级不会使用给定模块的较旧版本. 如果我们想扩展最小版本选择, 例如排除某些模块的能力, 我们只能通过继续使用可表示为 Horn 和双重 Horn公式的约束来保持唯一性和最小化属性.</p><p>(插一句: 最小版本选择解决的问题是 NL 完备问题: 因为 NL 是 2-SAT 的一个子集, 并且它是 NL-hard 问题, 因为 st-connectivity 可以简单地转换为最小版本选择构建列表构造问题. 令人愉快的是我们已经用一个 NL 完备问题取代了一个 NP 完备问题, 但是知道这一点几乎没有什么实际价值: NL 只保证一个多项式时间解, 而我们已经有一个线性时间解.</p><h3 id="排除模块"><a href="#排除模块" class="headerlink" title="排除模块"></a>排除模块</h3><p>最小版本选择始终选择满足构建总体要求的最小(最旧)模块版本. 如果该版本以某种方式出现问题, 则升级或降级操作可以修改顶级目标的需求列表以强制选择不同的版本.</p><p>明确记录该版本有问题也很有用, 以避免在将来的升级或降级操作中重新引入该版本. 但是我们希望以保持前一节的唯一性和最小性的方式来做到这一点, 所以我们必须使用 Horn 和双重 Horn公式的约束条件. 这意味着构建约束只能是无条件的肯定断言(必须安装 X:X), 无条件的否定断言(¬Y:Y 不能安装)和正面含义(X→Z, 等价于 X∨Z: 如果 X 已安装, 那么 Z 必须安装). 否定的含义(X→¬Y, 等同于 ¬X∨¬Y: 如果安装了 X, 那么 Y 不能安装)不能作为约束添加却不破坏表单. 因此模块排除必须是无条件的: 它们必须独立于构建列表构造期间的选择而决定.</p><p>我们可以做的是允许一个模块声明它自己的排除模块版本的本地列表. 就本地而言, 我的意思是仅在该模块内部建立该列表才被查阅; 将模块用作依赖的较大构建会忽略排除列表. 在我们的例子中, 如果 A 的构建参考了 D 1.3 的列表, 那么确切的排除集合将取决于构建是选择了 D 1.3 还是 D 1.4, 从而使排除条件变得有条件并导致 NP-完备 搜索问题. 只有顶层模块保证在构建中, 因此只使用顶层模块的排除列表. 请注意，只要在开始构建之前决定使用列表, 并且列表内容不依赖于哪些模块, 就可以参考其他来源的排除列表, 例如通过网络加载的全局排除列表在构建期间被选中.</p><p>尽管所有关注点都是无条件排除, 但似乎我们已经有有条件排除: C 1.2 需要 D 1.4, 因此暗含排除 D 1.3. 但是我们的算法不会将其视为排除. 当算法 1 运行时, 它将 D 1.3(对于 B)和 D 1.4(对于 C)都添加到粗略构建列表连同它们的最低要求. 只有 D 1.4 存在, 最终的简化过程才会删除 D 1.3. 这种声明不兼容性和声明最低要求之间的区别至关重要. 声明不得使用 D 1.3 构建 C 1.2, 只描述如何失败. 声明 C 1.2 必须用 D 1.4 构建, 而不是描述如何成功.</p><p>排除必须是无条件的. 知道这个事实很重要, 但它并没有告诉我们如何实施排除. 一个简单的答案是添加排除作为构建约束, 像 “D 1.3 不能安装” 这样的子句. 不幸的是, 单独添加该子句会导致需要 D 1.3 的模块(如 B 1.2)可以被卸载. 我们需要以某种方式表达 B 1.2 可以选择 D 1.4. 这样做的简单方法是修改构建约束, 将 “B 1.2 → D 1.3” 更改为 “B 1.2 → D 1.3 ∨ D 1.4”, 并且通常允许所有将来的 D 版本. 但是该条款(等同于 B 1.2 ∨ D 1.3 ∨ D 1.4) 有两个正面文字, 使整体构建公式不再是 Horn 公式. 它仍然是一个双重 Horn 公式, 所以我们仍然可以定义一个线性时间构建列表构造, 但是构造 - 也就是如何执行升级的问题 - 将不再保证具有唯一的, 最小的答案.</p><p>我们可以通过改变现有的约束来实现它们, 而不是将排除作为新的约束条件来实施. 也就是说, 我们可以修改需求图, 就像我们升级和降级一样. 如果一个特定的模块被排除, 那么我们可以将它从模块需求图中移除, 但也可以改变该模块上的任何现有需求, 以便用下一个更新的版本替代. 例如, 如果我们排除 D 1.3, 那么我们也会更新 B 1.2 以要求 D 1.4:</p><p><a href="/static/images/version-select-6@2x.png" class="gallery-item"><img src="/static/images/version-select-6@2x.png" width="463px" height="272px"></a></p><p>如果删除了最新版本的模块, 则需要删除任何需要该版本的模块, 如降级算法中所述. 例如, 如果 G 1.1 被移除, 那么 C 1.3 也需要被移除.</p><p>一旦排除已被应用到模块需求图中, 算法就像以前一样继续.</p><h3 id="更换模块"><a href="#更换模块" class="headerlink" title="更换模块"></a>更换模块</h3><p>在 A 的开发过程中, 假设我们在 D 1.4 中发现了一个 bug, 我们想测试一个潜在的修复. 我们需要一些方法来将我们的构建中的 D 1.4 替换为未发布的副本 U. 我们可以允许一个模块将其声明为替换: “就像 D 1.4 的源码和需求模块已经被 U 的替换了一样继续前行”.</p><p>和排除一样, 替换可以通过在预处理步骤中修改模块需求图来实现, 而不是通过增加处理图的算法复杂度来实现. 与排除一样, 替换列表对于一个模块也是本地的. A 的构建参考 A 的替换列表, 而不是来自 B 1.2, C 1.2 或构建中的任何其他模块的. 这避免了有条件的替换, 那将难以实现, 并且还避免了替换冲突的可能性: 如果 B 1.2 和 C 1.2 为 E 1.2 指定了不同的替换项, 该怎么办 ? 更一般地说, 保持一个模块的本地排除和替换限制了该模块对其他构建的控制.</p><h3 id="谁控制你的构建"><a href="#谁控制你的构建" class="headerlink" title="谁控制你的构建"></a>谁控制你的构建</h3><p>顶层模块的依赖关系必须对顶层构建进行一定的控制. B 1.2 需要能够确保它是用 D 1.3 或更高版本构建的, 而不是 D 1.2. 否则, 我们会结束当前的 go get 过时依赖失败模式.</p><p>同时, 为了使构建保持可预测性和可理解性, 我们不能依赖对顶级构建的任意细粒度控制. 这会导致冲突和意外. 例如, 假设 B 声明它需要 D 的偶数版本, 而 C 声明它需要 D 的素数版本. D 经常更新并且达到 D 1.99. 单独使用 B 或 C, 总是可以使用相对较新版本的 D (分别为 D 1.98 或 D 1.97). 但是当 A 同时使用 B 和 C 时, 构建会默默地选择更老的(并且更缓慢的) D 1.2. 这是一个极端的例子, 但它提出了一个问题: 为什么 B 和 C 的作者应该对 A 的构建有如此的极端控制 ? 在我写这篇文章时, 有一个<a href="https://github.com/kubernetes/client-go/issues/325" target="_blank" rel="noopener">开放的 bug 报告</a>, Kubernetes Go 客户端声明了一个需求, 它依赖于 gopkg.in/yaml.v2 两年前的一个特定版本. 当开发人员尝试在已使用 Kubernetes Go 客户端的程序中使用该 YAML 库的新功能时, 即使尝试升级到最新的可能版本后, 使用新功能的代码仍无法编译, 因为 “latest” 受限于 Kubernetes 的需求. 在这种情况下, 使用两年前的 YAML 库版本在 Kubernetes 代码库的背景下可能是完全合理的. 显然 Kubernetes 作者应该完全控制自己的构建, 但是这种控制级别扩展到其他开发人员的构建没有任何意义.</p><p>在模块需求, 排除和替换的设计中, 我试图平衡允许依赖足够控制的竞争关注, 以确保成功构建, 而不允许他们进行太多控制, 从而损害构建. 最低需求的结合没有冲突, 所以从所有依赖中收集它们是可行的(甚至容易的). 但排除和替换可以并且会发生冲突, 所以我们只允许它们由顶层模块指定.</p><p>因此, 模块作者完全控制了该模块的构建, 因为它是正在构建的主要程序, 但不能完全控制依赖于模块的其他用户的构建. 我相信对于比现有系统更大, 更分散的代码库来说, 这种区别将使版本选择规模最小化.</p><h3 id="高保真构建"><a href="#高保真构建" class="headerlink" title="高保真构建"></a>高保真构建</h3><p>现在回到高保真构建的问题.</p><p>在文章的开头, 我们看到, 使用 go get 构建 A, 可以使用不同于 A 的作者所使用的依赖, 没有一个很好的理由. 我把它称为低保真构建, 因为它是 A 的原始构建的较差再现. 使用最小版本选择, 构建是高保真的. 模块的源代码中包含的模块需求唯一确定了如何直接构建它. 用户构建的 A 将完全匹配作者的构建: 可复制构建. 但高保真意味着更多.</p><p>可复制构建通常被理解为整个程序构建的二元属性: 用户的构建与作者完全相同, 或者不相同. 在构建一个库模块作为大型程序的一部分时呢 ? 用户构建一个库与作者的构建尽可能匹配时很有帮助的. 然后用户运行作者开发和测试的相同代码(包括依赖). 当然, 在一个更大的项目中, 用户构建一个库可能无法完全匹配作者的构建. 该构建的另一部分可能会强制使用更新的依赖, 从而使用户的库构建偏离作者的构建. 当只是为了满足构建中其他地方的需求时, 构建偏离了作者自己的构建, 我们将构建称为高保真的构建.</p><p>再考虑一下我们最初的例子:</p><p><a href="/static/images/version-select-1@2x.png" class="gallery-item"><img src="/static/images/version-select-1@2x.png" width="463px" height="272px"></a></p><p>在这个例子中, 虽然 B 的作者使用 D 1.3, 但 A 的内部结合了 B 1.2 和 D 1.4. 这种改变是必要的, 因为 A 也使用 C 1.2, 而它需要 D 1.4. A 的构建仍然是 B 1.2 的高保真构建: 它通过使用 D 1.4 而偏离, 但仅仅因为那是必须的. 相反, 如果构建使用 E 1.3, 如 get -u, Dep 和 Cargo 通常所做的那样, 构建将会是低保真构建: 因为它是不必要地偏离的.</p><p>最小版本选择通过使用满足需求的最旧版本来提供高保真构建. 新版本的发布对构建没有影响. 相比之下, 包括 Cargo 和 Dep 在内的大多数其他系统使用可用的最新版本, 以满足 “manifest file” 中列出的需求. 新版本的发布会更改其构建决策. 为了获得可复制的构建, 这些系统添加了第二种机制, 即 “lock file”, 它列出了构建应该使用的特定版本. 锁定文件确保了整个程序的可复制构建, 但是对于库模块它却被忽略; <a href="http://doc.crates.io/faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries" target="_blank" rel="noopener">Cargo FAQ</a> 解释说这是 “这正是因为库不应该被它的所有用户进行确定性的重新编译”. 确实, 完美的复制并不总是可能的, 但通过完全放弃, Cargo 方案承认不必要的偏离库作者的构建. 也就是说, 它提供了低保真构建. 在我们的例子中, 当 A 首先将 B 1.2 或 C 1.2 添加到其构建中时, Cargo 会看到它们需要 E 1.2 或更高版本, 并且会选择 E 1.3. 然而, 直到另外指示, 作为 B 和 C 的作者, 继续用 E 1.2 构建它似乎更好. 使用最旧的允许版本还消除了具有两个不同文件(manifest 和 lock)的冗余, 这两个文件都指定要使用哪些模块版本.</p><p>自动使用较新的版本也使得最低需求容易出错. 假设我们开始使用当时的最新版本 B 1.1 开发 A, 并且我们记录 A 仅需要 B 1.1. 但是然后 B 1.2 出来了, 我们开始在我们自己的构建和 lock 文件中使用它, 而不更新 manifest. 这时, 不再有 A 和 B 1.1 的任何开发或测试. 我们可能会开始使用 B 1.2 中的新功能或依赖它的错误修复, 但现在 A 错误地将其最低需求列为 B 1.1. 如果用户总是选择比最低需求更新的版本, 那么没有太大的伤害: 他们也会使用 B 1.2. 但是当系统确实尝试使用声明的最小版本时, 它将会出错. 例如, 当用户尝试对 A 进行有限更新时, 系统无法看到对 B 1.2 的更新也是必需的. 更一般地说, 每当最低版本(manifest 中)和构建版本(lock 中)不同时, 为什么我们认为使用最低版本构建将生成可用的库 ? 为了试图检测这个问题, <a href="https://github.com/rust-lang/cargo/issues/4100" target="_blank" rel="noopener">Cargo 开发者已经建议</a>在发布前使用 cargo publish 尝试使用最低版本的所有依赖进行构建. 当 A 开始使用 B 1.2 中的新功能时, 它会检测到使用 B.1.1 构建将失败 - 但它不会检测 A 何时开始依赖于新的错误修复.</p><p>根本的问题是, 在版本选择期间选择最新允许版本的模块会产生低保真构建. 针对整个程序构建, Lock 文件是部分解决方案; 像 cargo publish 这样的额外构建检查也是部分解决方案. 更完整的解决方案是使用作者所用的模块版本构建. 这使得用户的构建尽可能接近作者的构建: 高保真构建.</p><h3 id="升级速度"><a href="#升级速度" class="headerlink" title="升级速度"></a>升级速度</h3><p>鉴于最小版本选择采用了每个依赖项的最小允许版本, 很容易认为这会导致使用很旧的软件包副本, 进而可能导致不必要的错误或安全问题. 不过, 在实践中, 我认为情况正好相反, 因为允许的最小版本是所有约束中最大的一个, 因此, 对构建中的所有模块提供的一个控制杠杆是强制使用较新版本的依赖项的能力, 而不是使用该版本. 我希望最小版本选择的用户最终会得到一些程序, 这些程序几乎和他们的朋友一样, 都是使用像 Cargo 这样更有侵略性的系统的最新版本.</p><p>例如, 假设您正在编写一个依赖于少数其他模块的程序, 所有这些模块都依赖于一些非常常见的模块, 比如 gopkg.in/yaml.v2. 你的程序的构建将使用你的模块所请求的最新的 YAML 版本, 以及少量的依赖项. 即使只有一个依赖项, 也会迫使你的构建更新许多其他依赖项. 这与我前面提到的 Kubernetes Go 客户端问题正好相反.</p><p>如果有什么区别的话, 最小版本选择反而会遇到相反的问题, 即这个 “最小值的最大值” 答案就像一个棘轮, 迫使依赖关系向前过快. 但我认为, 在实践中, 依赖性将以正确的速度向前推进, 最终的结果是, 其速度恰好比 Cargo 和它的同伴们的速度要慢一些.</p><h3 id="升级时间"><a href="#升级时间" class="headerlink" title="升级时间"></a>升级时间</h3><p>最小版本选择的一个关键特性是在开发人员要求升级之前不会发生. 你不会得到一个未经测试的模块版本, 除非你要求升级该模块.</p><p>例如, 在 Cargo 中, 如果包 B 依赖于包 C 2.9, 并且将 B 添加到你的构建中, 那么你就不能获得 C 2.9. 你在那一刻得到了最新的允许版本, 也许是 C 2.15. 也许 C 2.15 在几分钟前才发布, 而作者还没有被告知一个重要的错误.<br>这对你和你的构建来说太糟糕了. 另一方面, 在最小版本选择中, 模块 B 的 go.mod 文件将列出 B 的作者所开发和测试的 C 的确切版本. 你会得到那个版本的. 或者, 你的程序中的其他模块使用较新版本的 C 进行了开发和测试. 然后你会得到那个版本. 但是你永远不会得到程序中的某个模块在 go.mod 文件中没有明确要求的 C 的版本. 这意味着你只能得到一个为别人工作的 C 的版本, 而不是最近的版本, 可能没有为任何人工作过.</p><p>明确地说, 我这里的目的不是挑剔 Cargo, 我认为它是一个设计得很好的系统. 我在这里使用 Cargo 作为许多开发人员都熟悉的模型的一个示例, 来尝试传达在最小版本选择中会有什么不同.</p><h3 id="最小化"><a href="#最小化" class="headerlink" title="最小化"></a>最小化</h3><p>我将此系统最小版本选择称为系统最小版本选择, 因为整个系统看起来是最小的: 我不知道如何删除任何内容而不破坏它. 毫无疑问, 有些人会说, 太多的已经被删除了, 但到目前为止，它似乎完全能够处理我已经检查过的现实世界的案例. 我们将通过对 vgo 原型进行试验来发现更多的问题.</p><p>最小版本选择的关键是它对模块的最小允许版本的偏好. 当我将 go get-u 的 “将所有东西升级到最新的” 方法, 应用于能够依赖导入兼容性规则的系统中时, 我意识到 manifest 和 lock 的存在都是为了相同的目的: 解决 “将所有东西升级到最新的” 默认行为. manifest 描述哪些新版本是不需要的, 而 lock 描述哪些新版本是不想要的. 相反, 为什么不更改默认值呢 ? 使用允许的最小版本, 通常是作者使用的准确版本, 并将升级的时间完全留给用户控制. 这种方法导致在没有 lock 文件的情况下可复制的构建, 更一般的情况下, 产生了只在需要时才偏离作者自己的构建的高保真版本.</p><p>最重要的是, 我想找到一个可理解的, 可预测的, 甚至于无聊的版本选择算法. 其他系统似乎为展现原始灵活性和强大进行了优化, 最小版本选择的目标是无形的. 我希望它成功.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
            <tag> vgo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>语义导入版本控制</title>
      <link href="/post/vgo-import.html"/>
      <url>/post/vgo-import.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自 <a href="https://research.swtch.com/vgo-import" target="_blank" rel="noopener">Semantic Import Versioning</a>, <a href="https://lingchao.xin/tag/vgo.html">Go &amp; Versioning</a> 的第 3 部分, 版权@归原文所有.<br><a id="more"></a><p></p><p>如何将不兼容的更改部署到现有软件包 ? 这是任何包管理系统中的根本挑战和决断. 问题的答案决定了所产生的系统的复杂性, 它决定了如何轻松或难以使用包管理. (它还决定如何轻松或难以实现包管理, 但用户体验更重要.)</p><p>为了回答这个问题, 这篇文章首先介绍了 Go 的导入兼容性规则:</p><blockquote><p>如果旧包和新包具有相同的导入路径, 新软件包必须向后兼容旧软件包.</p></blockquote><p>我们从 Go 一开始就主张这个原则, 但我们没有给它一个名字或者这样一个直接的陈述.</p><p>导入兼容性规则大大简化了使用不兼容版本的软件包的体验. 当每个不同版本具有不同的导入路径时, 关于给定导入语句的预期语义没有歧义. 这使开发人员和工具更容易理解 Go 程序.</p><p>今天的开发人员希望使用语义版本来描述软件包, 因此我们将它们应用到模型中. 具体来说, 模块 my/thing 被导入成 my/thing 作为 v0, 该阶段预计会发生破坏性更改, 并且不会受到保护, 并且持续到第一个稳定的主要版本 V1. 但是当添加 v2 的时候, 我们不再重新定义现在稳定的 my/thing 的所代表的含义, 而是给它一个新的名字: my/thing/v2.</p><p><a href="/static/images/impver@2x.png" class="gallery-item"><img src="/static/images/impver@2x.png" width="458px" height="223px"></a></p><p>我将这种约定称为语义导入版本控制, 这是在使用语义版本控制时遵循导入兼容性规则的结果.</p><p>一年前, 我相信把版本放入这样的导入路径是丑陋的, 不可取的, 并且可能是可以避免的. 但是在过去的一年里, 我已经开始理解它们为系统带来多少清晰和简单. 在这篇文章中, 我希望能让你了解我为什么改变主意.</p><h3 id="一个依赖的故事"><a href="#一个依赖的故事" class="headerlink" title="一个依赖的故事"></a>一个依赖的故事</h3><p>为了使讨论具体化, 请考虑以下故事. 这个故事当然是虚构的, 但它是由一个真正的问题所驱动. 当 dep 发布时, Google 编写 OAuth2 软件包的团队问我, 他们应该如何引入他们长期以来都想做的一些不兼容的改进. 我越想它, 越是意识到这不像听起来的那么容易, 至少不像没有语义导入版本的那样.</p><h4 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h4><p>从包管理工具的角度来看, 分为代码作者和代码用户. Alice, Anna 和 Amy 是不同代码包的作者. Alice 在 Google 工作并编写 OAuth2 软件包. Amy 在微软工作并编写了 Azure 客户端库. Anna 在亚马逊工作并撰写了 AWS 客户端库. Ugo 是所有这些软件包的用户. 他正在开发最终的云应用 Unity, 并使用所有这些软件包和其他软件包.</p><p>作为作者, Alice, Anna 和 Amy 需要能够编写和发布他们软件包的新版本. 软件包的每个版本都为其每个依赖项指定了所需的版本.</p><p>作为用户, Ugo 需要能够用这些其他软件包一起构建 Unity. 他需要精确控制在特定构建中使用哪些版本; 当他选择时他需要能够更新到新版本.</p><p>当然, 我们的朋友可能期望从包管理工具中获得更多, 特别是在发现, 测试, 可移植性和有用的诊断方面, 但这些与故事无关.</p><p>随着我们的故事逐渐打开, Ugo 的 Unity 构建依赖关系看起来像这样:</p><p><a href="/static/images/deps-a1-short2@2x.png" class="gallery-item"><img src="/static/images/deps-a1-short2@2x.png" width="550px" height="351px"></a></p><h4 id="章节-1"><a href="#章节-1" class="headerlink" title="章节 1"></a>章节 1</h4><p>每个人都独立编写软件.</p><p>在谷歌, Alice 一直在为 OAuth2 软件包设计一个新的, 更简单, 更易于使用的 API. 它仍然可以完成旧软件包可以完成的所有工作, 但只需要一半的 API 接口. 她将其发布为 OAuth2 r2. (这里的 r 代表修订. 目前, 修订号并不表示除顺序之外的任何内容: 特别是, 它们不是语义版本)</p><p>在微软, Amy 正处于应有的长假期中, 她的团队决定在她回来之前不做任何与 OAuth2 r2 相关的更改. Azure 包现在将继续使用 OAuth2 r1.</p><p>在亚马逊, Anna 发现使用 OAuth2 r2 可以让她在实现 AWS r1 的过程中删除许多难看的代码, 因此她将 AWS 更改为使用 OAuth2 r2. 她一路修复了一些错误, 并将结果发布为 AWS r2.</p><p>Ugo 获取了有关 Azure 行为的 bug 报告, 并追踪到 Azure 客户端库的一个 bug. 在休假之前, Amy 已经在 Azure r2 中发布了该 bug 的修复程序. Ugo 向 Unity 添加了一个测试用例, 确认它失败, 并要求包管理工具更新到 Azure r2.</p><p>更新之后, Ugo 的构建看起来像这样:</p><p><a href="/static/images/deps-a1.5@2x.png" class="gallery-item"><img src="/static/images/deps-a1.5@2x.png" width="550px" height="427px"></a></p><p>他确认新的测试通过, 并且他所有的旧测试仍然通过. 他锁定 Azure 更新并发布更新后的 Unity.</p><h4 id="章节-2"><a href="#章节-2" class="headerlink" title="章节 2"></a>章节 2</h4><p>Amazon 大张旗鼓地推出了他们新的云服务: Amazon Zeta Functions. 为了准备发布, Anna 给 AWS 软件包添加了 Zeta 支持, 她现在将它发布为 AWS r3.</p><p>当 Ugo 听到有关 Amazon Zeta 的消息时, 他写了一些测试程序, 并对他们工作的效果感到非常兴奋, 因此他跳过午餐更新去 Unity. 今天的更新不如最后一次. Ugo 希望使用 Azure r2 和 AWS r3 (每个版本的最新版本)来构建包含 Zeta 支持的 Unity. 但  Azure r2 需要 OAuth2 r1 (而不是 r2 ), 而 AWS r3 需要 OAuth2 r2 (而不是 r1). 经典的菱形依赖, 对吧? Ugo 不在乎它是什么. 他只是想构建 Unity.</p><p>更糟的是, 这似乎不是任何人的错. Alice 写了一个更好的 OAuth2 包. Amy 修复了一些 Azure bug 并去度假. Anna 觉得 AWS 应该使用新的 OAuth2 (内部实现细节), 并且后来增加了 Zeta 支持. Ugo 希望 Unity 使用最新的 Azure 和 AWS 软件包. 很难说他们中的任何一个做错了什么. 如果这些人没有错, 那么也许包管理错了. 我们一直假设在 Ugo 的 Unity 构建中只能有一个版本的 OAuth2. 也许这就是问题所在: 也许包管理器应该允许在单个构建中包含不同的版本. 这个例子似乎表明它必须这样.</p><p>Ugo 仍然卡住了, 所以他搜索了 StackOverflow 并找到了包管理器的 -fmultiverse标志, 它允许多个版本, 以便他的程序构建为:</p><p><a href="/static/images/deps-a2-short@2x.png" class="gallery-item"><img src="/static/images/deps-a2-short@2x.png" width="550px" height="351px"></a></p><p>Ugo 试了. 它不起作用. 进一步深入研究这个问题, Ugo 发现 Azure 和 AWS 都在使用名为 Moauth 的流行 OAuth2 中间件库, 它简化了部分 OAuth2 处理. Moauth 不是一个完整的 API 替代品: 用户仍然直接导入 OAuth2, 但他们使用 Moauth 来简化一些 API 调用. Moauth 参与的细节没有从 OAuth2 r1 改为 r2, 因此 Moauth r1 (唯一存在的版本)与两者兼容. Azure r2 和 AWS r3 都使用 Moauth r1. 在仅使用 Azure 或仅使用 AWS 的程序中, 这种方式效果很好, 但 Ugo 的 Unity 构建看起来像这样:</p><p><a href="/static/images/deps-a3-short@2x.png" class="gallery-item"><img src="/static/images/deps-a3-short@2x.png" width="550px" height="454px"></a></p><p>Unity 需要两个 OAuth2 拷贝, 但 Moauth 导入哪个拷贝 ?</p><p>为了使构建工作, 我们似乎需要两个完全相同的Moauth副本: 一个导入 OAuth2 r1 供 Azure 使用, 另一个导入 OAuth2 r2 供 AWS 使用. 一个快速的 StackOverflow 搜索显示软件包管理器有一个标志(flag): -fclone. Ugo 的程序使用这个标志来构建为:</p><p><a href="/static/images/deps-a4-short@2x.png" class="gallery-item"><img src="/static/images/deps-a4-short@2x.png" width="550px" height="451px"></a></p><p>这实际上可以工作并通过了测试, 虽然 Ugo 现在想知道是否还有更多的潜在问题. 他需要回家吃晚饭.</p><h4 id="章节-3"><a href="#章节-3" class="headerlink" title="章节 3"></a>章节 3</h4><p>Amy 已经结束度假回到了微软. 她觉得 Azure 可以继续使用 OAuth2 r1 一段时间, 但她意识到它可以帮助用户直接传递 Moauth 令牌到 Azure API. 她以向后兼容的方式将其添加到 Azure 包中, 并发布 Azure r3. 在亚马逊这边, Anna 喜欢 Azure 包基于 Moauth 的新 API, 并向 AWS 包添加了类似的 API, 发布为 AWS r4.</p><p>Ugo 看到了这些变化, 并决定更新到最新版本的 Azure 和 AWS, 以便使用基于 Moauth 的 API. 这次卡了他一个下午. 首先他暂时更新 Azure 和 AWS 包, 而不修改 Unity. 它的程序可以构建!</p><p>令人兴奋的是, Ugo 将 Unity 改变为使用基于 Moauth 的 Azure API, 而且也可以构建. 但是, 当他将 Unity 更改为使用基于 Moauth 的 AWS API 时, 构建失败. 困惑的是, 他恢复了他的 Azure 更改, 只留下 AWS 更改, 构建成功. 他将 Azure 更改放回, 构建再次失败. Ugo 返回到 StackOverflow (继续搜索).</p><p>Ugo 了解到, 当通过 -fmultiverse -fclone 仅使用一个基于 Moauth 的 API (在本例中为 Azure) 时, Unity 隐式地构建为:</p><p><a href="/static/images/deps-a5-short@2x.png" class="gallery-item"><img src="/static/images/deps-a5-short@2x.png" width="596px" height="451px"></a></p><p>但是当他使用两个基于 Moauth 的 API 时, Unity 中的单个导入 “moauth” 是不明确的. 由于 Unity 是主要的软件包, 它不能被克隆(与 Moauth 本身相反):</p><p><a href="/static/images/deps-a6-short@2x.png" class="gallery-item"><img src="/static/images/deps-a6-short@2x.png" width="628px" height="451px"></a></p><p>一个 StackOverflow 评论建议将 Moauth 导入移动到两个不同的包中, 然后让 Unity 导入它们. Ugo 尝试了这一点, 令人难以置信的是, 它可以工作:</p><p><a href="/static/images/deps-a7-short@2x.png" class="gallery-item"><img src="/static/images/deps-a7-short@2x.png" width="561px" height="601px"></a></p><p>Ugo 按时回了家. 他对包管理并不满意, 但他现在是 StackOverflow 的忠实粉丝.</p><h3 id="基于语义版本的复述"><a href="#基于语义版本的复述" class="headerlink" title="基于语义版本的复述"></a>基于语义版本的复述</h3><p>假设包管理使用它们而不是原始故事的 ‘r’ 数字, 让我们挥动一把魔杖并用语义版本复述故事.</p><p>以下是一些变化:</p><ul><li>OAuth2 r1 变为 OAuth2 1.0.0</li><li>Moauth r1 变为 Moauth 1.0.0</li><li>Azure r1 变为 Azure 1.0.0</li><li>AWS r1 变为 AWS 1.0.0</li><li>OAuth2 r2 变为 OAuth2 2.0.0 (部分不兼容的 API)</li><li>Azure r2 变为 Azure 1.0.1 (bug 修复)</li><li>AWS r2 变为 AWS 1.0.1 (bug 修复, 内部使用 OAuth2 2.0.0)</li><li>AWS r3 变为 AWS 1.1.0 (功能更新: 添加 Zeta)</li><li>Azure r3 变为 Azure 1.1.0 (功能更新: 添加 Moauth API)</li><li>AWS r4 变为 AWS 1.2.0 (功能更新: 添加 Moauth API)</li></ul><p><strong>故事没有任何变化</strong>. Ugo 仍然遇到相同的构建问题, 他仍然不得不转向使用 StackOverflow 来了解构建标志(flag)和重构技术, 以保持 Unity 成功构建. 根据 semver, Ugo 应该没有任何更新的麻烦: 在故事中没有一个 Unity 导入的包改变了主要版本. 只有 OAuth2 深入 Unity 的依赖树. Unity 本身不会导入 OAuth2. 什么地方出了错 ?</p><p>这里的问题是, semver 规范实际上不仅仅是选择和比较版本字符串的方式. 它没有说别的. 特别是, 在增加主版本号后, 如何处理不兼容的更改也没有提及.</p><p>semver 最有价值的部分是鼓励在可能的情况下进行向后兼容的更改. FAQ 正确的记录到:</p><blockquote><p>“不兼容的更改不应该轻微引入具有大量相关代码的软件. 升级必须承担的成本可能很大. 不得不通过增加主版本号来发布不兼容的更改意味着你将会考虑更改的影响并评估涉及的成本/收益率.”</p></blockquote><p>我当然同意 “不应该轻易引入不兼容的变化”. 我认为 semver 缺乏的地方是: “不得不通过增加主版本号” 是促使你 “思考你更改的影响并评估涉及的 成本/收益 率” 的一个步骤. 恰恰相反: 读取 semver 太容易了, 因为这意味着只要你在进行不兼容的更改时递增主版本, 其他所有操作都可以解决. 这个例子表明情况并非如此.</p><p>从 Alice 的角度来看, OAuth2 API 需要向后兼容的变更, 并且当她做出这些更改时, semver 似乎承诺发布不兼容的 OAuth2 软件包会很好, 前提是她给了它 2.0.0 版本. 但是这种经过 semver 认可的改变引发了 Ugo 和 Unity 的一系列问题.</p><p>语义版本是作者向用户传达期望的重要方式, 但这就是他们的全部. 就其本身而言, 不能期望解决这些较大的构建问题. 相反, 让我们看看解决构建问题的方法. 之后, 我们可以考虑如何在这种方法中恰当的使用 semver.</p><h3 id="导入版本控制复述"><a href="#导入版本控制复述" class="headerlink" title="导入版本控制复述"></a>导入版本控制复述</h3><p>再一次, 让我们使用导入兼容性规则重新讲述故事:</p><blockquote><p>在 Go 中, 如果旧包和新包具有相同的导入路径, 新软件包必须向后兼容旧软件包.</p></blockquote><p>现在情节变化更加显著. 故事以同样的方式开始, 但在第 1 章中, 当 Alice 决定创建一个部分不兼容的新 OAuth2 API 时, 她不能使用 “oauth2” 作为其导入路径. 相反, 她将新版本命名为 Pocoauth, 并为其提供导入路径 “pocoauth”.</p><p>面对两个不同的 OAuth2 软件包, Moe (Moauth 的作者) 必须为 Pocoauth 编写第二个软件包 Moauth, 他命名为 Pocomoauth 并给出了导入路径 “pocomoauth”.</p><p>当 Anna 将 AWS 软件包更新为新的 OAuth2 API 时, 她还将该代码中的导入路径从 “oauth2” 更改为 “pocoauth”, 并将 “moauth” 中的导入路径更改为 “pocomoauth”. 然后, 随着 AWS r2 和 AWS r3 的发布, 故事会继续进行.</p><p>在第 2 章中, 当 Ugo 热切地采用 Amazon Zeta 时, 一切正常. 所有软件包代码中的导入都完全匹配需要构建的代码. 他不必在 StackOverflow 上查找特殊标志(flag), 而且他午餐仅仅晚了五分钟.</p><p><a href="/static/images/deps-b1-short@2x.png" class="gallery-item"><img src="/static/images/deps-b1-short@2x.png" width="550px" height="517px"></a></p><p>在第 3 章中, Amy 将基于 Moauth 的 API 添加到 Azure, 而 Anna 则将相同的基于 Pocomoauth 的 API 添加到 AWS.</p><p>当 Ugo 决定更新 Azure 和 AWS 时, 再次没有问题. 他更新的程序不需要任何特殊的重构:</p><p><a href="/static/images/deps-b2-short@2x.png" class="gallery-item"><img src="/static/images/deps-b2-short@2x.png" width="550px" height="467px"></a></p><p>在这个故事版本的末尾, Ugo 甚至都没有想到他的包管理器. 它正常工作; 他几乎没有注意到它在那里.</p><p>与故事的语义版本翻译相比, 这里使用导入版本化改变了两个关键细节. 首先, 当 Alice 介绍了她向后兼容的 OAuth2 API 时, 她不得不将其作为一个新包发布 (Pocoauth). 其次, 由于 Moe 的封装包 Moauth 在其 API 中公开了 OAuth2 包的类型定义, Alice 发布了一个新包迫使 Moe 也发布了一个新包 (Pocomoauth). Ugo 最终的 Unity 构建进展顺利, 因为 Alice 和 Moe 的软件包拆分创建保持了 Unity 等客户端构建和运行所需的结构. 取而代之的是, Ugo 和像他一样的用户不再需要诸如 -fmultiverse -fclone 这样外来重构辅助的不完整包管理的复杂性, 导入兼容性规则将少量额外的工作推给包作者, 从而让所有用户收益.</p><p>需要为每个向后不兼容的 API 更改引入一个新名称肯定会有成本, 但正如 semver FAQ 所述, 该成本应鼓励作者更清楚地考虑这些变化的影响以及它们是否真的有必要. 而在导入版本控制的情况下, 成本会为用户带来显著的收益.</p><p>导入版本控制 (Import Versioning) 的一个优点是程序包名称和导入路径是 Go 开发人员能很好理解的概念. 如果你告诉一个包作者, 做出向后不兼容的更改需要创建具有不同导入路径的不同包, 那么 - 即便没有任何版本控制的知识 - 作者可以通过对客户端包的影响推理: 客户端需要更改他们的导入一次; Moauth 不再适用于新的软件包, 等等.</p><p>能够更清楚地预测对用户的影响, 作者可能会对他们的变化做出不同的, 更好的决策. Alice 可能会寻求将新的更清晰的 API 与现有 API 一起引入最初的 OAuth2 包中, 以避免包拆分. Moe 可能会更仔细地考虑是否可以使用接口来使 Moauth 支持 OAuth2 和 Pocoauth, 从而避免使用新的 Pocomoauth 包. Amy 可能会认为更新到 Pocoauth 和 Pocomoauth 是值得的, 而不是暴露 Azure API 使用过时的 OAuth2 和 Moauth 包的事实. Anna 可能会尝试让 AWS API 允许 Moauth 或 Pocomoauth 使 Azure 用户更容易切换.</p><p>相比之下, semver “主版本升级 (bump)” 的含义远不是那么清晰, 并且不会对作者施加同样的设计压力. 需要清楚的是, 这种方法为作者创造了更多的工作, 但通过为用户带来显著的好处, 这项工作是合理的. 总的来说, 这种权衡是有道理的, 因为软件包的目标是拥有比作者更多的用户, 并且希望所有软件包至少拥有与作者一样多的用户.</p><h3 id="语义导入版本控制"><a href="#语义导入版本控制" class="headerlink" title="语义导入版本控制"></a>语义导入版本控制</h3><p>上一节展示了在更新期间, 导入版本如何带来简单, 可预测的构建. 但是, 在每次向后兼容的更改中选择一个新名字对用户来说都很困难并且没有任何帮助. 鉴于 OAuth2 和 Pocoauth 之间的选择, Amy 应该使用哪个 ? 没有进一步调查, 就没有办法知道. 相比之下, 语义版本化使得这很容易: OAuth2 2.0.0 显然是 OAuth2 1.0.0 的预期替代品.</p><p>我们可以使用语义版本控制, 并通过在导入路径中包含主版本来遵循导入兼容性规则. Alice 可以用新的导入路径 “oauth2/v2” 调用她新的 API OAuth2 2.0.0, 而不需要创建一个可爱但不相关的新名称 Pocoauth. Moe 也一样: Moauth 2.0.0 (导入为 “moauth/v2” ) 也可以成为 OAuth2 2.0.0 的辅助包, 就像 Moauth 1.0.0 是 OAuth2 1.0.0 的辅助包一样.</p><p>当 Ugo 在第  2章中添加 Zeta 支持时, 他的构建看起来像这样:</p><p><a href="/static/images/deps-c1-short@2x.png" class="gallery-item"><img src="/static/images/deps-c1-short@2x.png" width="567px" height="467px"></a></p><p>因为 “moauth” 和 “moauth/v2” 只是不同的软件包, 所以 Ugo 完全清楚他需要如何使用 Azure 的 “moauth” 以及使用 AWS 的 “moauth/v2”: 导入两者.</p><p><a href="/static/images/deps-c2-short@2x.png" class="gallery-item"><img src="/static/images/deps-c2-short@2x.png" width="550px" height="467px"></a></p><p>为了兼容现有的 Go 用法, 并作为不做向后不兼容的 API 更改的小鼓励, 我在此假定主要版本 1 从导入路径中省略: import “moauth”, 而不是 “moauth/v1”. 同样, 主要版本 0 明确拒绝兼容性, 也从导入路径中省略. 这里的想法是, 通过使用 v0 依赖关系, 用户明确承认破坏的可能性并在选择更新时承担处理它的责任. (当然, 更新不会自动发生是很重要的. 我们将在下一篇文章中看到如何最小化版本选择对此有所帮助.)</p><h3 id="功能性名称和不可变的含义"><a href="#功能性名称和不可变的含义" class="headerlink" title="功能性名称和不可变的含义"></a>功能性名称和不可变的含义</h3><p>二十年前, Rob Pike 和我正在修改 Plan 9 C 库的内部结构, Rob 教会了我这样一个经验法则, 当你改变一个函数的行为时, 你也改变它的名字. 旧的名字有一个含义. 通过对新名称使用不同的含义并删除旧名称, 我们确保编译器会大声抱怨需要检查和更新的每段代码, 而不是静静地编译不正确的代码. 如果人们有他们自己的程序在使用这个函数, 他们会得到编译时失败, 而不是长时间的调试会话. 在当今分布式版本控制的世界中, 最后一个问题被放大了, 这使得名称变得更加重要. 并发编写的旧代码所期望的旧的语义不应该在合并的时候被新的语义替代.</p><p>当然, 删除旧函数只有在可以找到所有用到它的地方, 或者当用户了解他们有责任跟上变化时才会起作用, 例如在 Plan 9 等研究系统中. 对于导出的 API, 通常会更好地保留旧名称和旧行为, 并只添加新行为的新名称. Rich Hickey 在 2016 年的 “<a href="https://www.youtube.com/watch?v=oyLBGkS5ICk" target="_blank" rel="noopener">Spec-ulation</a>“ 演讲中提到了这一点, 即只添加新名称和行为, 不删除旧名称或重新定义其含义, 正是函数式编程鼓励的个体变量或数据结构. 功能性方法在小规模编程中带来了明确性和可预测性方面的好处, 并且在应用时效益更大, 就像导入兼容性规则一样, 对于整个 API: 依赖地狱实际上只是可变性而已. 这只是演讲中的一个小点; 整个演讲值得一看.</p><p>在 “go get” 的早期, 当人们询问有关做出向后不兼容的变化时, 我们的回应是 - 基于多年来对这些软件变化的经验得出的直觉 - 是给出导入版本规则, 但没有明确的解释, 为什么这种方法比不把主版本放在导入路径中更好. Go 1.2 添加了一个关于软件包版本控制的 FAQ 条目, 它提供了基本的建议 (Go 1.10 也是):</p><blockquote><p>打算供公众使用的软件包应该尽量保持向后兼容性. <a href="https://golang.org/doc/go1compat.html" target="_blank" rel="noopener">Go 1 兼容性准则</a>在这里是一个很好的参考: 不要删除导出的名称, 鼓励标记的复合字面量等等. 如果需要不同的功能, 请添加新名称而不是更改旧名称. 如果需要完全破坏兼容性, 请使用新的导入路径创建新的程序包.</p></blockquote><p>这篇博文的一个动机是用一个清晰​​可信的例子来展示为什么遵循规则是如此重要.</p><h3 id="避免单例-Singleton-问题"><a href="#避免单例-Singleton-问题" class="headerlink" title="避免单例 (Singleton) 问题"></a>避免单例 (Singleton) 问题</h3><p>对语义导入版本管理方法的一个普遍反对意见是, 包作者今天预计在给定的构建中只有一个包的副本. 在不同主要版本中允许多个包可能会由于单例的意外重复而导致问题. 一个例子是注册一个 HTTP handler. 如果 my/thing 为 /debug/my/thing 注册了一个 HTTP handler, 那么拥有该程序包的两个副本将导致重复的注册, 这在注册时会引起恐慌. 另一个问题是如果程序中有两个 HTTP 堆栈. 显然, 只有一个 HTTP 堆栈可以在端口 80 上监听; 我们不希望一半的程序注册不会被使用的 handlers. <strong>Go 开发者已经由于 vendored 包出现这样的问题</strong>.</p><p>迁移到 vgo 和语义导入版本可以澄清并简化当前的情况. 通过取代 vendoring 导致的不可控的重复问题, 包作者将保证每个主版本的软件包只有一个实例. 通过将主要版本包含在导入路径中, 包作者应该更清楚 my/thing 和 my/thing/v2 是不同的并且需要能够共存. 或许这意味着在 /debug/my/thing/v2 上导出 v2 调试信息. 或者这也许意味着协调. 也许 v2 可以负责注册 handler, 但也可以为 v1 提供一个钩子(hook)来提供信息以显示在页面上. 这意味着 my/thing 导入 my/thing/v2 或反之亦然; 具有不同的导入路径, 这很容易做到并且易于理解. 相反, 如果 v1 和v2 都是 my/thing, 那么很难理解导入自己的导入路径并获取其他导入路径的含义.</p><h3 id="自动-API-更新"><a href="#自动-API-更新" class="headerlink" title="自动 API 更新"></a>自动 API 更新</h3><p>允许程序包的 v1 和 v2 共存于一个大型程序中的关键原因之一是可以一次升级该程序包的客户端, 并且仍然具有可构建的结果. 这是逐步修复代码的更一般问题的具体实例. (请参阅我的 2016 年文章 “<a href="https://talks.golang.org/2016/refactor.article" target="_blank" rel="noopener">Codebase Refactoring (with help from Go),</a>“ 了解更多关于该问题的信息.)</p><p>除了保持程序的构建外, 语义导入版本控制对逐步修复代码有很大的好处, 我在前面的章节中提到过: 代码包的一个主版本可以导入并用另一个版本编写. 将 v2 API 编写为 v1 实现的封装很简单, 反之亦然. 这让他们能够共享代码, 并且通过适当的设计选择和使用类型别名, 甚至可以允许使用 v1 和 v2 的客户端进行互操作. 它还可以帮助解决定义自动 API 更新中的关键技术问题.</p><p>在 Go 1 之前, 我们严重依赖于 go fix, 在更新到新的 Go 版本后, 用户运行它并找到不再编译的程序. 更新编译不过的代码使得我们无法使用大多数我们的程序分析工具, 这些工具要求其输入是有效的程序. 另外, 我们想知道如何允许 Go 标准库之外的包的作者提供特定于其自己的 API 更新的 “修复”. 在单个程序中命名和处理多个不兼容版本的软件包的能力提示了一种可能的解决方案: 如果 v1 API 函数可以作为 v2 API 的包装器来实现, 则包装器实现是修订规范的两倍. 例如, 假设 API 的 v1 函数具有 EnableFoo 和 DisableFoo 函数, v2 用一个 SetFoo(enabled bool) 替换该函数对. v2 发布后, v1 可以作为 v2 的包装实现:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package p // v1</span><br><span class="line"></span><br><span class="line">import v2 &quot;p/v2&quot;</span><br><span class="line"></span><br><span class="line">func EnableFoo() &#123;</span><br><span class="line">//go:fix</span><br><span class="line">v2.SetFoo(true)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DisableFoo() &#123;</span><br><span class="line">//go:fix</span><br><span class="line">v2.SetFoo(false)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别的 //go:fix 注释会指示去修正后面的包装体应该被内联到调用中. 然后运行 go fix 将重写调用 v1 EnableFoo 为 v2 SetFoo(true). 重写很容易指定和类型检查, 因为它是简单的 Go 代码. 更好的是, 重写显然是安全的: v1 EnableFoo 已经在调用 v2 SetFoo(true), 所以重写调用显然不会改变程序的含义.</p><p>合理的做法可能是使用符号执行来修复反向 API 更改, 从使用 SetFoo 的 v1 到使用 EnableFoo 和 DisableFoo 的 v2. v1 SetFoo 实现可以读取:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package q // v1</span><br><span class="line"></span><br><span class="line">import v2 &quot;q/v2&quot;</span><br><span class="line"></span><br><span class="line">func SetFoo(enabled bool) &#123;</span><br><span class="line">if enabled &#123;</span><br><span class="line">//go:fix</span><br><span class="line">v2.EnableFoo()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//go:fix</span><br><span class="line">v2.DisableFoo()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 go fix 会更新 SetFoo(true) 为 EnableFoo(), SetFoo(false) 为 DisableFoo(). 这种修补程序甚至会应用于单个主要版本中的 API 更新. 例如, v1 可能会被弃用(但保留) SetFoo, 并引入 EnableFoo 和 DisableFoo. 同样的修复将帮助调用者摆脱已弃用的 API.</p><p>要清楚的是, 今天这还没有实现, 但它看起来很有前景, 而且通过赋予不同的东西以不同的名称, 使得这种工具成为可能. 这些示例演示了将持久的, 不可变的名称附加到特定代码行为的能力. 我们只需遵循这样的规则: 当你改变某些东西时, 你也改变了它的名字.</p><h3 id="致力于兼容性"><a href="#致力于兼容性" class="headerlink" title="致力于兼容性"></a>致力于兼容性</h3><p>语义导入版本控制对包的作者来说更有用. 他们不能只是决定发布 v2, 远离 v1, 并留下像 Ugo 这样的用户来应对这种后果. 但那些这么做的包作者正在伤害用户. 在我看来, 如果系统难以伤害用户, 并且自然而然地包作者也不会作出伤害用户的行为, 那么这似乎是件好事.</p><p>更一般地说, Sam Boyer 在 GopherCon 2017 上谈到了软件包管理如何调节我们的社交互动, 以及人们构建软件的协作. 我们可以决定. 我们是否希望在一个围绕系统创建的社区中工作, 该系统可以优化兼容性, 平滑过渡以及一起很好的工作 ? 或者我们是否希望在一个围绕系统创建的社区中工作, 该系统可以优化创建和描述不兼容性, 这使得作者破坏用户程序也可以接受 ? 导入版本控制, 特别是通过将语义主版本提升到导入路径来处理语义版本控制, 就是我们如何确保在第一种社区中工作.</p><p>让我们致力于兼容性.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
            <tag> vgo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>版本化 Go 之旅</title>
      <link href="/post/vgo-tour.html"/>
      <url>/post/vgo-tour.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自 <a href="https://research.swtch.com/vgo-tour" target="_blank" rel="noopener">A Tour of Versioned Go (vgo)</a>, <a href="https://lingchao.xin/tag/vgo.html">Go &amp; Versioning</a> 的第 2 部分, 版权@归原文所有.<br><a id="more"></a><p></p><p>对我而言, 设计意味着一遍又一遍地构建, 拆除和再构建. 为了编写<a href="https://research.swtch.com/vgo-intro" target="_blank" rel="noopener">新的版本控制提案</a>, 我构建了一个原型 vgo, 来处理许多细微的细节. 这篇博文展示了如何使用 vgo.</p><p>你现在可以通过运行 go get golang.org/x/vgo 下载并尝试 vgo. Vgo 是 go 命令的一个直接替换(和分支拷贝). 你运行 vgo 而不是 go, 它将使用你安装在 $GOROOT (Go 1.10 beta1 或更高版本) 的编译器和标准库.</p><p>随着我们更多地了解什么可行, 什么不可行, vgo 的语义和命令行细节可能会发生变化. 但是, 我们打算避免 go.mod 文件格式的向后不兼容的更改, 以便今天添加了 go.mod 的项目以后也可以工作. 在我们完善提案时, 我们也会相应地更新 vgo.</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>该部分演示怎么使用 vgo. 请按照步骤进行实验.</p><p>从安装 vgo 开始:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go get -u golang.org/x/vgo</span><br></pre></td></tr></table></figure><p>你一定会遇到有趣的 bug, 因为 vgo 现在最多只有轻微的测试. 请使用 <a href="https://golang.org/issue" target="_blank" rel="noopener">Go 问题跟踪</a> 进行 bug 上报, 标题以 “x/vgo” 开头. 多谢.</p><h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello, world"></a>Hello, world</h3><p>我们来写一个有趣的 “Hello, world” 程序. 在 GOPATH/src 目录之外创建一个目录并切换到它:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd $HOME</span><br><span class="line">$ mkdir hello</span><br><span class="line">$ cd hello</span><br></pre></td></tr></table></figure><p>然后创建一个 hello.go:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">// import "github.com/you/hello"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"rsc.io/quote"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(quote.Hello())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者下载它:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -sS https://swtch.com/hello.go &gt;hello.go</span><br></pre></td></tr></table></figure><p>创建一个空的 go.mod 文件来标记此模块的根目录, 然后构建并运行新程序:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &gt;go.mod</span><br><span class="line">$ vgo build</span><br><span class="line">vgo: resolving import &quot;rsc.io/quote&quot;</span><br><span class="line">vgo: finding rsc.io/quote (latest)</span><br><span class="line">vgo: adding rsc.io/quote v1.5.2</span><br><span class="line">vgo: finding rsc.io/quote v1.5.2</span><br><span class="line">vgo: finding rsc.io/sampler v1.3.0</span><br><span class="line">vgo: finding golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c</span><br><span class="line">vgo: downloading rsc.io/quote v1.5.2</span><br><span class="line">vgo: downloading rsc.io/sampler v1.3.0</span><br><span class="line">vgo: downloading golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c</span><br><span class="line">$ ./hello</span><br><span class="line">Hello, world.</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>注意这里没有显式的需要运行 vgo get. 普通的 vgo build 将在遇到未知导入时查找包含它的模块, 并将该模块的最新版本作为依赖添加到当前模块中.</p><p>运行任何 vgo 命令的一个副作用是必要时会更新 go.mod. 这种情况下, vgo build 会写入新的 go.mod 文件:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat go.mod</span><br><span class="line">module &quot;github.com/you/hello&quot;</span><br><span class="line"></span><br><span class="line">require &quot;rsc.io/quote&quot; v1.5.2</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>由于 go.mod 已写入, 下一次 vgo build 将不会再次解析导入或打印那么多:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo build</span><br><span class="line">$ ./hello</span><br><span class="line">Hello, world.</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>即使明天发布了 rsc.io/quote v1.5.3 或 v1.6.0, 该目录中的构建仍将继续使用 v1.5.2, 除非进行明确的升级(见下文).</p><p>go.mod 文件列举了依赖的最小集合, 忽略了已列举中所隐含的. 在这种情况下, rsc.io/quote v1.5.2 依赖特定版本的 rsc.io/sampler 和 golang.org/x/text, 所以在 go.mod 中重复列举它们是冗余的.</p><p>使用 vgo list -m 仍然可以找到构建所需的全套模块:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo list -m</span><br><span class="line">MODULE                VERSION</span><br><span class="line">github.com/you/hello  -</span><br><span class="line">golang.org/x/text     v0.0.0-20170915032832-14c0d48ead0c</span><br><span class="line">rsc.io/quote          v1.5.2</span><br><span class="line">rsc.io/sampler        v1.3.0</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>此时你可能想知道为什么我们简单的 “hello world” 程序会使用 golang.org/x/text. 实际上 rsc.io/quote 依赖 rsc.io/sampler, 后者又依赖 golang.org/x/text 进行 <a href="https://blog.golang.org/matchlang" target="_blank" rel="noopener">language matching</a> .</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ LANG=fr ./hello</span><br><span class="line">Bonjour le monde.</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>我们已经看到, 当必须将新模块添加到构建以解决新的导入时, vgo 会采用最新的模块. 此前, 它需要 rsc.io/quote, 并发现 v1.5.2 是最新的. 但除了解析新的导入, vgo 仅使用 go.mod 文件中列出的版本. 在我们的例子中, rsc.io/quote 间接依赖于 golang.org/x/text 和 rsc.io/sampler 的特定版本. 事实证明, 这两个软件包都有较新的版本, 正如我们通过 vgo list -u (检查更新的软件包)看到的那样:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo list -m -u</span><br><span class="line">MODULE                VERSION                             LATEST</span><br><span class="line">github.com/you/hello  -                                   -</span><br><span class="line">golang.org/x/text     v0.0.0-20170915032832-14c0d48ead0c  v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">rsc.io/quote          v1.5.2 (2018-02-14 10:44)           -</span><br><span class="line">rsc.io/sampler        v1.3.0 (2018-02-13 14:05)           v1.99.99 (2018-02-13 17:20)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>这两个软件包都有更新的版本, 所以我们可能想在我们的 hello 程序中升级它们.</p><p>首先升级 golang.org/x/text:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo get golang.org/x/text</span><br><span class="line">vgo: finding golang.org/x/text v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">vgo: downloading golang.org/x/text v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">$ cat go.mod</span><br><span class="line">module &quot;github.com/you/hello&quot;</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">&quot;golang.org/x/text&quot; v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">&quot;rsc.io/quote&quot; v1.5.2</span><br><span class="line">)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>vgo get 命令将查找给定模块的最新版本, 并通过更新 go.mod 来将该版本添加为当前模块的依赖. 从现在开始, 未来的构建将使用较新的 text 模块:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo list -m</span><br><span class="line">MODULE                VERSION</span><br><span class="line">github.com/you/hello  -</span><br><span class="line">golang.org/x/text     v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">rsc.io/quote          v1.5.2</span><br><span class="line">rsc.io/sampler        v1.3.0</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>当然, 升级之后, 测试一切仍然工作良好是个好主意. 我们的依赖 rsc.io/quote 和 rsc.io/sampler 尚未使用较新的 text 模块进行测试. 我们可以在我们创建的配置中运行他们的测试:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo test all</span><br><span class="line">?   github.com/you/hello[no test files]</span><br><span class="line">?   golang.org/x/text/internal/gen[no test files]</span><br><span class="line">ok  golang.org/x/text/internal/tag0.020s</span><br><span class="line">?   golang.org/x/text/internal/testtext[no test files]</span><br><span class="line">ok  golang.org/x/text/internal/ucd0.020s</span><br><span class="line">ok  golang.org/x/text/language0.068s</span><br><span class="line">ok  golang.org/x/text/unicode/cldr0.063s</span><br><span class="line">ok  rsc.io/quote0.015s</span><br><span class="line">ok  rsc.io/sampler0.016s</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>在原版 go 命令中, 软件包模式 all 意味着 GOPATH 中能找到的所有软件包. 这几乎总是太多而无用. 在 vgo 中, 我们已经将 all 的含义缩小为 “当前模块中的所有软件包, 以及它们以递归方式导入的软件包”. rsc.io/quote 模块的 1.5.2 版本包含一个 buggy 包:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo test rsc.io/quote/...</span><br><span class="line">ok  rsc.io/quote(cached)</span><br><span class="line">--- FAIL: Test (0.00s)</span><br><span class="line">buggy_test.go:10: buggy!</span><br><span class="line">FAIL</span><br><span class="line">FAILrsc.io/quote/buggy0.014s</span><br><span class="line">(exit status 1)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>然而, 除非我们模块中的某个包导入 buggy, 否则它是不相干的, 所以它不包含在 all 里面. 无论如何, 升级的 x/text 看起来可以工作. 此时我们多半可以提交 go.mod.</p><p>另一种选择是使用 vgo get -u 升级构建所需的所有模块:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo get -u</span><br><span class="line">vgo: finding golang.org/x/text latest</span><br><span class="line">vgo: finding rsc.io/quote latest</span><br><span class="line">vgo: finding rsc.io/sampler latest</span><br><span class="line">vgo: finding rsc.io/sampler v1.99.99</span><br><span class="line">vgo: finding golang.org/x/text latest</span><br><span class="line">vgo: downloading rsc.io/sampler v1.99.99</span><br><span class="line">$ cat go.mod</span><br><span class="line">module &quot;github.com/you/hello&quot;</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">&quot;golang.org/x/text&quot; v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">&quot;rsc.io/quote&quot; v1.5.2</span><br><span class="line">&quot;rsc.io/sampler&quot; v1.99.99</span><br><span class="line">)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>在这里, vgo get -u 保留了升级后的 text 模块, 并将 rsc.io/sampler 升级到其最新版本 v1.99.99.</p><p>让我们来运行测试:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo test all</span><br><span class="line">?   github.com/you/hello[no test files]</span><br><span class="line">?   golang.org/x/text/internal/gen[no test files]</span><br><span class="line">ok  golang.org/x/text/internal/tag(cached)</span><br><span class="line">?   golang.org/x/text/internal/testtext[no test files]</span><br><span class="line">ok  golang.org/x/text/internal/ucd(cached)</span><br><span class="line">ok  golang.org/x/text/language0.070s</span><br><span class="line">ok  golang.org/x/text/unicode/cldr(cached)</span><br><span class="line">--- FAIL: TestHello (0.00s)</span><br><span class="line">quote_test.go:19: Hello() = &quot;99 bottles of beer on the wall, 99 bottles of beer, ...&quot;, want &quot;Hello, world.&quot;</span><br><span class="line">FAIL</span><br><span class="line">FAILrsc.io/quote0.014s</span><br><span class="line">--- FAIL: TestHello (0.00s)</span><br><span class="line">hello_test.go:31: Hello([en-US fr]) = &quot;99 bottles of beer on the wall, 99 bottles of beer, ...&quot;, want &quot;Hello, world.&quot;</span><br><span class="line">hello_test.go:31: Hello([fr en-US]) = &quot;99 bottles of beer on the wall, 99 bottles of beer, ...&quot;, want &quot;Bonjour le monde.&quot;</span><br><span class="line">FAIL</span><br><span class="line">FAILrsc.io/sampler0.014s</span><br><span class="line">(exit status 1)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>看起来 rsc.io/sampler v1.99.99 出了问题. 果然:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo build</span><br><span class="line">$ ./hello</span><br><span class="line">99 bottles of beer on the wall, 99 bottles of beer, ...</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>vgo get -u 获取每个依赖的最新版本的行为正和 go get 下载所有不在 GOPATH 的包所做的一样. 在一个 GOPATH 里空无一物的系统上:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go get -d rsc.io/hello</span><br><span class="line">$ go build -o badhello rsc.io/hello</span><br><span class="line">$ ./badhello</span><br><span class="line">99 bottles of beer on the wall, 99 bottles of beer, ...</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>重要的区别是, 默认情况下, vgo 不会以这种方式运行. 你也可以通过降级撤消它.</p><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>要降级软件包, 请使用 vgo list -t 显示可用的标记(tag)版本:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo list -t rsc.io/sampler</span><br><span class="line">rsc.io/sampler</span><br><span class="line">v1.0.0</span><br><span class="line">v1.2.0</span><br><span class="line">v1.2.1</span><br><span class="line">v1.3.0</span><br><span class="line">v1.3.1</span><br><span class="line">v1.99.99</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>然后使用 vgo 获取要求的特定版本, 例如 v1.3.1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat go.mod</span><br><span class="line">module &quot;github.com/you/hello&quot;</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">&quot;golang.org/x/text&quot; v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">&quot;rsc.io/quote&quot; v1.5.2</span><br><span class="line">&quot;rsc.io/sampler&quot; v1.99.99</span><br><span class="line">)</span><br><span class="line">$ vgo get rsc.io/sampler@v1.3.1</span><br><span class="line">vgo: finding rsc.io/sampler v1.3.1</span><br><span class="line">vgo: downloading rsc.io/sampler v1.3.1</span><br><span class="line">$ vgo list -m</span><br><span class="line">MODULE                VERSION</span><br><span class="line">github.com/you/hello  -</span><br><span class="line">golang.org/x/text     v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">rsc.io/quote          v1.5.2</span><br><span class="line">rsc.io/sampler        v1.3.1</span><br><span class="line">$ cat go.mod</span><br><span class="line">module &quot;github.com/you/hello&quot;</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">&quot;golang.org/x/text&quot; v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">&quot;rsc.io/quote&quot; v1.5.2</span><br><span class="line">&quot;rsc.io/sampler&quot; v1.3.1</span><br><span class="line">)</span><br><span class="line">$ vgo test all</span><br><span class="line">?   github.com/you/hello[no test files]</span><br><span class="line">?   golang.org/x/text/internal/gen[no test files]</span><br><span class="line">ok  golang.org/x/text/internal/tag(cached)</span><br><span class="line">?   golang.org/x/text/internal/testtext[no test files]</span><br><span class="line">ok  golang.org/x/text/internal/ucd(cached)</span><br><span class="line">ok  golang.org/x/text/language(cached)</span><br><span class="line">ok  golang.org/x/text/unicode/cldr(cached)</span><br><span class="line">ok  rsc.io/quote0.016s</span><br><span class="line">ok  rsc.io/sampler0.015s</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>降级一个软件包可能需要降级其他软件包. 例如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo get rsc.io/sampler@v1.2.0</span><br><span class="line">vgo: finding rsc.io/sampler v1.2.0</span><br><span class="line">vgo: finding rsc.io/quote v1.5.1</span><br><span class="line">vgo: finding rsc.io/quote v1.5.0</span><br><span class="line">vgo: finding rsc.io/quote v1.4.0</span><br><span class="line">vgo: finding rsc.io/sampler v1.0.0</span><br><span class="line">vgo: downloading rsc.io/sampler v1.2.0</span><br><span class="line">$ vgo list -m</span><br><span class="line">MODULE                VERSION</span><br><span class="line">github.com/you/hello  -</span><br><span class="line">golang.org/x/text     v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">rsc.io/quote          v1.4.0</span><br><span class="line">rsc.io/sampler        v1.2.0</span><br><span class="line">$ cat go.mod</span><br><span class="line">module &quot;github.com/you/hello&quot;</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">&quot;golang.org/x/text&quot; v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">&quot;rsc.io/quote&quot; v1.4.0</span><br><span class="line">&quot;rsc.io/sampler&quot; v1.2.0</span><br><span class="line">)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>在这种情况下, rsc.io/quote v1.5.0 是第一个需要 rsc.io/sampler v1.3.0 的版本; 早期版本只需要 v1.0.0(或更高版本). 降级选择了 rsc.io/quote v1.4.0, 这是与 v1.2.0 兼容的最新版本.</p><p>也可以通过指定 none 作为版本来完全删除一个依赖, 这是一种极端的降级形式:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo get rsc.io/sampler@none</span><br><span class="line">vgo: downloading rsc.io/quote v1.4.0</span><br><span class="line">vgo: finding rsc.io/quote v1.3.0</span><br><span class="line">$ vgo list -m</span><br><span class="line">MODULE                VERSION</span><br><span class="line">github.com/you/hello  -</span><br><span class="line">golang.org/x/text     v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">rsc.io/quote          v1.3.0</span><br><span class="line">$ cat go.mod</span><br><span class="line">module &quot;github.com/you/hello&quot;</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">&quot;golang.org/x/text&quot; v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">&quot;rsc.io/quote&quot; v1.3.0</span><br><span class="line">)</span><br><span class="line">$ vgo test all</span><br><span class="line">vgo: downloading rsc.io/quote v1.3.0</span><br><span class="line">?   github.com/you/hello[no test files]</span><br><span class="line">ok  rsc.io/quote0.014s</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>让我们回到一切都是最新版本的状态, 包括 rsc.io/sampler v1.99.99:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo get -u</span><br><span class="line">vgo: finding golang.org/x/text latest</span><br><span class="line">vgo: finding rsc.io/quote latest</span><br><span class="line">vgo: finding rsc.io/sampler latest</span><br><span class="line">vgo: finding golang.org/x/text latest</span><br><span class="line">$ vgo list -m</span><br><span class="line">MODULE                VERSION</span><br><span class="line">github.com/you/hello  -</span><br><span class="line">golang.org/x/text     v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">rsc.io/quote          v1.5.2</span><br><span class="line">rsc.io/sampler        v1.99.99</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="排除-Excluding"><a href="#排除-Excluding" class="headerlink" title="排除 (Excluding)"></a>排除 (Excluding)</h3><p>在确定 v1.99.99 并不适用于我们的 hello world 程序后, 我们可能想记录下这个事实, 以避免将来出现问题. 我们可以通过向 go.mod 添加 exclude 指令来做到这一点:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exclude &quot;rsc.io/sampler&quot; v1.99.99</span><br></pre></td></tr></table></figure><p>之后的操作表现的好像该模块不存在一样:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &apos;exclude &quot;rsc.io/sampler&quot; v1.99.99&apos; &gt;&gt;go.mod</span><br><span class="line">$ vgo list -t rsc.io/sampler</span><br><span class="line">rsc.io/sampler</span><br><span class="line">v1.0.0</span><br><span class="line">v1.2.0</span><br><span class="line">v1.2.1</span><br><span class="line">v1.3.0</span><br><span class="line">v1.3.1</span><br><span class="line">v1.99.99 # excluded</span><br><span class="line">$ vgo get -u</span><br><span class="line">vgo: finding golang.org/x/text latest</span><br><span class="line">vgo: finding rsc.io/quote latest</span><br><span class="line">vgo: finding rsc.io/sampler latest</span><br><span class="line">vgo: finding rsc.io/sampler latest</span><br><span class="line">vgo: finding golang.org/x/text latest</span><br><span class="line">$ vgo list -m</span><br><span class="line">MODULE                VERSION</span><br><span class="line">github.com/you/hello  -</span><br><span class="line">golang.org/x/text     v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">rsc.io/quote          v1.5.2</span><br><span class="line">rsc.io/sampler        v1.3.1</span><br><span class="line">$ cat go.mod</span><br><span class="line">module &quot;github.com/you/hello&quot;</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">&quot;golang.org/x/text&quot; v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">&quot;rsc.io/quote&quot; v1.5.2</span><br><span class="line">&quot;rsc.io/sampler&quot; v1.3.1</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">exclude &quot;rsc.io/sampler&quot; v1.99.99</span><br><span class="line">$ vgo test all</span><br><span class="line">?   github.com/you/hello[no test files]</span><br><span class="line">?   golang.org/x/text/internal/gen[no test files]</span><br><span class="line">ok  golang.org/x/text/internal/tag(cached)</span><br><span class="line">?   golang.org/x/text/internal/testtext[no test files]</span><br><span class="line">ok  golang.org/x/text/internal/ucd(cached)</span><br><span class="line">ok  golang.org/x/text/language(cached)</span><br><span class="line">ok  golang.org/x/text/unicode/cldr(cached)</span><br><span class="line">ok  rsc.io/quote(cached)</span><br><span class="line">ok  rsc.io/sampler(cached)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>排除仅适用于当前模块的构建. 如果当前模块被更大的构建所依赖, 则排除不适用. 例如, rsc.io/quote 的 go.mod 中的排除不适用于我们的 “hello, world” 构建.</p><p>这一策略的权衡让当前模块的作者几乎可以任意控制自己的构建, 而不会受到它们依赖的模块几乎任意控制的影响.</p><p>此时, 正确的下一步是联系 rsc.io/sampler 的作者并在 v1.99.99 中报告问题, 因此它可以在 v1.99.100 中修复. 不幸的是, 作者有一个博文依赖它而不予修复.</p><h3 id="替换-Replacing"><a href="#替换-Replacing" class="headerlink" title="替换 (Replacing)"></a>替换 (Replacing)</h3><p>如果确实在依赖中发现了问题, 则需要一种方法将其暂时替换为一个合适的副本. 假设我们想改变一些关于 rsc.io/quote 的行为. 也许我们想要解决 rsc.io/sampler 中的问题, 或者我们想要做其他的事情. 第一步是使用通常的 git 命令检出 quote 模块:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/rsc/quote ../quote</span><br><span class="line">Cloning into &apos;../quote&apos;...</span><br></pre></td></tr></table></figure><p>然后编辑 ../quote/quote.go 来改变 func Hello 的一些内容. 例如, 我把它的返回值从 sampler.Hello() 更改为 sampler.Glass(), 这是一个更有趣的问候语.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ../quote</span><br><span class="line">$ &lt;edit quote.go&gt;</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>改变了克隆代码之后, 我们可以通过向 go.mod 添加 replace 指令来让我们的构建使用它来代替真正的构建:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">replace &quot;rsc.io/quote&quot; v1.5.2 =&gt; &quot;../quote&quot;</span><br></pre></td></tr></table></figure><p>然后我们可以使用它来构建我们的程序:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ../hello</span><br><span class="line">$ echo &apos;replace &quot;rsc.io/quote&quot; v1.5.2 =&gt; &quot;../quote&quot;&apos; &gt;&gt;go.mod</span><br><span class="line">$ vgo list -m</span><br><span class="line">MODULE                VERSION</span><br><span class="line">github.com/you/hello  -</span><br><span class="line">golang.org/x/text     v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">rsc.io/quote          v1.5.2</span><br><span class="line"> =&gt; ../quote</span><br><span class="line">rsc.io/sampler        v1.3.1</span><br><span class="line">$ vgo build</span><br><span class="line">$ ./hello</span><br><span class="line">I can eat glass and it doesn&apos;t hurt me.</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>你也可以将一个不同的模块命名为替换模块. 例如, 你可以克隆 github.com/rsc/quote, 然后将更改推送到你自己的分支.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ../quote</span><br><span class="line">$ git commit -a -m &apos;my fork&apos;</span><br><span class="line">[master 6151719] my fork</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line">$ git tag v0.0.0-myfork</span><br><span class="line">$ git pu https://github.com/you/quote v0.0.0-myfork</span><br><span class="line">To https://github.com/you/quote</span><br><span class="line"> * [new tag]         v0.0.0-myfork -&gt; v0.0.0-myfork</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>然后你可以使用它作为替换:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ../hello</span><br><span class="line">$ echo &apos;replace &quot;rsc.io/quote&quot; v1.5.2 =&gt; &quot;github.com/you/quote&quot; v0.0.0-myfork&apos; &gt;&gt;go.mod</span><br><span class="line">$ vgo list -m</span><br><span class="line">vgo: finding github.com/you/quote v0.0.0-myfork</span><br><span class="line">MODULE                    VERSION</span><br><span class="line">github.com/you/hello      -</span><br><span class="line">golang.org/x/text         v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">rsc.io/quote              v1.5.2</span><br><span class="line"> =&gt; github.com/you/quote  v0.0.0-myfork</span><br><span class="line">rsc.io/sampler            v1.3.1</span><br><span class="line">$ vgo build</span><br><span class="line">vgo: downloading github.com/you/quote v0.0.0-myfork</span><br><span class="line">$ LANG=fr ./hello</span><br><span class="line">Je peux manger du verre, ça ne me fait pas mal.</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h3 id="向后兼容性"><a href="#向后兼容性" class="headerlink" title="向后兼容性"></a>向后兼容性</h3><p>即使你想为你的项目使用 vgo, 你也不可能要求你的所有的用户都有 vgo. 相反, 你可以创建一个 vendor 目录, 以允许 go 命令用户生成几乎相同的构建(当然, 在 GOPATH 中编译):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vgo vendor</span><br><span class="line">$ mkdir -p $GOPATH/src/github.com/you</span><br><span class="line">$ cp -a . $GOPATH/src/github.com/you/hello</span><br><span class="line">$ go build -o vhello github.com/you/hello</span><br><span class="line">$ LANG=es ./vhello</span><br><span class="line">Puedo comer vidrio, no me hace daño.</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>我说这些构建 “几乎相同”, 因为工具链看到的并在最终二进制文件中记录的导入路径是不同的. vendored 版本参见 vendor 目录:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go tool nm hello | grep sampler.hello</span><br><span class="line"> 1170908 B rsc.io/sampler.hello</span><br><span class="line">$ go tool nm vhello | grep sampler.hello</span><br><span class="line"> 11718e8 B github.com/you/hello/vendor/rsc.io/sampler.hello</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>除了这种差异, 构建应该产生相同的二进制文件. 为了提供优雅的转换, 基于 vgo 的构建完全忽略 vendor 目录, 一如既往的模块感知 go 命令构建.</p><h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来 ?"></a>接下来 ?</h2><p>请尝试 vgo. 在存储库中开始标记(tagging)版本. 创建并检入(check in) go.mod 文件. 在 golang.org/issue 上上报问题, 并在标题开头添加 “x/vgo:” 明天会有更多的博文. 谢谢, 玩得开心!</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
            <tag> vgo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go += 包版本</title>
      <link href="/post/vgo-intro.html"/>
      <url>/post/vgo-intro.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自 <a href="https://research.swtch.com/vgo-intro" target="_blank" rel="noopener">Go += Package Versioning</a>, <a href="https://lingchao.xin/tag/vgo.html">Go &amp; Versioning</a> 的第 1 部分, 版权@归原文所有.<br><a id="more"></a><p></p><p>我们需要将包版本控制添加到 Go.</p><p>更确切地说, 我们需要将软件包版本的概念添加到 Go 开发人员和我们的工具的工作词汇表中, 以便在彼此交谈时准确地确定应该构建, 运行或分析哪个程序. go 命令需要能够告诉开发人员具体哪些版本的软件包在特定构建中, 反之亦然.</p><p>版本控制可以让我们启用可重复构建, 所以如果我告诉你试用我的程序的最新版本, 我知道你将不仅获得我的代码的最新版本, 而且还包括我的代码所依赖包的精确的同一版本, 所以你和我将构建完全等价的二进制.</p><p>版本控制还可以让我们确保明天程序的构建方式与今天的完全相同. 即使有更新版本的依赖, go 命令也不应该使用它们除非被要求这样做.</p><p>尽管我们必须添加版本控制, 但我们也不能移除当前 go 命令的最佳部分: 简单, 速度以及易懂. 当前, 许多程序员大多不关注版本控制, 而且大部分都工作良好. 如果我们正确地获得了模型和默认值, 我们应该能够以这样的方式添加版本控制, 即程序员仍然大多不关注版本控制, 并且一切都更好, 而且更易于理解. 现有的工作流程应该尽可能少地改变. 发布新版本应该非常简单. 一般来说, 版本管理工作必须从后台淡出, 而不是日常关注.</p><p>简而言之, 我们需要添加软件包版本控制, 但我们还不能破坏 go get. 这篇文章草拟了一个做这件事的恰到好处的提案, 以及今天就可以尝试的原型演示, 希望这将成为最终 go 命令集成的基础. 我打算将这篇文章作为有效讨论什么可行以及什么不可行的开始. 基于这一讨论, 我将对提案和原型进行调整, 然后我将提交一份正式的 <a href="https://golang.org/s/proposal" target="_blank" rel="noopener">Go 提案</a>, 作为可选功能集成到 Go 1.11 中.</p><p>这个提案保留了 go get 最好的部分, 增加了可重复构建, 采用了语义版本化, 消除了 vendoring, 弃用了 GOPATH 转而采用了基于项目的工作流程, 并且提供了一个从 dep 和其前任们的平滑迁移. 也就是说, 这个提案还处于早期阶段. 如果细节还不正确, 我们会花时间在集成进 Go 主发行版之前修复它们.</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在我们看这个提案之前, 让我们看看我们做到了什么. 这可能有点长, 但历史对当下有重要的启示, 并有助于理解提案为什么会作出改变. 如果你不耐烦, 请跳到<a href="https://research.swtch.com/vgo-intro#proposal" target="_blank" rel="noopener">提案</a>或阅读附带的<a href="https://research.swtch.com/vgo-tour" target="_blank" rel="noopener">示例博客文章</a>.</p><h3 id="Makefiles-goinstall-以及-go-get"><a href="#Makefiles-goinstall-以及-go-get" class="headerlink" title="Makefiles, goinstall, 以及 go get"></a>Makefiles, goinstall, 以及 go get</h3><p>2009 年 11 月, Go 的最初版本是一个编译器, 链接器和一些库. 你必须运行 6g 和 6l 编译和链接你的程序, 并且我们包含了示例 makefile(s). 在大多数情况下, 有一个最小化的 gobuild 封装可以构建单个包并写入一个合适的 makefile. 没有既定的方式与其他人分享代码. 我们知道还需要更多的东西, 但是我们已经发布了我们所有的东西, 并计划在社区中完成剩下的工作.</p><p>2010 年 2 月, 我们提出了 <a href="https://groups.google.com/d/msg/golang-nuts/8JFwR3ESjjI/cy7qZzN7Lw4J" target="_blank" rel="noopener">goinstall</a> 一个新的零配置命令, 用于从源码控制仓库(如 Bitbucket 和 GitHub )下载软件包. Goinstall 引入了今天开发人员认为理所当然的导入路径约定. 由于当时没有任何代码遵循这些约定, 所以 goinstall 起初只能处理除标准库之外没有任何其他包导入的软件包. 但是开发人员很快从他们自己的各种命名方案转移到了我们今天所知道的统一约定, 并且已发布的 Go 包集合发展成为一个连贯的生态系统.</p><p>Goinstall 也消除了 makefile 以及与之相关的用户定义构建变动的复杂性. 尽管对于包作者在每次构建期间不能生成代码来说有时不方便, 但这种简化对于包用户来说非常重要: 用户不必担心首次安装与构建之前使用的包作者相同的一组工具. 简化对于工具来说也是至关重要的. makefile 是编译包的一个必要的步骤, 反向工程如何应用不同的工具, 如 go vet 或代码完成, 到相同的包, 可能会非常困难. 即使正确地获得构建依赖关系, 以便在必要时重新构建包, 并且只在必要时重新构建包, 这对于任意 makefile 非常困难. 虽然有些人在灵活性被剥夺的时候表示反对, 但回想起来, 这些好处远远超过了不便之处.</p><p>2011 年 12 月, 作为 Go 1 准备工作的一部分, 我们推出了 <a href="https://groups.google.com/d/msg/golang-dev/8DNjlySemwI/-1CDvVX6QVcJ" target="_blank" rel="noopener">go</a> 命令, go get 替换了 gobuild .</p><p>总体而言, go get 具有变革意义, 可让 Go 开发人员共享源代码并构建彼此的工作, 并通过在 go 命令内部隔离构建系统的细节来启用工具. 但是 go get 缺少任何版本控制的概念. 很明显在<a href="https://groups.google.com/d/msg/golang-nuts/8JFwR3ESjjI/cy7qZzN7Lw4J" target="_blank" rel="noopener">第一次 goinstall 讨论</a>中我们需要做一些关于版本控制的内容. 不幸的是, 至少对于我们在 Go 团队中, 我们不清楚究竟该怎么做. 当 go get 需要一个包时, 它总是获取最新的副本, 将下载和更新操作委托给像 Git 或 Mercurial 这样的版本控制系统. 软件包版本的这种无知导致了至少两个显著的缺陷.</p><h3 id="版本和-API-稳定性"><a href="#版本和-API-稳定性" class="headerlink" title="版本和 API 稳定性"></a>版本和 API 稳定性</h3><p>go get 的第一个显著缺点是, 如果没有版本控制的概念, 它就不能告诉用户对给定更新期望发生什么样的变化.</p><p>2013 年 11 月, Go 1.2 添加了一个关于包版本控制的常见问题解答条目, 提供了基本的建议 (Go 1.10也没有变):</p><blockquote><p>打算供公众使用的软件包应该尽量保持向后兼容性. <a href="https://golang.org/doc/go1compat.html" target="_blank" rel="noopener">Go 1 兼容性准则</a>在这里是一个很好的参考: 不要删除导出的名称, 鼓励标记的复合文字等等. 如果需要不同的功能, 请添加新名称而不是更改旧名称. 如果需要完全打破兼容性, 请创建新的导入路径的软件包.</p></blockquote><p>2014 年 3 月, Gustavo Niemeyer 创建了 <a href="https://gopkg.in/" target="_blank" rel="noopener">gopkg.in</a>, 广而告之为 “Go语言的稳定API”. 该域名是一个版本感知的 GitHub 重定向器, 允许导入路径, 如 gopkg.in/yaml.v1 和 gopkg.in/yaml.v2 引用单个 Git 仓库的不同提交 (可能位于不同分支上) . 在语义版本化之后, 包作者需要在进行重大更改时引入一个新的主要版本, 以便较早版本的 v1 导入路径可以作为先前版本的替代版本, 而 v2 导入路径可能是完全不同的 API.</p><p>2015 年 8 月, Dave Cheney 提出<a href="https://github.com/golang/go/issues/12302" target="_blank" rel="noopener">采用语义版本化的提案</a>. 这在接下来的几个月里引发了一场有趣的讨论, 其中每个人似乎都认为, 使用语义版本标记代码似乎是一个好主意, 但没有人知道下一步: 这些版本应该使用什么工具 ?</p><p>任何关于语义版本的讨论都不可避免地包含引用海勒姆法则的反驳, 其中指出:</p><blockquote><p>拥有足够数量的 API 用户, 无论你在合同中承诺什么, 都无关紧要. 系统中所有可观察到的行为都将被某人依赖.</p></blockquote><p>虽然海勒姆法则在经验上是真实的, 但是语义版本化仍然是一个有用的方法来构建对发布之间关系的期望. 从 1.2.3 更新到 1.2.4 不应该破坏你的代码, 而从 1.2.3 更新到 2.0.0 是可能的. 如果代码在更新到 1.2.4 后停止工作, 作者很可能会欢迎 bug 报告并在 1.2.5 中发布修复. 如果你的代码在更新到 2.0.0 之后停止工作(甚至编译), 那么这种改变更有可能是故意的, 并且在 2.0.1 中修复你的代码的机会相对较少.</p><p>我没有从海勒姆法则中得出结论: 语义版本化是不可能的, 我认为构建应该小心地使用作者所做的每个依赖的完全相同的版本, 除非被迫. 也就是说, 构建应该默认为尽可能重现.</p><h3 id="Vendoring-以及可重复性构建"><a href="#Vendoring-以及可重复性构建" class="headerlink" title="Vendoring 以及可重复性构建"></a>Vendoring 以及可重复性构建</h3><p>go get 的第二个显著的缺点是, 如果没有版本控制的概念, 它不能确保甚至不能表达可重复构建的想法. 无法确定你的用户正在编译你的代码所依赖的相同版本. 2013 年 11 月, Go 1.2 常见问题解答还添加了以下基本建议:</p><blockquote><p>如果你使用的是外部提供的软件包, 并担心它可能会以意想不到的方式更改, 最简单的解决方案是将其复制到本地仓库 (这是 Google 内部采取的方法). 将副本存储在新的导入路径下, 以将其标识为本地副本. 例如, 你可能会复制 “original.com/pkg” 到 “you.com/external/original.com/pkg”. Keith Rarick 的 goven 是帮助实现这一过程自动化的工具之一.</p></blockquote><p>Goven, Keith Rarick 于 2012 年 3 月开始创建, 它将依赖项复制到你的仓库中, 并更新其中的所有导入路径以反映新位置. 以这种方式修改依赖项的源代码对于构建它而言是必要的, 但也是不幸的. 这些修改使得它难以与使用该依赖关系的其他复制代码进行比较和合并更新的副本和所需的更新.</p><p>Keith 在 2013 年 9 月宣布了 <a href="https://groups.google.com/d/msg/golang-nuts/8NJq6jTIpas/Vpf-KZtVu9MJ" target="_blank" rel="noopener">godep</a>: “一个冻结软件包依赖关系的新工具”. godep 的主要进展是添加我们现在所理解的 Go vendoring - 即将依赖复制到项目中, 而不修改源文件 - 没有直接工具链通过以某种方式设置 GOPATH 来支持.</p><p>2014 年 10 月, Keith 建议在 Go 工具链中<a href="https://groups.google.com/forum/#!msg/golang-dev/74zjMON9glU/dGhnoi2IMzsJ" target="_blank" rel="noopener">增加对 “外部软件包” 概念的支持</a>, 以便工具可以更好地理解使用该约定的项目. 届时, 有许多类似于 godep 的努力. Matt Farina 写了一篇博客文章: “<a href="https://codeengineered.com/blog/2014/glide-go-package-management/" target="_blank" rel="noopener">Glide In The Sea of Go Package Managers</a>“, 将最新的包管理器特别是 glide 与 godep 进行比较.</p><p>2015 年 4 月, Dave Cheney 介绍了 gb 一个 “基于项目的构建工具…允许通过源代码 vendoring 重复构建”, 而且无需重新导入. (gb 的另一个动机是避免将代码存储在 GOPATH 中的特定目录中, 这对于许多开发人员的工作流程来说不太适合).</p><p>那年春天, Jason Buberel 对 Go 包管理进行了调查, 以了解可以采取什么措施来统一这些多重努力, 避免重复和浪费工作. 他的调查在 Go 团队中清楚地表明, go 命令需要直接支持 vendoring 而不是重写 import . 与此同时, Daniel Theophanes 开始了一个文件格式规范, 以描述 vendor 目录中确切的出处和代码版本. 2015 年 6 月, 我们接受 Keith 的提案作为 Go 1.5 vendor 实验方式, 在 Go 1.5 中可选, 并在 Go 1.6 中默认启用. 我们鼓励所有 vendoring 工具作者与 Daniel 合作采用单一元数据文件格式.</p><p>将 vendoring 概念纳入 Go 工具链允许程序分析工具如 go vet 使用 vendoring 更好地理解项目, 现在有十几个 Go 软件包管理器或 vendoring 工具来管理 vendor 目录. 另一方面, 因为这些工具都使用不同的元数据文件格式, 所以它们不能互操作, 并且不能轻松共享关于依赖需求的信息.</p><p>从根本上说, vendoring 是解决软件包版本问题的不完整方案. 它只提供可重复性构建. 它没有帮助理解软件包版本并决定使用哪个版本的软件包. 软件包管理器如 glide 和 dep 将版本控制的概念隐式地添加到 Go 中, 通过以某种方式设置 vendor 目录而无需直接的工具链支持. 因此, Go 生态系统中的许多工具无法正确识别版本. 很明显, Go 需要对软件包版本提供直接的工具链支持.</p><h3 id="官方包管理实验"><a href="#官方包管理实验" class="headerlink" title="官方包管理实验"></a>官方包管理实验</h3><p>在 2016 年 GopherCon 大会上, 一群有趣的 gophers 在 Hack Day (现在是 Community Day) 聚在一起, <a href="https://docs.google.com/document/d/1xMJ0c-YxvcgNglzjbALzncs5_Acr0MST29oMf9TkgQI/edit" target="_blank" rel="noopener">围绕 Go 包管理进行广泛的讨论</a>. 其中一个成果是成立了<a href="https://groups.google.com/d/msg/go-package-management/P8TehVoFLjg/Ni6VRyOjEAAJ" target="_blank" rel="noopener">一个委员会和一个包管理工作咨询小组</a>, 目标是为 Go 包管理创建一个新工具. 愿景是为了统一和取代现有的工具, 但它仍然在直接工具链之外使用 vendor 目录来实现.<br>由 Peter Bourgon 组织的委员会 Andrew Gerrand, Ed Muller, Jessie Frazelle 和 Sam Boyer 起草了一份<a href="https://docs.google.com/document/d/1qnmjwfMmvSCDaY4jxPmLAccaaUI5FfySNE90gB0pTKQ/edit" target="_blank" rel="noopener">规范</a>, 然后由 Sam 领导, 将其<a href="https://github.com/golang/dep" target="_blank" rel="noopener">实施为 dep</a>. 有关背景信息, 请参阅 Sam 的 2016 年 2 月发布的文章: “<a href="https://medium.com/@sdboyer/so-you-want-to-write-a-package-manager-4ae9c17d9527" target="_blank" rel="noopener">所以你想写一个包管理器</a>“, 他 2016 年 12 月发布的 “<a href="https://blog.gopheracademy.com/advent-2016/saga-go-dependency-management/" target="_blank" rel="noopener">Go 的依赖管理传奇</a>“ 和他 2017 年 7 月的 GopherCon 演讲 “<a href="https://www.youtube.com/watch?v=5LtMb090AZI" target="_blank" rel="noopener">Go包管理的新时代</a>“.</p><p>Dep 有许多用途: 它是对当前可用的实践的重要改进, 它是朝着解决方案迈出的重要一步, 也是一个实验 - 我们称之为 “官方实验” - 帮助我们更多地了解什么是对 Go 开发者友好的以及哪些不是. 但 dep 不是最终集成了包版本控制的 go 命令的直接原型. 它是一种强大的, 几乎任意灵活的方式来探索设计空间, 在构建 Go 程序时扮演像 makefiles 一样的角色. 但是, 一旦我们更好地理解设计空间并将其缩小到必须支持的几个关键特性, 它将帮助 Go 生态系统移除其他特性, 降低表现力, 采用强制性约定, 使 Go 代码库更加均匀并且更容易理解并使工具更易于构建.</p><p>这篇文章是 dep 之后下一步的开始: 最终 go 命令集成原型的初稿, 即 goinstall 的包管理的等价物. 原型是我们所称的独立命令 vgo. 它是 go 命令的直接替代品, 但它增加了对软件包版本控制的支持. 这是一个新的实验, 我们将看到我们可以从中学到什么. 就像我们介绍 goinstall 的那样, 当前一些代码和项目已经可以使用 vgo, 其他项目需要进行更改才能兼容. 我们将拿走一些控制和表现力, 就像我们拿走了 makefile 一样, 为简化系统和消除用户复杂性服务. 通常，我们正在寻找早期采用者来帮助我们进行实验 vgo, 以便我们尽可能地从用户那里学习.</p><p>开始尝试 vgo 并不意味着结束对 dep 的支持. 我们将保持 dep 可用, 直到完成 go 命令集成的路径被确定, 实施并且大体上可用. 我们也将尽可能顺利地完成从最终过渡 dep 到 go 命令集成的各种形式. 尚未转化到 dep 的项目仍然可以从中获益. (注意, <a href="https://github.com/tools/godep" target="_blank" rel="noopener">godep</a> 和 <a href="https://github.com/Masterminds/glide" target="_blank" rel="noopener">glide</a> 已经结束了活跃的开发, 鼓励迁移到 dep). 其他项目不妨直接迁移到 vgo, 如果它已满足需求.</p><h2 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h2><p>添加版本到 go 命令的提案有四个步骤. 首先, 采用 Go FAQ 和 gopkg.in 暗示的导入兼容性规则; 也就是说, 建立一个预期, 即具有给定导入路径的软件包的新版本应该与旧版本向后兼容. 其次, 使用简单的新算法(称为最小版本选择)来选择在给定构建中使用哪些版本. 第三, 引入 Go module 的概念, Go module 是一组版本为单个版本的软件包, 并声明了它们的依赖关系必须满足的最低要求. 第四, 定义如何将所有这些改造成现有的 go 命令, 以便基本的工作流程从今天不再发生显著变化. 本节的其余部分将介绍这些步骤中的每一个. 本周其他博客文章将更详细地介绍.</p><h3 id="导入-Import-兼容性规则"><a href="#导入-Import-兼容性规则" class="headerlink" title="导入 (Import) 兼容性规则"></a>导入 (Import) 兼容性规则</h3><p>包装管理系统中几乎所有的痛苦都是由于试图驯服不兼容而导致的. 例如, 大多数系统允许程序包 B 声明它需要程序包 D 6 或更高版本, 然后允许程序包 C 声明它需要D 2, 3 或 4, 但不是 5 或更高版本. 如果你正在编写软件包 A, 并且你想同时使用 B 和 C, 那么你运气不好: 没有一个 D 版本可以选择将 B 和 C 一起构建到 A 中. 你什么也做不了: 这些系统说 B 和 C 这样做是可以接受的 - 他们有效地鼓励它 - 所以就这样你被卡住了.</p><p>这个提案要求包作者遵循导入兼容性规则, 而不是设计一个不可避免导致大型程序无法构建的系统:</p><blockquote><p>如果旧软件包和新软件包具有相同的导入路径, 则新软件包必须与旧软件包向后兼容.</p></blockquote><p>这条规则是对前面引用的 Go FAQ 中的建议的重申. 常见问题引文最后说到: “如果需要完全的破坏兼容性, 请使用新的导入路径创建一个新包”. 今天的开发人员希望使用语义版本来表达这样一个破坏, 所以我们将语义版本集成到了我们的提案中. 具体来说, 主版本 2 和更高版本可以通过在路径中包含版本来使用, 如下所示:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;github.com/go-yaml/yaml/v2&quot;</span><br></pre></td></tr></table></figure><p>创建 v2.0.0, 在语义版本化中表示一个重大破坏, 因此按照导入兼容性的要求, 创建具有新导入路径的新包. 由于每个主要版本都有不同的导入路径, 因此给定的 Go 可执行文件可能包含每个主要版本中的一个. 这是预期的和可取的. 它保持程序的构建, 并允许一个非常大的程序部分独立地从 v1 更新到 v2.</p><p>期望包作者遵循导入兼容性规则, 可以避免尝试驯服不兼容性, 使整个系统指数级更简单, 并且软件包生态系统更少碎片化. 当然, 实际上, 尽管作者做出了最大的努力, 但在同一个主要版本中的更新偶尔会破坏用户使用. 因此, 使用升级速度不太快的升级机制很重要. 这将引领我们到下一步.</p><h3 id="最小版本选择"><a href="#最小版本选择" class="headerlink" title="最小版本选择"></a>最小版本选择</h3><p>今天几乎所有的软件包管理器, 包括 dep 和 cargo, 使用<a href="https://research.swtch.com/cargo-newest.html" target="_blank" rel="noopener">最新允许的版本</a>参与构建包. 我认为这是错误的违约, 有两个重要原因. 首先, “最新允许版本”的含义可能因外部事件而改变, 即新版本正在发布. 也许今晚有人会推出一些新版本的依赖项, 然后明天你再运行今天的相同命令序列会产生不同的结果. 其次，为了覆盖这个默认值, 开发人员花时间告诉包管理器 “不, 不要使用 X”, 然后包管理器花时间<a href="https://research.swtch.com/version-sat" target="_blank" rel="noopener">寻找一种不使用 X 的方法</a>.</p><p>这个提案采取了不同的方法, 我称之为最小版本选择. 它默认使用构建中涉及的每个包的最旧允许版本. 这个决定从今天到明天不会改变, 因为不会发布旧版本. 更好的是, 为了覆盖这个默认值，开发人员花时间告诉包管理器, “不, 至少使用 Y”, 然后包管理器可以轻松地决定使用哪个版本. 我称之为最小版本选择, 因为所选择的版本是最小的, 也因为整个系统也可能是最小的, 避免了现有系统的几乎所有复杂性.</p><p>最小版本选择允许模块仅指定其依赖模块的最低需求. 它为升级和降级操作提供了定义明确的独特答案, 并且这些操作的实施效率很高. 它还允许正在构建的整个模块的作者指定要排除的依赖项版本, 或者指定将特定的依赖项版本替换为本地文件系统中的 forked 副本或作为其自己的模块发布. 当模块被构建为其他模块的依赖项时, 这些排除和替换不适用. 这使用户可以完全控制自己的程序的构建方式, 而不是其他人的程序构建方式.</p><p>最小版本选择默认提供可重复的版本, 无需锁定文件.</p><p>导入兼容性是简化版本选择的关键. 用户不会说 “不, 这太新了”, 他们只会说 “不, 这太旧了”. 在这种情况下, 解决方案很明确: 使用(最低限度)更新的版本. 新版本同意成为老版本的可接受替代品.</p><h3 id="定义-Go-模块"><a href="#定义-Go-模块" class="headerlink" title="定义 Go 模块"></a>定义 Go 模块</h3><p>Go 模块是一组共享公共导入路径前缀的软件包, 称为模块路径. 该模块是版本控制的单元, 模块版本被编写为语义版本字符串. 在开发使用 Git 时, 开发人员将通过向模块的 Git 仓库添加标签(tag)来定义模块的新语义版本. 尽管强烈推荐使用语义版本, 但也支持引用特定的提交(commits).</p><p>一个模块在一个称作 go.mod 的新文件中定义了它所依赖的其他模块的最低版本要求. 例如, 这里是一个简单的 go.mod 文件:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// My hello, world.</span><br><span class="line"></span><br><span class="line">module &quot;rsc.io/hello&quot;</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">&quot;golang.org/x/text&quot; v0.0.0-20180208041248-4e4a3210bb54</span><br><span class="line">&quot;rsc.io/quote&quot; v1.5.2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>该文件定义了一个由路径标识的模块, 该模块 rsc.io/hello 本身依赖于另外两个模块: golang.org/x/text 和 rsc.io/quote. 模块本身的构建将始终使用 go.mod 文件中列出的特定版本的必需依赖项. 作为更大构建的一部分, 如果构建中的其他地方需要它, 它将只使用更新的版本.</p><p>期望包作者使用语义版本标记(tag)发布, vgo 鼓励使用标记版本, 而不是任意提交. rsc.io/quote 模块服务于 github.com/rsc/quote, 已经标记了版本, 包括 v1.5.2. 但是 golang.org/x/text 模块尚未提供标签版本. 要命名未标记的提交, 伪版本 v0.0.0-yyyymmddhhmmss-commit 标识在给定日期进行的特定提交. 在语义版本控制中, 这个字符串对应于一个 v0.0.0 预发行版, 预发行版标识符为 yyyymmddhhmmss - commit. 语义版本优先规则在 v0.0.0 或更高版本之前排序此类预发布, 并且它们通过字符串比较来排序预发布. 在伪版本语法中放置日期在前可确保字符串比较匹配日期比较.</p><p>除了 requirements 之外, go.mod 文件还可以指定上一节中提到的排除 (exclusions) 和替换 (replacements), 但这些仅在直接构建模块时才应用, 而不是在作为较大程序的一部分构建模块时应用. 这些<a href="https://research.swtch.com/vgo-tour" target="_blank" rel="noopener">例子</a>演示了所有这些.</p><p>Goinstall 和旧的 go get 直接调用版本控制工具, 如 git 和 hg 直接下载代码, 导致许多问题, 其中包括碎片化. 例如, 用户没有 bzr 无法下载存储在 Bazaar 仓库中的代码. 相比之下, 模块始终下载通过 HTTP 提供的 zip 归档文件. 之前, go get 有特殊外壳为流行代码托管站点选择版本控制命令. 现在, vgo 有特殊外壳可以使用这些托管站点的 API 来获取档案.</p><p>将模块统一表示为 zip 压缩文件可以实现模块下载代理的简单协议和实现. 公司或个人可以出于任何原因运行代理, 包括安全性, 并希望能够在删除原始文件的情况下从缓存副本进行工作. 通过使用代理来确保可用性, 在 go.mod 中定义要使用的代码, vendor 目录不再需要.</p><h3 id="go-命令"><a href="#go-命令" class="headerlink" title="go 命令"></a>go 命令</h3><p>go 命令必须更新以使用模块. 一个显著的变化是, 普通的构建命令, 如 go build, go install, go run 和 go test, 将按需解决新依赖, 只需要使用 golang.org/x/text 全新的模块增加导入到 Go 源代码并且构建代码.</p><p>但是, 最重要的变化是 GOPATH 作为 Go 代码工作的必需位置的结束. 因为该 go.mod 文件包含完整的模块路径, 并且还定义了正在使用的每个依赖项的版本, 所以带有 go.mod 文件的目录会将目录树的根标记为独立的工作空间, 与其他任何此类目录分开. 现在你只是 git clone, cd, 开始写. 无处不可. 不需要 GOPATH.</p><h2 id="接下来"><a href="#接下来" class="headerlink" title="接下来"></a>接下来</h2><p>我还发布了 “<a href="https://research.swtch.com/vgo" target="_blank" rel="noopener">A Tour of Versioned Go</a>“ 来展示 vgo 的使用方式. 看这篇文章, 了解如何下载和实验 vgo. 我会在整个一周发布更多信息, 以添加我在本文中跳过的详细信息. 我鼓励对这个帖子和其他人的评论发表意见, 我也会试着去看看 Go subreddit 和 golang-nuts 邮件列表. 周五, 我将发布 FAQ 作为系列文章的最后一篇博文(至少现在). 下周我会提交一份正式的 Go 提案.</p><p>请尝试 <a href="https://research.swtch.com/vgo-tour" target="_blank" rel="noopener">vgo</a>. 在存储库中开始标记版本. 创建并签入 go.mod 文件. 请注意, 如果运行的是一个包含空的 go.mod 的仓库, 但是, 它有一个现成的 dep, glide, glock, godep, godeps, govend, govendor 或 gvt 配置文件, vgo 将用它来填充 go.mod 文件.</p><p>我为 Go 添加版本到它的工作词汇中这一姗姗来迟的一步感到兴奋. 开发者在使用 Go 时遇到的一些最常见的问题是缺乏可重复的构建, go get 完全忽略发布标签, GOPATH 无法理解包的多个版本以及想要或需要在 GOPATH 之外的源目录中工作. 这里提出的设计消除了所有这些问题, 以及更多.</p><p>即便如此, 我确定有些细节是错误的. 我希望我们的用户能够通过尝试新的 vgo 原型并参与富有成效的讨论来帮助我们实现这一设计. 我希望 Go 1.11 为 Go 模块提供初步支持, 作为一种技术预览, 然后我希望 Go 1.12 能够提供官方支持. 在稍后的一些版本中, 我们将删除对旧的无版本的 go get 支持. 不过, 这是一个激进的时间表, 如果获得正确的功能意味着等待以后的发布, 我们会.</p><p>我非常关心从旧的 go get 和无数的 vendoring 工具到新的模块系统的过渡. 对于我来说, 这个过程就和获得正确的功能同样重要. 如果成功的转换意味着等待以后的发布, 我们会.</p><p>感谢 Peter Bourgon, Jess Frazelle, Andrew Gerrand 和 Ed Mueller 以及 Sam Boyer 在包管理委员会的工作以及去年的许多有益讨论. 还要感谢 Dave Cheney, Gustavo Niemeyer, Keith Rarick 和 Daniel Theophanes 对 Go 和包版本的关键贡献. 再次感谢 Sam Boyer 创造 dep, 并感谢他和 dep 的所有贡献者. 感谢所有曾经在许多早期的 vendoring 工具上创建或工作过的人. 最后, 感谢所有能够帮助我们推进此提案的人, 找到并解决问题, 并尽可能顺利地将软件包版本控制添加到 Go.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
            <tag> vgo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>开发者关系权利法案</title>
      <link href="/post/a-developer-relations-bill-of-rights.html"/>
      <url>/post/a-developer-relations-bill-of-rights.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自 <a href="https://medium.com/glitch/a-developer-relations-bill-of-rights-21381920e273" target="_blank" rel="noopener">A Developer Relations Bill of Rights</a> 版权@归原文所有.<br><a id="more"></a><p></p><p>开发者关系是任何希望建立成功的技术平台的公司中最具战略意义的角色之一. 然而, 大多数公司缩短了他们的 Dev Rel (译注: 开发者关系) 团队, 并危及他们在这项关键工作中的投资.</p><p><a href="/static/images/1_-GNpo5PEhPm-1Ns4F76t9w.png" class="gallery-item"><img src="/static/images/1_-GNpo5PEhPm-1Ns4F76t9w.png" width="1000" height="523"></a></p><p>十七年前, Joel Spolsky 写了 <a href="https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/" target="_blank" rel="noopener">Joel Test</a>, 这个广泛的框架主张赋予开发者权力并投资于他们的工作. 即使这些想法已经演变或者具体规则变得有点过时, 基本原则已经相当成熟, 并且帮助科技行业提高了生产力. Joel Test 是代表制造软件的人所提倡的最有效的努力之一.</p><p>本着同样的精神, 我们提出了另一个开始点来讨论如何支持一个较新的, 较少承认的, 但同样重要的社区: 开发者关系. 无论它被称为开发者福音主义, 开发者体验, Dev Rel, 还是其他任何名字, 该领域都包含一系列相关的战略性关键角色. 社区包括具有实际开发者关系头衔的人员, 以及开发者主张者, 平台或产品布道者或开发者支持等头衔.</p><blockquote><p>无论我们如何描述自己, Dev Rel 的工作对于任何为其生态系统提供技术平台的公司都是至关重要的.</p></blockquote><p>然而, 尽管 Dev Rel 如此重要, 正如我们在 <a href="https://medium.com/glitch/its-time-to-get-serious-about-developer-relations-af238c002b31" target="_blank" rel="noopener">是时候认真对待开发者关系</a> 中所说的那样, <strong>但大多数公司从根本上没有向 Dev Rel 展示它应有的尊重</strong>. 我们已经看到来自社区人士的有价值的努力, 如 Ashley McNamara 开始编纂应支持有效的开发者关系的<a href="https://hackernoon.com/the-best-career-advice-ive-received-so-far-is-never-turn-down-an-interview-7586ca5b7ef8" target="_blank" rel="noopener">原则</a>. 当然, 就我们自己而言, 我们已经建立了像 Glitch 这样的社区, 其具体目标是成为 <a href="https://glitch.com/forplatforms" target="_blank" rel="noopener">Dev Rel 的重要工具</a>.</p><p>在这项工作的基础上, 并希望开始改变大多数公司不支持 Dev Rel 的现实, 下面是 Dev Rel 权利法案的第一稿. 我们渴望听到您对其变更和改进的建议.</p><h3 id="Dev-Rel-权利法案"><a href="#Dev-Rel-权利法案" class="headerlink" title="Dev Rel 权利法案"></a>Dev Rel 权利法案</h3><p>为开发者关系工作的每个人都应该得到遵循这 10 条原则的环境的支持:</p><ol><li><p><a href="https://medium.com/glitch/every-dev-rel-professional-deserves-a-clear-set-of-business-goals-f91e1a558046" target="_blank" rel="noopener">一套明确的商业目标</a></p></li><li><p><a href="https://medium.com/glitch/dev-rel-requires-a-well-defined-place-in-the-organization-288ee75b8b1e" target="_blank" rel="noopener">组织中一个明确的地方</a></p></li><li><p><a href="https://medium.com/glitch/a-structured-way-to-impact-product-or-platform-f5a7c5648ac4" target="_blank" rel="noopener">影响产品或平台的结构化方式</a></p></li><li><p><a href="https://medium.com/glitch/dev-rel-needs-open-lines-of-communication-to-marketing-960faf2c0023" target="_blank" rel="noopener">向市场开放沟通渠道</a></p></li><li><p><a href="https://medium.com/glitch/dev-rel-needs-the-right-tools-specifically-designed-for-the-job-af858d770b8a" target="_blank" rel="noopener">专为这项工作设计的正确工具</a></p></li><li><p><a href="https://medium.com/glitch/dev-rel-requires-explicit-ethical-and-social-guidelines-9c67b3d2356c" target="_blank" rel="noopener">明确的道德和社会准则</a></p></li><li><p><a href="https://medium.com/glitch/dev-rel-deserves-support-for-building-inclusive-communities-5a7779543cd" target="_blank" rel="noopener">支持建设包容性社区</a></p></li><li><p><a href="https://medium.com/glitch/dev-rel-must-be-provided-with-a-clear-distinction-from-sales-engineering-3ba17a4cda4f" target="_blank" rel="noopener"><strong>与销售工程的明显区别</strong></a></p></li><li><p><a href="https://medium.com/glitch/dev-rel-must-be-supported-with-ongoing-investment-in-professional-development-19ba90326b7a" target="_blank" rel="noopener">持续的专业发展资源</a></p></li><li><p><a href="https://medium.com/glitch/dev-rel-success-requires-an-ongoing-connection-to-a-community-of-peers-ed660b40b62" target="_blank" rel="noopener">连接到同行社区</a></p></li></ol><p>我们将深入探讨这些关键概念的愿景, 这些概念使 Dev Rel 获得成功, <strong>但我们希望听到社区中关心开发者关系的未来的每个人的意见</strong>. 我们确信 Dev Rel 中的每个人都可以想到我们错过的一个区域, 或者您在职业生涯中遇到的一个特别的痛点.</p><p>我们相信, 我们有信心能够争取为 Dev Rel 获得投资, 资源, 支持和战略重点, 从而推动行业向前发展.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> software development </tag>
            
            <tag> translation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go JSON 技巧</title>
      <link href="/post/json-tips-in-go.html"/>
      <url>/post/json-tips-in-go.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">相对于很多的语言来说, Go 的 JSON 解析可谓简单至极.<br><a id="more"></a><p></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>通常情况下, 我们在 Go 中经常这样进行 JSON 的解码:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"encoding/json"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// jsonText comes from http://json.org/example.html</span></span><br><span class="line"><span class="keyword">var</span> jsonText = []<span class="keyword">byte</span>(<span class="string">`</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">   "glossary":&#123;</span></span><br><span class="line"><span class="string">      "title":"example glossary",</span></span><br><span class="line"><span class="string">      "GlossDiv":&#123;</span></span><br><span class="line"><span class="string">         "title":"S",</span></span><br><span class="line"><span class="string">         "GlossList":&#123;</span></span><br><span class="line"><span class="string">            "GlossEntry":&#123;</span></span><br><span class="line"><span class="string">               "ID":"SGML",</span></span><br><span class="line"><span class="string">               "SortAs":"SGML",</span></span><br><span class="line"><span class="string">               "GlossTerm":"Standard Generalized Markup Language",</span></span><br><span class="line"><span class="string">               "Acronym":"SGML",</span></span><br><span class="line"><span class="string">               "Abbrev":"ISO 8879:1986",</span></span><br><span class="line"><span class="string">               "GlossDef":&#123;</span></span><br><span class="line"><span class="string">                  "para":"A meta-markup language, used to create markup languages such as DocBook.",</span></span><br><span class="line"><span class="string">                  "GlossSeeAlso":[</span></span><br><span class="line"><span class="string">                     "GML",</span></span><br><span class="line"><span class="string">                     "XML"</span></span><br><span class="line"><span class="string">                  ]</span></span><br><span class="line"><span class="string">               &#125;,</span></span><br><span class="line"><span class="string">               "GlossSee":"markup"</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">         &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;`</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> glossary <span class="keyword">struct</span> &#123;</span><br><span class="line">Glossary <span class="keyword">struct</span> &#123;</span><br><span class="line">Title    <span class="keyword">string</span> <span class="string">`json:"title"`</span></span><br><span class="line">GlossDiv <span class="keyword">struct</span> &#123;</span><br><span class="line">Title     <span class="keyword">string</span> <span class="string">`json:"title"`</span></span><br><span class="line">GlossList <span class="keyword">struct</span> &#123;</span><br><span class="line">GlossEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">ID        <span class="keyword">string</span> <span class="string">`json:"ID"`</span></span><br><span class="line">SortAs    <span class="keyword">string</span> <span class="string">`json:"SortAs"`</span></span><br><span class="line">GlossTerm <span class="keyword">string</span> <span class="string">`json:"GlossTerm"`</span></span><br><span class="line">Acronym   <span class="keyword">string</span> <span class="string">`json:"Acronym"`</span></span><br><span class="line">Abbrev    <span class="keyword">string</span> <span class="string">`json:"Abbrev"`</span></span><br><span class="line">GlossDef  <span class="keyword">struct</span> &#123;</span><br><span class="line">Para         <span class="keyword">string</span>   <span class="string">`json:"para"`</span></span><br><span class="line">GlossSeeAlso []<span class="keyword">string</span> <span class="string">`json:"GlossSeeAlso"`</span></span><br><span class="line">&#125; <span class="string">`json:"GlossDef"`</span></span><br><span class="line">GlossSee <span class="keyword">string</span> <span class="string">`json:"GlossSee"`</span></span><br><span class="line">&#125; <span class="string">`json:"GlossEntry"`</span></span><br><span class="line">&#125; <span class="string">`json:"GlossList"`</span></span><br><span class="line">&#125; <span class="string">`json:"GlossDiv"`</span></span><br><span class="line">&#125; <span class="string">`json:"glossary"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> g glossary</span><br><span class="line">json.Unmarshal(jsonText, &amp;g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的解码对于我们日常使用好像也没什么问题, 起码能用 ? 对于一段 JSON, 我们解码的时候未必需要立即解码所有的部分, 什么意思呢 ?</p><p>拿上面的例子代码来说, 我们解码 jsonText , 可能仅需要马上使用 Title 和 GlossDiv.Title . 那么对于这种情况我们怎么做合适呢 ?</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"encoding/json"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// jsonText comes from http://json.org/example.html</span></span><br><span class="line"><span class="keyword">var</span> jsonText = []<span class="keyword">byte</span>(<span class="string">`</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">   ... // 此处省略, 同上</span></span><br><span class="line"><span class="string">&#125;`</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> glossarySectional <span class="keyword">struct</span> &#123;</span><br><span class="line">Glossary <span class="keyword">struct</span> &#123;</span><br><span class="line">Title    <span class="keyword">string</span> <span class="string">`json:"title"`</span></span><br><span class="line">GlossDiv <span class="keyword">struct</span> &#123;</span><br><span class="line">Title     <span class="keyword">string</span>          <span class="string">`json:"title"`</span></span><br><span class="line">GlossList json.RawMessage <span class="string">`json:"GlossList"`</span> <span class="comment">// diff: delay JSON decoding</span></span><br><span class="line">&#125; <span class="string">`json:"GlossDiv"`</span></span><br><span class="line">&#125; <span class="string">`json:"glossary"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> g glossarySectional</span><br><span class="line">json.Unmarshal(jsonText, &amp;g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错, 魔法就在 GlossList json.RawMessage . 我们看相关<a href="https://golang.org/pkg/encoding/json/#RawMessage" target="_blank" rel="noopener">文档</a>怎么说:</p><blockquote><p>RawMessage is a raw encoded JSON value. It implements Marshaler and Unmarshaler and can be used to delay JSON decoding or precompute a JSON encoding.</p></blockquote><p>一目了然, RawMessage 起到了延迟解码一个 JSON 值的作用. 那么你可能会说, 这有啥用呢 ?</p><p>这对于普通的解码可能问题不大, 但是对于一些像消息传递(Kafka 这种), 细微的延迟可能会造成很大的影响. 我们可以通过简单的 benchmark 测试一下这细微的差别:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其他代码略 ... 完整代码参见: http://bit.ly/2skxY9L .</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmarkJSONUnmarshal</span><span class="params">(f <span class="keyword">func</span>()</span>, <span class="title">b</span> *<span class="title">testing</span>.<span class="title">B</span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkJSONUnmarshal_0</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">benchmarkJSONUnmarshal(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> g glossary</span><br><span class="line">json.Unmarshal(jsonText, &amp;g)</span><br><span class="line">&#125;, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkJSONUnmarshal_1</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">benchmarkJSONUnmarshal(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> g glossarySectional</span><br><span class="line">json.Unmarshal(jsonText, &amp;g)</span><br><span class="line">&#125;, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过运行 go test -run=NONE -bench=. ./… 可以得出(不同环境有略微差别):</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BenchmarkJSONUnmarshal_0-8     200000     10565 ns/op</span><br><span class="line">BenchmarkJSONUnmarshal_1-8     200000      7699 ns/op</span><br></pre></td></tr></table></figure><p>差别幅度:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">benchmark                    old ns/op     new ns/op     delta</span><br><span class="line">BenchmarkJSONUnmarshal-8     10298         7591          -26.29%</span><br></pre></td></tr></table></figure><p>可以看得出这个差别还是很大的, 特别是当 JSON 本身体量很大的时候.</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>对于一些关乎性能的 JSON 解析的处理, 我们可以通过 json.RawMessage 进行性能的提升.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go 函数选项模式</title>
      <link href="/post/functional-options-pattern-in-go.html"/>
      <url>/post/functional-options-pattern-in-go.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自 <a href="https://halls-of-valhalla.org/beta/articles/functional-options-pattern-in-go,54/" target="_blank" rel="noopener">Functional Options Pattern in Go</a> 版权@归原文所有.<br><a id="more"></a><p></p><p>Golang 开发者遇到的许多问题之一是尝试将一个函数的参数设置为可选. 这是一个非常常见的用例, 有些对象应该使用一些基本的默认设置来开箱即用, 并且你偶尔可能需要提供一些更详细的配置.</p><p>在很多语言中这很容易; 在 C 族语言中, 可以使用不同数量的参数提供相同函数的多个版本; 在像 PHP 这样的语言中, 可以给参数一个默认值，并在调用方法时忽略它们. 但是在 Golang 中, 这两种方式你哪个也用不了. 那么你如何创建一个函数, 用户可以指定一些额外的配置?</p><p>有很多可能的方法可以做到这一点, 但是大多数都不能满足要求, 或者需要在服务端的代码中进行额外的检查和验证, 或者通过传递额外的客户端不关心的参数来为客户端做额外的工作.</p><p>我将介绍一些不同的方案, 并说明为什么每个都不是最理想的, 然后我们将建立我们自己的方式来作为最终干净的解决方案: 函数式选项模式 (Functional Options Pattern).</p><p>我们来看一个例子. 比方说, 我们有一些名为 StuffClient 的服务, 它有一些东西, 并有两个配置选项(timeout 和 retries):</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StuffClient <span class="keyword">interface</span> &#123;</span><br><span class="line">    DoStuff() error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> stuffClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    conn    Connection</span><br><span class="line">    timeout <span class="keyword">int</span></span><br><span class="line">    retries <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体 stuffClient 是私有的, 所以我们应该为它提供一些构造器:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStuffClient</span><span class="params">(conn Connection, timeout, retries <span class="keyword">int</span>)</span> <span class="title">StuffClient</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;stuffClient&#123;</span><br><span class="line">        conn:    conn,</span><br><span class="line">        timeout: timeout,</span><br><span class="line">        retries: retries,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯, 但是现在我们每次调用 NewStuffClient 时都要提供 timeout 和 retries. 而大多数时候我们只想使用默认值. 我们不能用不同的参数数量来定义多个版本的 NewStuffClient, 否则我们会得到一个类似 “NewStuffClient redeclared in this blockt” 的编译错误.</p><p>一个方案是创建另一个不同名称的构造器:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStuffClient</span><span class="params">(conn Connection)</span> <span class="title">StuffClient</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;stuffClient&#123;</span><br><span class="line">        conn:    conn,</span><br><span class="line">        timeout: DEFAULT_TIMEOUT,</span><br><span class="line">        retries: DEFAULT_RETRIES,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStuffClientWithOptions</span><span class="params">(conn Connection, timeout, retries <span class="keyword">int</span>)</span> <span class="title">StuffClient</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;stuffClient&#123;</span><br><span class="line">        conn:    conn,</span><br><span class="line">        timeout: timeout,</span><br><span class="line">        retries: retries,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是, 这有点蹩脚. 我们可以做得比这更好. 如果我们传入了一个配置对象呢:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StuffClientOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    Retries <span class="keyword">int</span> <span class="comment">//number of times to retry the request before giving up</span></span><br><span class="line">    Timeout <span class="keyword">int</span> <span class="comment">//connection timeout in seconds</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStuffClient</span><span class="params">(conn Connection, options StuffClientOptions)</span> <span class="title">StuffClient</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;stuffClient&#123;</span><br><span class="line">        conn:    conn,</span><br><span class="line">        timeout: options.Timeout,</span><br><span class="line">        retries: options.Retries,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是, 这也不是很好. 现在我们总是需要创建 StuffClientOptions, 并且即使我们不想指定任何选项也要传递它. 而且我们也没有自动填充默认值, 除非我们在代码中添加了一堆检查, 或者我们可以传入一个 DefaultStuffClientOptions 变量 (也不好, 因为它可以在一个地方修改导致其他地方有问题).</p><p>那么解决方案是什么? 解决这个难题最好的方法是使用函数式选项模式, 利用 Go 对闭包的方便支持. 让我们继续我们上面定义的 StuffClientOptions, 但是我们会添加一些东西:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StuffClientOption <span class="function"><span class="keyword">func</span><span class="params">(*StuffClientOptions)</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">StuffClientOptions</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">    Retries <span class="keyword">int</span> <span class="comment">//number of times to retry the request before giving up</span></span><br><span class="line">    Timeout <span class="keyword">int</span> <span class="comment">//connection timeout in seconds</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithRetries</span><span class="params">(r <span class="keyword">int</span>)</span> <span class="title">StuffClientOption</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *StuffClientOptions)</span></span> &#123;</span><br><span class="line">        o.Retries = r</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(t <span class="keyword">int</span>)</span> <span class="title">StuffClientOption</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *StuffClientOptions)</span></span> &#123;</span><br><span class="line">        o.Timeout = t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泥土般芬芳, 对吧? 究竟发生了什么? 基本上我们有我们的结构定义我们的 StuffClient 的可用选项. 另外现在我们定义了一个名为 StuffClientOption 的东东(这次是单数), 它只是一个接受我们的选项 struct 作为参数的函数. 我们已经定义了另外一些函数 WithRetries 和 WithTimeout, 它们返回一个闭包. 现在魔法降临:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultStuffClientOptions = StuffClientOptions&#123;</span><br><span class="line">    Retries: <span class="number">3</span>,</span><br><span class="line">    Timeout: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStuffClient</span><span class="params">(conn Connection, opts ...StuffClientOption)</span> <span class="title">StuffClient</span></span> &#123;</span><br><span class="line">    options := defaultStuffClientOptions</span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">        o(&amp;options)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;stuffClient&#123;</span><br><span class="line">        conn:    conn,</span><br><span class="line">        timeout: options.Timeout,</span><br><span class="line">        retries: options.Retries,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经定义了一个额外的未导出(unexposed)变量, 包含我们的默认选项, 我们现在调整了我们的构造函数, 而不是接受一个可变参数. 然后, 我们遍历 StuffClientOption (单数) 列表, 并对每一项应用返回的闭包到我们的选项变量.</p><p>现在我们要做的就是这样:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := NewStuffClient(Connection&#123;&#125;)</span><br><span class="line">fmt.Println(x) <span class="comment">// prints &amp;&#123;&#123;&#125; 2 3&#125;</span></span><br><span class="line">x = NewStuffClient(</span><br><span class="line">    Connection&#123;&#125;,</span><br><span class="line">    WithRetries(<span class="number">1</span>),</span><br><span class="line">)</span><br><span class="line">fmt.Println(x) <span class="comment">// prints &amp;&#123;&#123;&#125; 2 1&#125;</span></span><br><span class="line">x = NewStuffClient(</span><br><span class="line">    Connection&#123;&#125;,</span><br><span class="line">    WithRetries(<span class="number">1</span>),</span><br><span class="line">    WithTimeout(<span class="number">1</span>),</span><br><span class="line">)</span><br><span class="line">fmt.Println(x) <span class="comment">// prints &amp;&#123;&#123;&#125; 1 1&#125;</span></span><br></pre></td></tr></table></figure><p>这看起来相当不错而且可用. 而关于它的好的部分是, 我们可以随时添加新的选项, 只需要对代码进行非常少量的更改. 把这些都组合起来就是这样:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultStuffClientOptions = StuffClientOptions&#123;</span><br><span class="line">    Retries: <span class="number">3</span>,</span><br><span class="line">    Timeout: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> StuffClientOption <span class="function"><span class="keyword">func</span><span class="params">(*StuffClientOptions)</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">StuffClientOptions</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">    Retries <span class="keyword">int</span> <span class="comment">//number of times to retry the request before giving up</span></span><br><span class="line">    Timeout <span class="keyword">int</span> <span class="comment">//connection timeout in seconds</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithRetries</span><span class="params">(r <span class="keyword">int</span>)</span> <span class="title">StuffClientOption</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *StuffClientOptions)</span></span> &#123;</span><br><span class="line">        o.Retries = r</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(t <span class="keyword">int</span>)</span> <span class="title">StuffClientOption</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *StuffClientOptions)</span></span> &#123;</span><br><span class="line">        o.Timeout = t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> StuffClient <span class="keyword">interface</span> &#123;</span><br><span class="line">    DoStuff() error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> stuffClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    conn    Connection</span><br><span class="line">    timeout <span class="keyword">int</span></span><br><span class="line">    retries <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Connection <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStuffClient</span><span class="params">(conn Connection, opts ...StuffClientOption)</span> <span class="title">StuffClient</span></span> &#123;</span><br><span class="line">    options := defaultStuffClientOptions</span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">        o(&amp;options)</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> &amp;stuffClient&#123;</span><br><span class="line">            conn:    conn,</span><br><span class="line">            timeout: options.Timeout,</span><br><span class="line">            retries: options.Retries,</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c stuffClient)</span> <span class="title">DoStuff</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想自己尝试一下, 去 <a href="https://play.golang.org/p/VcWqWcAEyz" target="_blank" rel="noopener">Go Playground</a> 吧.</p><p>但是可以通过删除 StuffClientOptions 结构并直接将选项应用到我们的 StuffClient 来进一步简化.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultStuffClient = stuffClient&#123;</span><br><span class="line">    retries: <span class="number">3</span>,</span><br><span class="line">    timeout: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> StuffClientOption <span class="function"><span class="keyword">func</span><span class="params">(*stuffClient)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithRetries</span><span class="params">(r <span class="keyword">int</span>)</span> <span class="title">StuffClientOption</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *stuffClient)</span></span> &#123;</span><br><span class="line">        o.retries = r</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(t <span class="keyword">int</span>)</span> <span class="title">StuffClientOption</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *stuffClient)</span></span> &#123;</span><br><span class="line">        o.timeout = t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> StuffClient <span class="keyword">interface</span> &#123;</span><br><span class="line">    DoStuff() error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> stuffClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    conn    Connection</span><br><span class="line">    timeout <span class="keyword">int</span></span><br><span class="line">    retries <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Connection <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStuffClient</span><span class="params">(conn Connection, opts ...StuffClientOption)</span> <span class="title">StuffClient</span></span> &#123;</span><br><span class="line">    client := defaultStuffClient</span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">        o(&amp;client)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client.conn = conn</span><br><span class="line">    <span class="keyword">return</span> client</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c stuffClient)</span> <span class="title">DoStuff</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在<a href="https://play.golang.org/p/Z5P5Om4KDL" target="_blank" rel="noopener">这里</a>尝试一下. 在我们的示例中, 我们只是直接将配置应用到我们的结构中, 在中间有一个额外的配置结构是没有意义的. 但是请注意, 在许多情况下, 您可能仍然想使用前面示例中的 config 结构体; 例如, 如果你的构造器使用配置选项来执行一些操作, 但不把它们存储到结构中, 或者传递到其他地方. 配置结构变体是更通用的实现.</p><p>感谢 Rob Pike 和 Dave Cheney 推广这种设计模式.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go work-stealing 调度器</title>
      <link href="/post/gos-work-stealing-scheduler.html"/>
      <url>/post/gos-work-stealing-scheduler.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自 Rakyll 的 <a href="https://rakyll.org/scheduler/" target="_blank" rel="noopener">scheduler</a> 版权@归原文所有.<br><a id="more"></a><p></p><p>Go 调度器的工作是将可运行的 goroutine 分发到一个或多个处理器上运行的多个操作系统工作线程. 在多线程计算里, 调度出现了两种模式: work-sharing (工作共享) 和 work-stealing (工作窃取).</p><ul><li><strong>work-sharing</strong> 当一个处理器产生新的线程时, 它试图将其中的一些迁移到其他处理器上, 希望它们能被空闲或未充分利用的处理器所利用.</li><li><strong>work-stealing</strong> 未充分利用的处理器会主动去寻找其他处理器的线程并窃取一些.</li></ul><p>work-stealing 中线程迁移的频率少于 work-sharing. 当所有处理器都有工作要运行时, 没有线程会被迁移. 而一旦有空闲的处理器, 就会考虑迁移.</p><p>Go 从 1.1 开始就有一个 work-stealing 的调度器, 由 <a href="https://github.com/dvyukov" target="_blank" rel="noopener">Dmitry Vyukov</a> 贡献. 本文将深入解释什么是 work-stealing 调度器, 以及 Go 如何实现它.</p><h3 id="调度基础"><a href="#调度基础" class="headerlink" title="调度基础"></a>调度基础</h3><p>Go 有一个可以利用多核处理器的 M:N 调度器. 任何时候, M 个 goroutine 都需要在 N 个 OS 线程上进行调度, 这些线程运行在最多 GOMAXPROCS 数量的处理器上. Go 调度器使用以下术语解释 goroutine, 线程以及处理器:</p><ul><li>G: goroutine</li><li>M: OS 线程 (机器)</li><li>P: 处理器 (译者: 此处不是指 CPU, 可以认为是 Go 调度上下文或调度处理器, 所以下文的处理器如无特别说明都是指 P)</li></ul><p>有一个 P 相关的本地和全局 goroutine 队列. 每个 M 应该被分配给一个 P. 如果被阻塞或者在系统调用中, P (们) 可能没有 M (们). 任何时候，最多只有 GOMAXPROCS 数量的 P. 任何时候, 每个 P 只能有一个 M 运行. 如果需要, 更多的 M (们) 可以由调度器创建.</p><p><a href="/static/images/scheduler-concepts.png" class="gallery-item"><img src="/static/images/scheduler-concepts.png" width="782" height="358"></a></p><p>每轮调度只是简单找到一个可运行的 goroutine 并执行它. 在每轮调度中, 搜索按以下顺序进行:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">runtime.schedule() &#123;</span><br><span class="line">    <span class="comment">// only 1/61 of the time, check the global runnable queue for a G. 仅 1/61 的时间, 检查全局运行队列里面的 G.</span></span><br><span class="line">    <span class="comment">// if not found, check the local queue. 如果没找到, 检查本地队列.</span></span><br><span class="line">    <span class="comment">// if not found, 还是没找到 ?</span></span><br><span class="line">    <span class="comment">//     try to steal from other Ps. 尝试从其他 P 偷.</span></span><br><span class="line">    <span class="comment">//     if not, check the global runnable queue. 还是没有, 检查全局运行队列.</span></span><br><span class="line">    <span class="comment">//     if not found, poll network. 还是没有, 轮询网络.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦找到可运行的 G, 它会一直执行直到被阻塞.</p><p><strong>注意</strong> 看起来好像全局队列比本地队列有优势, 但是偶尔检查全局队列是至关重要的, 以避免 M 只是从本地队列调度, 直到没有本地排队的 goroutine 留下.</p><h3 id="Stealing-窃取"><a href="#Stealing-窃取" class="headerlink" title="Stealing (窃取)"></a>Stealing (窃取)</h3><p>当一个新的 G 被创建或者一个现有的 G 变成可运行的时候, 它被压入当前 P 的可运行的 goroutine 列表. 当 P 完成 G 时, 它会尝试从自己的可运行 goroutine 列表中弹出一个 G. 如果列表现在是空的, P 会随机的选择其他的 P, 并尝试从其队列中偷取一半可运行的 goroutine(s).</p><p><a href="/static/images/scheduler-stealing.png" class="gallery-item"><img src="/static/images/scheduler-stealing.png" width="782" height="409"></a></p><p>在上面的例子中, P2 找不到任何可运行的 goroutine. 因此, 它随机选择另一个 P1, 并将其三个 goroutine(s) 窃取到自己的本地队列中. P2 将能够运行这些 goroutine, 并且调度器的工作会在多个处理器之间更加公平地分配.</p><h3 id="自旋线程-Spinning-threads"><a href="#自旋线程-Spinning-threads" class="headerlink" title="自旋线程 (Spinning threads)"></a>自旋线程 (Spinning threads)</h3><p>调度器总是希望将尽可能多的可运行的 goroutine(s) 分配给 M (们) 来利用处理器, 但是同时我们需要停留过多的工作来节省 CPU 和电力. 与此相矛盾的是, 调度器还需要能够扩展到高吞吐量和 CPU 密集型的程序. 如果性能是至关重要的, 那么对高吞吐量程序来说持续抢占既是昂贵又是有问题的. 操作系统线程不应该频繁地在 goroutine(s) 之间切换, 因为这会增加延迟. 除此之外, 在发生系统调用的时候, 操作系统线程需要不断地被阻塞和解除阻塞. 这是昂贵的, 并增加了很多开销.</p><p>为了尽量减少切换, Go 调度器实现了自旋线程. 自旋线程消耗一点额外的 CPU, 但是它们最小化了 OS 线程的抢占. 一个线程是自旋的, 如果:</p><ul><li>分配了 P 的 M 正在寻找一个可执行 goroutine;</li><li>没有分配 P 的 M 正在寻找可用的 P;</li><li>调度器还会释放一个附加的线程, 当它正准备一个 goroutine 并且没有空闲的 P 也没有其他自旋线程的时候让它自旋.</li></ul><p>任何时候最多有 GOMAXPROCS 个自旋的 M (们). 当一个自旋的线程找到工作, 它就脱离了自旋状态.</p><p>如果有空闲的 M 没有被赋予 P, 那么被赋予 P 的空闲线程不会被阻塞. 当新的 goroutine(s) 被创建或 M 被阻塞时, 调度器确保至少有一个自旋 M. 这确保了没有可运行的 goroutine(s) 不被运行; 并且避免过多的 M 阻塞或者解除阻塞.</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Go 调度器做了很多事情来避免过多的操作系统线程抢占, 通过窃取(stealing)调度它们到正确和未充分利用的处理器, 以及实现自旋线程以避免过高阻塞或者解除阻塞切换的发生.</p><p>调度事件可以用执行追踪器(<a href="https://golang.org/cmd/trace/" target="_blank" rel="noopener">execution tracer</a>)追踪. 如果你碰巧认为自己的处理器利用率很差, 则可以用它探究发生了什么事情.</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://github.com/golang/go/blob/master/src/runtime/proc.go" target="_blank" rel="noopener">Go 运行时调度器源码</a></li><li><a href="https://golang.org/s/go11sched" target="_blank" rel="noopener">可扩展 Go 调度器设计文档</a></li><li><a href="https://morsmachine.dk/go-scheduler" target="_blank" rel="noopener">Daniel Morsing: Go 调度器</a></li></ul></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go 谚语</title>
      <link href="/post/go-proverbs.html"/>
      <url>/post/go-proverbs.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自<a href="http://go-proverbs.github.io/" target="_blank" rel="noopener">go-proverbs</a>, 脱胎于 Rob Pike 振奋人心的演讲视频 <a href="https://www.youtube.com/watch?v=PAAkCSZUG1c" target="_blank" rel="noopener">talk at Gopherfest SV 2015</a> (<a href="https://www.bilibili.com/video/av18889438/" target="_blank" rel="noopener">bilibili</a>).<p></p><h3 id="不要通过共享内存进行通信-通过通信共享内存-Don’t-communicate-by-sharing-memory-share-memory-by-communicating"><a href="#不要通过共享内存进行通信-通过通信共享内存-Don’t-communicate-by-sharing-memory-share-memory-by-communicating" class="headerlink" title="不要通过共享内存进行通信, 通过通信共享内存 (Don’t communicate by sharing memory, share memory by communicating)"></a>不要通过共享内存进行通信, 通过通信共享内存 (<a href="https://www.bilibili.com/video/av18889438/?t=2m48s" target="_blank" rel="noopener">Don’t communicate by sharing memory, share memory by communicating</a>)</h3><p>传统的线程模型（通常在编写 Java, C++ 和 Python 程序时使用）要求程序员使用共享内存在线程之间进行通信. 通常, 共享数据结构受锁保护, 线程将争夺这些锁访问数据, 在某些情况下, 通过使用 Python 的 Queue 等线程安全的数据结构可以使这变得更容易.</p><p>Go 的并发原语 (goroutines 和 channels) 为构造并发软件提供了一种优雅而独特的手段. (这些概念有一个有趣的历史, 要从 C.A.R.Hoare 的通信顺序进程说起.) Go 鼓励使用 channels 在 goroutines 之间传递对数据的引用, 而不是显式地使用锁来调解对共享数据的访问. 这种方法确保只有一个 goroutine 可以在给定的时间访问数据. 这个概念总结在 Effective Go 文档中 (任何 Go 程序员都必须阅读).</p><p>Go 官方博客中有一篇文章对该谚语解读, 可以参见<a href="https://blog.golang.org/share-memory-by-communicating" target="_blank" rel="noopener">原文</a>.</p><h3 id="并发不是并行-Concurrency-is-not-parallelism"><a href="#并发不是并行-Concurrency-is-not-parallelism" class="headerlink" title="并发不是并行 (Concurrency is not parallelism)"></a>并发不是并行 (<a href="https://www.bilibili.com/video/av18889438/?t=3m42s" target="_blank" rel="noopener">Concurrency is not parallelism</a>)</h3><p>当人们听到 <em>并发</em> 这个词的时候, 他们经常会想到并行, 这是一个相关的, 但非常独特的概念. 在编程中, 并发是独立执行的进程的组成, 而并行则是 (可能相关的) 计算的同时执行. 并发是一次处理很多事情. 并行是一次做很多事情.</p><h3 id="Channels-重排序-互斥量串行化-Channels-orchestrate-mutexes-serialize"><a href="#Channels-重排序-互斥量串行化-Channels-orchestrate-mutexes-serialize" class="headerlink" title="Channels 重排序; 互斥量串行化 (Channels orchestrate; mutexes serialize)"></a>Channels 重排序; 互斥量串行化 (<a href="https://www.bilibili.com/video/av18889438/?t=4m20s" target="_blank" rel="noopener">Channels orchestrate; mutexes serialize</a>)</h3><p>这个看中文（翻译待商榷）是不是一脸懵 (虽然英文也看不懂) ? 其实分号前后说的是一个意思, 该谚语按我的个人理解可以用 go 程序 (来自 <a href="https://github.com/golang/tour/blob/master/content/concurrency/channels.go" target="_blank" rel="noopener">go tour</a>) 解释成如下:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum <span class="comment">// 此处如果改成互斥量一样可以做到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line"><span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">x, y := &lt;-c, &lt;-c</span><br><span class="line"></span><br><span class="line">fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口越大-抽象越弱-The-bigger-the-interface-the-weaker-the-abstraction"><a href="#接口越大-抽象越弱-The-bigger-the-interface-the-weaker-the-abstraction" class="headerlink" title="接口越大, 抽象越弱 (The bigger the interface, the weaker the abstraction)"></a>接口越大, 抽象越弱 (<a href="https://www.bilibili.com/video/av18889438/?t=5m17s" target="_blank" rel="noopener">The bigger the interface, the weaker the abstraction</a>)</h3><p>接口背后的概念是通过将对象的行为抽象为简单的契约来允许重用性. 虽然接口不是 Go 专有的, 但由于 Go 接口通常趋向于小型化, Go 程序员才广泛使用它们. 通常情况下, 一个接口只限于一到两个方法.</p><p>Go io 包接口就是典型的例子.</p><h3 id="充分利用零值-Make-the-zero-value-useful"><a href="#充分利用零值-Make-the-zero-value-useful" class="headerlink" title="充分利用零值 (Make the zero value useful)"></a>充分利用零值 (<a href="https://www.bilibili.com/video/av18889438/?t=6m25s" target="_blank" rel="noopener">Make the zero value useful</a>)</h3><p>零值的典型例子如 bytes.Buffer 和 sync.Mutex:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">buf.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line">fmt.Println(buf.String())</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu.Lock()</span><br><span class="line">mu.Unlock()</span><br></pre></td></tr></table></figure><p>这样看起来是不是感觉一点用没有 ? 如果这样呢 ?</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.RWMutex</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Set</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> m.m == <span class="literal">nil</span> &#123;</span><br><span class="line">m.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">m.m[k] = v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="interface-言之无物-interface-says-nothing"><a href="#interface-言之无物-interface-says-nothing" class="headerlink" title="interface{} 言之无物 (interface{} says nothing)"></a>interface{} 言之无物 (<a href="https://www.bilibili.com/video/av18889438/?t=7m36s" target="_blank" rel="noopener">interface{} says nothing</a>)</h3><p>该谚语不是说 interface {} 不代表任何东西, 而是说该类型无静态检查以及调用时保证, 比如你的 func 接收一个 interface{} 类型, 你写的时候是可用的, 但是某个时间你进行了代码重构可能坏掉了.</p><h3 id="Gofmt-的风格没有人喜欢-但是-gofmt-是每个人的最爱-Gofmt’s-style-is-no-one’s-favorite-yet-gofmt-is-everyone’s-favorite"><a href="#Gofmt-的风格没有人喜欢-但是-gofmt-是每个人的最爱-Gofmt’s-style-is-no-one’s-favorite-yet-gofmt-is-everyone’s-favorite" class="headerlink" title="Gofmt 的风格没有人喜欢, 但是 gofmt 是每个人的最爱 (Gofmt’s style is no one’s favorite, yet gofmt is everyone’s favorite)"></a>Gofmt 的风格没有人喜欢, 但是 gofmt 是每个人的最爱 (<a href="https://www.bilibili.com/video/av18889438/?t=8m43s" target="_blank" rel="noopener">Gofmt’s style is no one’s favorite, yet gofmt is everyone’s favorite</a>)</h3><p>该谚语告诉我们少些风格之争, 用这些时间多写代码.</p><h3 id="小复制好过小依赖-A-little-copying-is-better-than-a-little-dependency"><a href="#小复制好过小依赖-A-little-copying-is-better-than-a-little-dependency" class="headerlink" title="小复制好过小依赖 (A little copying is better than a little dependency)"></a>小复制好过小依赖 (<a href="https://www.bilibili.com/video/av18889438/?t=9m28s" target="_blank" rel="noopener">A little copying is better than a little dependency</a>)</h3><p>简单说就是如果你可以手动撸小快代码就不要导入一个库去做, 比如 UUID:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// see: https://groups.google.com/d/msg/golang-nuts/d0nF_k4dSx4/rPGgfXv6QCoJ</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, _ := os.Open(<span class="string">"/dev/urandom"</span>) <span class="comment">// 演示用忽略 errcheck</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">16</span>)</span><br><span class="line">f.Read(b)</span><br><span class="line">f.Close()</span><br><span class="line">uuid := fmt.Sprintf(<span class="string">"%x-%x-%x-%x-%x"</span>, b[<span class="number">0</span>:<span class="number">4</span>], b[<span class="number">4</span>:<span class="number">6</span>], b[<span class="number">6</span>:<span class="number">8</span>], b[<span class="number">8</span>:<span class="number">10</span>], b[<span class="number">10</span>:])</span><br><span class="line">fmt.Println(uuid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然有一堆写好的 UUID 库, 当你仅仅需要一个 UUID v4 实现.</p><h3 id="系统调用必须始终使用构建标签保证-Syscall-must-always-be-guarded-with-build-tags"><a href="#系统调用必须始终使用构建标签保证-Syscall-must-always-be-guarded-with-build-tags" class="headerlink" title="系统调用必须始终使用构建标签保证 (Syscall must always be guarded with build tags)"></a>系统调用必须始终使用构建标签保证 (<a href="https://www.bilibili.com/video/av18889438/?t=11m10s" target="_blank" rel="noopener">Syscall must always be guarded with build tags</a>)</h3><p>不同的系统 (*NIX, Windows) 调用导致你同一个 func (实现并不一样) 可能需要在不同的系统上构建才能得到你想要的结果. 简单说就是系统调用不可移植才这么干. 示例可参见 Go 标准库 syscall.</p><h3 id="Cgo-必须始终使用构建标签保证-Cgo-must-always-be-guarded-with-build-tags"><a href="#Cgo-必须始终使用构建标签保证-Cgo-must-always-be-guarded-with-build-tags" class="headerlink" title="Cgo 必须始终使用构建标签保证 (Cgo must always be guarded with build tags)"></a>Cgo 必须始终使用构建标签保证 (<a href="https://www.bilibili.com/video/av18889438/?t=11m53s" target="_blank" rel="noopener">Cgo must always be guarded with build tags</a>)</h3><p>基本上原因同上一条.</p><h3 id="Cgo-不是-Go-Cgo-is-not-Go"><a href="#Cgo-不是-Go-Cgo-is-not-Go" class="headerlink" title="Cgo 不是 Go (Cgo is not Go)"></a>Cgo 不是 Go (<a href="https://www.bilibili.com/video/av18889438/?t=12m37s" target="_blank" rel="noopener">Cgo is not Go</a>)</h3><p>如果可能不要用 Cgo. 这里有篇<a href="https://dave.cheney.net/2016/01/18/cgo-is-not-go" target="_blank" rel="noopener">文章</a>说明了为什么.</p><h3 id="unsafe-包无保证-With-the-unsafe-package-there-are-no-guarantees"><a href="#unsafe-包无保证-With-the-unsafe-package-there-are-no-guarantees" class="headerlink" title="unsafe 包无保证 (With the unsafe package there are no guarantees)"></a>unsafe 包无保证 (With the unsafe package there are no guarantees)</h3><p>包如其名, 不安全. 你可以使用 unsafe 包如果你准备好了有一天它会坏掉.</p><h3 id="清晰好过聪明-Clear-is-better-than-clever"><a href="#清晰好过聪明-Clear-is-better-than-clever" class="headerlink" title="清晰好过聪明 (Clear is better than clever)"></a>清晰好过聪明 (<a href="https://www.bilibili.com/video/av18889438/?t=14m35s" target="_blank" rel="noopener">Clear is better than clever</a>)</h3><p>Rob Pike 在他与别人合著的 &lt;<a href="https://item.jd.com/11836053.html" target="_blank" rel="noopener">程序设计实践</a>&gt; 中写到: “写清晰的代码, 不要写聪明的代码”.</p><h3 id="反射永远不是清晰的-Reflection-is-never-clear"><a href="#反射永远不是清晰的-Reflection-is-never-clear" class="headerlink" title="反射永远不是清晰的 (Reflection is never clear)"></a>反射永远不是清晰的 (<a href="https://www.bilibili.com/video/av18889438/?t=15m22s" target="_blank" rel="noopener">Reflection is never clear</a>)</h3><p>很多人在 Stackoverflow 上抱怨 Go 的反射不工作, 因为那不是为你准备的😂! 只有很少很少的人应该用反射这个非常强大而又非常难的特性. 新手应该远离反射和 interface{}.</p><h3 id="错误也是一种值-Errors-are-values"><a href="#错误也是一种值-Errors-are-values" class="headerlink" title="错误也是一种值 (Errors are values)"></a>错误也是一种值 (<a href="https://www.bilibili.com/video/av18889438/?t=16m13s" target="_blank" rel="noopener">Errors are values</a>)</h3><p>值可以被编程, 并且由于错误是值, 所以错误可以被编程. Go 官方博客有对此的<a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">解读</a>.</p><h3 id="不要止步于检查错误而要优雅的处理-Don’t-just-check-errors-handle-them-gracefully"><a href="#不要止步于检查错误而要优雅的处理-Don’t-just-check-errors-handle-them-gracefully" class="headerlink" title="不要止步于检查错误而要优雅的处理 (Don’t just check errors, handle them gracefully)"></a>不要止步于检查错误而要优雅的处理 (<a href="https://www.bilibili.com/video/av18889438/?t=17m25s" target="_blank" rel="noopener">Don’t just check errors, handle them gracefully</a>)</h3><p>Dave Cheney 有篇<a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">博客</a>详细解读了该谚语.</p><h3 id="设计架构-命名组件-记录细节-Design-the-architecture-name-the-components-document-the-details"><a href="#设计架构-命名组件-记录细节-Design-the-architecture-name-the-components-document-the-details" class="headerlink" title="设计架构, 命名组件, 记录细节 (Design the architecture, name the components, document the details)"></a>设计架构, 命名组件, 记录细节 (<a href="https://www.bilibili.com/video/av18889438/?t=18m09s" target="_blank" rel="noopener">Design the architecture, name the components, document the details</a>)</h3><p>当你写一个大型系统的时候, 你把它设计成一种结构化的东西. 想象组件的每一个部分并行工作, 为不同的组件起好的名字, 因为这些名字会出现在稿纸上.</p><p>拿 Go 程序来说, 如果名字不错, 组件就好理解, 那么程序的结构设计就会清晰, 程序会感觉很自然.</p><p>但是还有很多东西你需要解释, 所以这些是你需要解释的细节. 但是命名会帮助你解释很大一部分设计. 细节只是填补材料的缺口可能用来为用户打印工程图解文档.</p><h3 id="文档是针对用户的-Documentation-is-for-users"><a href="#文档是针对用户的-Documentation-is-for-users" class="headerlink" title="文档是针对用户的 (Documentation is for users)"></a>文档是针对用户的 (<a href="https://www.bilibili.com/video/av18889438/?t=19m07s" target="_blank" rel="noopener">Documentation is for users</a>)</h3><p>很多人写文档表明某个 func 是做什么的, 但是他们不想想这个 func 是为谁而写. 这有很大的不同. 你知道这个 func 返回什么是对的, 但是它为什么返回了你使用的时候不一样的结果?</p><p>把自己当成使用者而不是写它的人, 那么 godoc 上的文档就是对用户有用的. 这对于其他语言一样适用.</p><h3 id="不要慌-Don’t-panic"><a href="#不要慌-Don’t-panic" class="headerlink" title="不要慌 (Don’t panic)"></a>不要慌 (<a href="https://github.com/golang/go/wiki/CodeReviewComments#dont-panic" target="_blank" rel="noopener">Don’t panic</a>)</h3><p>不要使用 panic 进行正常的错误处理. 使用错误 (error) 和多个返回值.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go 调度工作机制</title>
      <link href="/post/how-does-the-golang-scheduler-work.html"/>
      <url>/post/how-does-the-golang-scheduler-work.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文是来自 Quora 上面一个 Go 相关的<a href="https://www.quora.com/How-does-the-golang-scheduler-work/answer/Ian-Lance-Taylor?share=508736a1&amp;srid=imO0" target="_blank" rel="noopener">问题</a>.<br><a id="more"></a><p></p><p>下面是 Ian Lance Taylor (Go 核心开发者兼资深元老) 给出的答案:</p><p>我将给出从 Go 1.7 开始使用的调度器的概述.</p><p>调度器有三个基本结构, 称为 G, M 和 P. 一个 G 是一个 goroutine, 一个 M 是一个操作系统线程, 一个 P 是一个(逻辑)处理器.</p><p>调度器有确切的 GOMAXPROCS 数量的 P (GOMAXPROCS是一个环境变量和运行时函数, 用来设置程序中的并发度). 为了让 M 执行一个 G, 它必须获得一个P, 然后运行 G 直到停止. G 通过进行诸如 I/O 操作的系统调用, 阻塞一个 channel 操作, 调用 C 函数, 正在被预抢占(pre-emption)或其他一些小的情况来停止. 一个 G 只能在一个安全的地方被预抢占, 在当前的实现中只能在代码发生函数调用的时候发生.</p><p>当一个 G 被类似于一个 channel 操作那样阻塞时, 它将被放置在一个队列中, M 将寻找另一个可运行的 G . 如果没有可运行的 G, 则 M 将释放 P 并进入睡眠状态.</p><p>当 G 完成系统调用时, 必须重新获取 P. 如果没有 P 可用, 它将被标记为可运行, M 将进入睡眠状态.</p><p>当 channel 操作成功时, 它会唤醒另一个 goroutine, 将其标记为可运行, 并且如果有可用的 P, 则唤醒 M 来运行它.</p><p>虽然垃圾收集器大多是并发的, 但有几点要暂时停止所有的线程才能安全地转移到下一个收集阶段. 它通过标记所有正在运行的 goroutine 来预抢占. 当他们到达安全点时, G 和 M 将进入睡眠. 当垃圾收集器是唯一剩下的正在运行的 G 时, 它将移动到下一个阶段, 然后唤醒 GOMAXPROC 数量的 M, 它们将各自找到可运行的 G, 并继续下去.</p><p>runtime.Gosched 函数促使 M 将当前的 G 放在可运行的 goroutine 列表中, 并从该列表中选择一个新的 G 开始运行.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL Order By 按特定的字段值排序</title>
      <link href="/post/ordering-by-specific-field-values-with-mysql.html"/>
      <url>/post/ordering-by-specific-field-values-with-mysql.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自(<a href="https://www.electrictoolbox.com/mysql-order-specific-field-values/" target="_blank" rel="noopener">Ordering by specific field values with MySQL</a>)版权@归原文所有<p></p><p>在 SQL 查询中可能有时需要使用 ASC 或 DESC 或使用特殊排序字段才能完成的特定顺序. MySQL 有一个 ORDER BY FIELD 函数可以用来做这个.<br><a id="more"></a></p><h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><p>本文中的示例数据使用我的示例 <a href="https://www.electrictoolbox.com/mysql-example-table/" target="_blank" rel="noopener">fruit</a> 表. 这是一个有点简单的表, 但它可以用来很好地说明这篇文章中的观点.</p><h3 id="按特定字段值排序"><a href="#按特定字段值排序" class="headerlink" title="按特定字段值排序"></a>按特定字段值排序</h3><p>fruit 表有一个 name 字段, 具有以下特定的值: 苹果(Apple), 香蕉(Banana), 橘子(Orange), 梨(Pear). 每个特定的值都有一系列的品种.</p><p>比方说, 为了论证的缘故, 我们要按香蕉, 苹果, 梨, 橘子等特定的顺序排列数据, 然后再按品种排序. 使用普通的 ORDER BY 子句不可能这样做, 因为这个字段的升序或降序排序不起作用. 我们要么需要某种形式的排序列或进行其他选择.</p><p>在 ORDER BY 子句中使用 FIELD 函数可以实现这一点. 它的工作方式是指定要排序的列, 然后按顺序排序它们的值. 例如:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> fruit</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">FIELD</span>(<span class="keyword">name</span>, <span class="string">'Banana'</span>, <span class="string">'Apple'</span>, <span class="string">'Pear'</span>, <span class="string">'Orange'</span>), variety;</span><br></pre></td></tr></table></figure><p>来自示例表的结果数据如下所示:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------+--------+---------------------+</span><br><span class="line">| fruit_id | name   | variety             |</span><br><span class="line">+----------+--------+---------------------+</span><br><span class="line">|       11 | Banana | Burro               |</span><br><span class="line">|       12 | Banana | Cavendish           |</span><br><span class="line">|       10 | Banana | Plantain            |</span><br><span class="line">|        6 | Apple  | Cox&apos;s Orange Pippin |</span><br><span class="line">|        7 | Apple  | Granny Smith        |</span><br><span class="line">|        1 | Apple  | Red Delicious       |</span><br><span class="line">|        8 | Pear   | Anjou               |</span><br><span class="line">|        4 | Pear   | Bartlett            |</span><br><span class="line">|        2 | Pear   | Comice              |</span><br><span class="line">|        5 | Orange | Blood               |</span><br><span class="line">|        3 | Orange | Navel               |</span><br><span class="line">|        9 | Orange | Valencia            |</span><br><span class="line">+----------+--------+---------------------+</span><br></pre></td></tr></table></figure><h3 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h3><p>使用此功能时有一个小小的疑难杂症. 列中不在 FIELD 函数中的任何值将在指定的值之前或多或少随机出现. 例如, 只指定苹果和香蕉:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> fruit</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">FIELD</span>(<span class="keyword">name</span>, <span class="string">'Banana'</span>, <span class="string">'Apple'</span>) <span class="keyword">DESC</span>, variety;</span><br></pre></td></tr></table></figure><p>这导致:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------+--------+---------------------+</span><br><span class="line">| fruit_id | name   | variety             |</span><br><span class="line">+----------+--------+---------------------+</span><br><span class="line">|        6 | Apple  | Cox&apos;s Orange Pippin |</span><br><span class="line">|        7 | Apple  | Granny Smith        |</span><br><span class="line">|        1 | Apple  | Red Delicious       |</span><br><span class="line">|       11 | Banana | Burro               |</span><br><span class="line">|       12 | Banana | Cavendish           |</span><br><span class="line">|       10 | Banana | Plantain            |</span><br><span class="line">|        8 | Pear   | Anjou               |</span><br><span class="line">|        4 | Pear   | Bartlett            |</span><br><span class="line">|        5 | Orange | Blood               |</span><br><span class="line">|        2 | Pear   | Comice              |</span><br><span class="line">|        3 | Orange | Navel               |</span><br><span class="line">|        9 | Orange | Valencia            |</span><br><span class="line">+----------+--------+---------------------+</span><br></pre></td></tr></table></figure><h3 id="解决问题的方法"><a href="#解决问题的方法" class="headerlink" title="解决问题的方法"></a>解决问题的方法</h3><p>虽然通常只有在确切的列已知的情况下才使用此函数, 但解决方法是颠倒指定字段的顺序并按降序对其排序, 然后在同一个字段上进行第二次排序.</p><p>下面的例子, 不管它看起来如何，实际上按照香蕉, 苹果, 然后按照升序排列:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> fruit</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">FIELD</span>(<span class="keyword">name</span>, <span class="string">'Apple'</span>, <span class="string">'Banana'</span>) <span class="keyword">DESC</span>, <span class="keyword">name</span>, variety;</span><br></pre></td></tr></table></figure><p>这导致:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------+--------+---------------------+</span><br><span class="line">| fruit_id | name   | variety             |</span><br><span class="line">+----------+--------+---------------------+</span><br><span class="line">|       11 | Banana | Burro               |</span><br><span class="line">|       12 | Banana | Cavendish           |</span><br><span class="line">|       10 | Banana | Plantain            |</span><br><span class="line">|        6 | Apple  | Cox&apos;s Orange Pippin |</span><br><span class="line">|        7 | Apple  | Granny Smith        |</span><br><span class="line">|        1 | Apple  | Red Delicious       |</span><br><span class="line">|        5 | Orange | Blood               |</span><br><span class="line">|        3 | Orange | Navel               |</span><br><span class="line">|        9 | Orange | Valencia            |</span><br><span class="line">|        8 | Pear   | Anjou               |</span><br><span class="line">|        4 | Pear   | Bartlett            |</span><br><span class="line">|        2 | Pear   | Comice              |</span><br><span class="line">+----------+--------+---------------------+</span><br></pre></td></tr></table></figure><p>如果一组特定的行需要显示在结果集中的其他行之前, 这可能是一个有用的解决方案, 但是当使用 ASC 或 DESC 排序顺序时, 通常不会出现在第一行.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go 命名返回值的好处</title>
      <link href="/post/golang-internals-part-2-nice-benefits-of-named-return-values.html"/>
      <url>/post/golang-internals-part-2-nice-benefits-of-named-return-values.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自(<a href="https://blog.minio.io/golang-internals-part-2-nice-benefits-of-named-return-values-1e95305c8687" target="_blank" rel="noopener">Golang 内幕第 2 部分: 命名返回值的好处</a>)版权@归原文所有<p></p><p>你可能知道 Golang 提供了命名返回值的能力. 到目前为止在 <a href="https://github.com/minio/minio" target="_blank" rel="noopener">minio</a> 中我们还没有使用这个功能, 但是这将会改变, 因为我们将在这个博客文章中解释一些隐藏的好处.<br><a id="more"></a></p><p>如果你像我们一样, 你可能会有相当数量的代码, 如下所示, 对于每一个 return 语句你都实例化一个新的对象, 以便返回一个’默认’值:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> objectInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">arg1 <span class="keyword">int64</span></span><br><span class="line">arg2 <span class="keyword">uint64</span></span><br><span class="line">arg3 <span class="keyword">string</span></span><br><span class="line">arg4 []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NoNamedReturnParams</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="params">(objectInfo)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// Do one thing</span></span><br><span class="line"><span class="keyword">return</span> objectInfo&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// Do another thing</span></span><br><span class="line"><span class="keyword">return</span> objectInfo&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">3</span> &#123;</span><br><span class="line"><span class="comment">// Do one more thing still</span></span><br><span class="line"><span class="keyword">return</span> objectInfo&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Normal return</span></span><br><span class="line"><span class="keyword">return</span> objectInfo&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你看一下 Golang 编译器生成的实际代码, 你将会得到如下的结果:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;.NoNamedReturnParams t=1 size=243 args=0x40 locals=0x0</span><br><span class="line">0x0000 TEXT&quot;&quot;.NoNamedReturnParams(SB), $0-64</span><br><span class="line">0x0000 MOVQ$0, &quot;&quot;.~r1+16(FP)</span><br><span class="line">0x0009 LEAQ&quot;&quot;.~r1+24(FP), DI</span><br><span class="line">0x000e XORPSX0, X0</span><br><span class="line">0x0011 ADDQ$-16, DI</span><br><span class="line">0x0015 DUFFZERO$288</span><br><span class="line">0x0028 MOVQ&quot;&quot;.i+8(FP), AX</span><br><span class="line">0x002d CMPQAX, $1</span><br><span class="line">0x0031 JEQ$0, 199</span><br><span class="line">0x0037 CMPQAX, $2</span><br><span class="line">0x003b JEQ$0, 155</span><br><span class="line">0x003d CMPQAX, $3</span><br><span class="line">0x0041 JNE111</span><br><span class="line">0x0043 MOVQ&quot;&quot;.statictmp_2(SB), AX</span><br><span class="line">0x004a MOVQAX, &quot;&quot;.~r1+16(FP)</span><br><span class="line">0x004f LEAQ&quot;&quot;.~r1+24(FP), DI</span><br><span class="line">0x0054 LEAQ&quot;&quot;.statictmp_2+8(SB), SI</span><br><span class="line">0x005b DUFFCOPY$854</span><br><span class="line">0x006e RET</span><br><span class="line">0x006f MOVQ&quot;&quot;.statictmp_3(SB), AX</span><br><span class="line">0x0076 MOVQAX, &quot;&quot;.~r1+16(FP)</span><br><span class="line">0x007b LEAQ&quot;&quot;.~r1+24(FP), DI</span><br><span class="line">0x0080 LEAQ&quot;&quot;.statictmp_3+8(SB), SI</span><br><span class="line">0x0087 DUFFCOPY$854</span><br><span class="line">0x009a RET</span><br><span class="line">0x009b MOVQ&quot;&quot;.statictmp_1(SB), AX</span><br><span class="line">0x00a2 MOVQAX, &quot;&quot;.~r1+16(FP)</span><br><span class="line">0x00a7 LEAQ&quot;&quot;.~r1+24(FP), DI</span><br><span class="line">0x00ac LEAQ&quot;&quot;.statictmp_1+8(SB), SI</span><br><span class="line">0x00b3 DUFFCOPY$854</span><br><span class="line">0x00c6 RET</span><br><span class="line">0x00c7 MOVQ&quot;&quot;.statictmp_0(SB), AX</span><br><span class="line">0x00ce MOVQAX, &quot;&quot;.~r1+16(FP)</span><br><span class="line">0x00d3 LEAQ&quot;&quot;.~r1+24(FP), DI</span><br><span class="line">0x00d8 LEAQ&quot;&quot;.statictmp_0+8(SB), SI</span><br><span class="line">0x00df DUFFCOPY$854</span><br><span class="line">0x00f2 RET</span><br></pre></td></tr></table></figure><p>一切都很好, 但这看起来是否有点重复? 你是对的. 实质上, 对于每个 return 语句, 要返回的对象或多或少被分配/初始化(或者通过 DUFFCOPY 宏更精确地复制).</p><p>毕竟这是我们通过在每种情况下都返回 objectInfo {} 的结果.</p><h3 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h3><p>现在看看如果我们做一个非常简单的改变会发生什么, 本质上只是给返回值一个名字 (oi) 和使用 Golang 的’裸体’返回特性(为返回语句放弃参数, 虽然这不是严格要求, 稍后更多):</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NamedReturnParams</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="params">(oi objectInfo)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// Do one thing</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// Do another thing</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">3</span> &#123;</span><br><span class="line"><span class="comment">// Do one more thing still</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Normal return</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看看编译器生成的代码, 我们得到以下结果:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;.NamedReturnParams t=1 size=67 args=0x40 locals=0x0</span><br><span class="line">0x0000 TEXT&quot;&quot;.NamedReturnParams(SB), $0-64</span><br><span class="line">0x0000 MOVQ$0, &quot;&quot;.oi+16(FP)</span><br><span class="line">0x0009 LEAQ&quot;&quot;.oi+24(FP), DI</span><br><span class="line">0x000e XORPSX0, X0</span><br><span class="line">0x0011 ADDQ$-16, DI</span><br><span class="line">0x0015 DUFFZERO$288</span><br><span class="line">0x0028 MOVQ&quot;&quot;.i+8(FP), AX</span><br><span class="line">0x002d CMPQAX, $1</span><br><span class="line">0x0031 JEQ$0, 66</span><br><span class="line">0x0033 CMPQAX, $2</span><br><span class="line">0x0037 JEQ$0, 65</span><br><span class="line">0x0039 CMPQAX, $3</span><br><span class="line">0x003d JNE64</span><br><span class="line">0x003f RET</span><br><span class="line">0x0040 RET</span><br><span class="line">0x0041 RET</span><br><span class="line">0x0042 RET</span><br></pre></td></tr></table></figure><p>这是一个非常大的差异, 所有四个对象初始化和 DUFFCOPY 这些东西消失(甚至对于这个微不足道的情况)了. 它将函数的大小从 243 减小到 67 字节. 另外作为一个额外的好处, 你将省去一些 CPU 周期退出, 因为不需要做任何事情来设置返回值.</p><p>请注意, 如果您不喜欢或偏好 Golang 提供的裸返回, 则可以使用 return oi, 同时还可以获得相同的好处, 如下所示:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> oi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="minio-服务器中真实世界的例子"><a href="#minio-服务器中真实世界的例子" class="headerlink" title="minio 服务器中真实世界的例子"></a>minio 服务器中真实世界的例子</h3><p>我们拿 minio server 的例子更进一步:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parse credentialHeader string into its structured form.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseCredentialHeader</span><span class="params">(credElement <span class="keyword">string</span>)</span> <span class="title">credentialHeader</span></span> &#123;</span><br><span class="line">creds := strings.Split(strings.TrimSpace(credElement), <span class="string">"="</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(creds) != <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> credentialHeader&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> creds[<span class="number">0</span>] != <span class="string">"Credential"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> credentialHeader&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">credElements := strings.Split(strings.TrimSpace(creds[<span class="number">1</span>]), <span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(credElements) != <span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">return</span> credentialHeader&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="literal">false</span> <span class="comment">/*!isAccessKeyValid(credElements[0])*/</span> &#123;</span><br><span class="line"><span class="keyword">return</span> credentialHeader&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Save access key id.</span></span><br><span class="line">cred := credentialHeader&#123;</span><br><span class="line">accessKey: credElements[<span class="number">0</span>],</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e error</span><br><span class="line">cred.scope.date, e = time.Parse(yyyymmdd, credElements[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> credentialHeader&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">cred.scope.region = credElements[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span> credElements[<span class="number">3</span>] != <span class="string">"s3"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> credentialHeader&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">cred.scope.service = credElements[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> credElements[<span class="number">4</span>] != <span class="string">"aws4_request"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> credentialHeader&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">cred.scope.request = credElements[<span class="number">4</span>]</span><br><span class="line"><span class="keyword">return</span> cred</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深入汇编我们得到以下的函数头:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;.parseCredentialHeader t=1 size=1157 args=0x68 locals=0xb8</span><br></pre></td></tr></table></figure><p>如果我们修改代码来使用一个命名返回参数(下面的第二个源代码块), 请检查函数的大小:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;.parseCredentialHeader t=1 size=863 args=0x68 locals=0xb8</span><br></pre></td></tr></table></figure><p>它从总共 1150 个字节中删除了 300 个字节, 这对于源代码这样一个最小的改变还不错. 取决于你从哪里来，你也可能更喜欢源代码的更干净的外观:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parse credentialHeader string into its structured form.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseCredentialHeader</span><span class="params">(credElement <span class="keyword">string</span>)</span> <span class="params">(ch credentialHeader)</span></span> &#123;</span><br><span class="line">creds := strings.Split(strings.TrimSpace(credElement), <span class="string">"="</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(creds) != <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> creds[<span class="number">0</span>] != <span class="string">"Credential"</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">credElements := strings.Split(strings.TrimSpace(creds[<span class="number">1</span>]), <span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(credElements) != <span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="literal">false</span> <span class="comment">/*!isAccessKeyValid(credElements[0])*/</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Save access key id.</span></span><br><span class="line">cred := credentialHeader&#123;</span><br><span class="line">accessKey: credElements[<span class="number">0</span>],</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e error</span><br><span class="line">cred.scope.date, e = time.Parse(yyyymmdd, credElements[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">cred.scope.region = credElements[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span> credElements[<span class="number">3</span>] != <span class="string">"s3"</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">cred.scope.service = credElements[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> credElements[<span class="number">4</span>] != <span class="string">"aws4_request"</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">cred.scope.request = credElements[<span class="number">4</span>]</span><br><span class="line"><span class="keyword">return</span> cred</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意, 实际上 ch 变量是一个正常的局部变量, 就像在函数中定义的任何其他局部变量一样. 因此, 您可以将其值从默认的’零’状态更改(当然, 修改后的版本将在退出时返回).</p><h3 id="命名返回值的其他用法"><a href="#命名返回值的其他用法" class="headerlink" title="命名返回值的其他用法"></a>命名返回值的其他用法</h3><p>正如几位人士指出的那样, 指定返回值的另一个好处是可以在闭包中使用(即 defer 语句). 因此, 可以在作为 defer 语句的结果调用的函数中访问指定的返回值, 并相应地进行操作.</p><h3 id="关于这个系列"><a href="#关于这个系列" class="headerlink" title="关于这个系列"></a>关于这个系列</h3><p>如果你错过了本系列的第一部分, 这里是一个链接:</p><ul><li>关于 <a href="https://blog.minio.io/golang-internals-part-1-autogenerated-functions-and-how-to-get-rid-of-them-6ca4749cc236" target="_blank" rel="noopener">autogenerated</a> 函数</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>所以我们将逐渐采用命名的返回值, 无论是新代码还是现有代码.</p><p>事实上, 我们也在研究是否可以开发一些小工具来帮助或自动化这个过程. 按照 gofmt 的思路思考, 然后自动修改源代码以进行上面所述的更改. 特别是在返回值还没有被命名的情况下(因此实用程序必须给它一个名字), 这个返回变量在现有的源代码中以任何方式改变都是不可能的, ch (在上面列表的情况下)不会导致程序的任何功能变化.</p><p>所以请继续关注.</p><p>我们希望这篇文章能对你有所帮助, 并提供一些关于 Go 如何在内部运行以及如何改进 Golang 代码的新见解.</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>已经有一个 Golang <a href="https://github.com/golang/go/issues/20859" target="_blank" rel="noopener">issue</a> 来优化编译器为上述情况生成相同的代码, 这将是一件好事.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go 没有传引用</title>
      <link href="/post/there-is-no-pass-by-reference-in-go.html"/>
      <url>/post/there-is-no-pass-by-reference-in-go.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自(<a href="https://dave.cheney.net/2017/04/29/there-is-no-pass-by-reference-in-go" target="_blank" rel="noopener">Go 没有传引用</a>)版权@归原文所有.<br><a id="more"></a><p></p><p>要清楚的是, Go 没有引用变量, 所以 Go 没有传递引用函数的调用语义.</p><h3 id="什么是引用变量-reference-variable"><a href="#什么是引用变量-reference-variable" class="headerlink" title="什么是引用变量(reference variable) ?"></a>什么是引用变量(reference variable) ?</h3><p>在像 C++ 这样的语言中, 你可以声明一个别名, 或者一个现有变量的替代名称. 这被称为引用变量.</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> &amp;b = a;</span><br><span class="line">        <span class="keyword">int</span> &amp;c = b;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%p %p %p\n"</span>, &amp;a, &amp;b, &amp;c); <span class="comment">// 0x7ffe114f0b14 0x7ffe114f0b14 0x7ffe114f0b14</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到 a, b 和 c 都指向相同的内存位置. 写入 a 会改变 b 和 c 的内容. 当你想在函数调用不同的作用域声明引用变量时, 这是很有用的.</p><h3 id="Go-没有引用变量"><a href="#Go-没有引用变量" class="headerlink" title="Go 没有引用变量"></a>Go 没有引用变量</h3><p>与 C++ 不同, Go 程序中定义的每个变量都占用一个唯一的内存位置.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a, b, c <span class="keyword">int</span></span><br><span class="line">        fmt.Println(&amp;a, &amp;b, &amp;c) <span class="comment">// 0x1040a124 0x1040a128 0x1040a12c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个两个变量在内存中共享相同的存储位置的 Go 程序是不可能的. 可以创建两个变量, 其内容指向相同的存储位置, 但与共享相同存储位置的两个变量不同.</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">var</span> b, c = &amp;a, &amp;a</span><br><span class="line">        fmt.Println(b, c)   <span class="comment">// 0x1040a124 0x1040a124</span></span><br><span class="line">        fmt.Println(&amp;b, &amp;c) <span class="comment">// 0x1040c108 0x1040c110</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中, b 和 c 保持相同的值, 即 a 的地址. 但是, b 和 c 本身存储在不同的位置. 更新 b 的内容对 c 没有影响.</p><h3 id="但是-map-和-channel-是引用吗"><a href="#但是-map-和-channel-是引用吗" class="headerlink" title="但是 map 和 channel 是引用吗 ?"></a>但是 map 和 channel 是引用吗 ?</h3><p>错, map 和 channel 不是引用. 如果他们是, 那么下面这个程序将打印 false .</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">        fn(m)</span><br><span class="line">        fmt.Println(m == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果map m 是一个 C++ 风格的引用变量, 则在 main 中声明的 m 和 在 fn 中声明的 m 将在内存中占据相同的存储位置. 但是, 因为对 fn 内的 m 的赋值对 m 的值没有影响, 所以我们可以看到 m 不是引用变量.</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Go 没有传递引用语义, 因为 Go 没有引用变量.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为什么 Go 不实现分代和紧凑 gc</title>
      <link href="/post/why-golang-garbage-collector-not-implement-generational-and-compact-gc.html"/>
      <url>/post/why-golang-garbage-collector-not-implement-generational-and-compact-gc.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">本文译自 Google 论坛(<a href="https://groups.google.com/forum/#!msg/golang-nuts/KJiyv2mV2pU/wdBUH1mHCAAJ" target="_blank" rel="noopener">golang-nuts</a>)版权@归原文所有.<p></p><p>有人在论坛里面问: 为什么 Golang 垃圾回收器不实现分代和紧凑 gc ?<br><a id="more"></a></p><p>Ian Lance Taylor 的回复:</p><p>这已经在过去讨论过了.</p><p>忽略细节, 紧凑(compacting) GC 的基本优点是:</p><ul><li>避免碎片, 以及;</li><li>允许使用简单而有效的凹凸分配器(bump allocator).</li></ul><p>但是, 现代的内存分配算法, 象 Go 运行时使用的基于 tcmalloc 的方案基本上没有碎片问题. 而凹凸分配器对于 Go 这样需要锁的多线程程序中的单线程程序是简单有效的. 一般来说, 这可能更多有效地使用一组每个线程缓存来分配内存, 而在这一点上你已经失去了凹凸分配器的优势. 所以我会断言, 一般来说有很多注意事项导致今天没有真正的优势为一个多线程程序使用压缩内存分配器. 我不是说使用压缩分配器有什么问题, 我只是认为它相对于非压缩的来说没有带来任何大的优势.</p><p>现在我们来考虑一下分代 GC. 分代 GC 的关键依赖于世代的假设: 分配在一个程序中的大部分值很快变得不会用到, 所以分代 GC 有一个优势就是可以花更多的时间查看最近分配的对象. 这里 Go 不同于许多垃圾收集语言, 因为许多对象是直接在程序栈(stack)上分配的. Go 编译器使用逃逸分析(escape analysis)来查找那些在编译时生命周期就已知的对象, 将它们分配到堆栈而不是垃圾收集的内存中. 所以一般来说, 在 Go 中, 与其他语言相比, 有很大比例的分代 GC 要找的很快不会用到的(quickly-unused)值不会分配在 GC 内存的首要位置. 所以分代 GC 能给 Go 带来的优势相对于其他语言要小.</p><p>更微妙的是, 大多数世代 GC 实现的隐藏点是减少垃圾收集带来的程序暂停的时间. 暂停期间只看最年轻的一代, 暂停时间很短. 然而, Go 使用了一个并发垃圾收集器, 并且在 Go 中程序暂停时间与年轻代或者任意代的大小无关. Go 基本上假设, 在多线程程序中, 通过在不同的核上并行运行 GC, 不是为了最小化 GC 时间去暂停导致程序运行更长的时间, 而是总体上花更多的总 CPU 时间在 GC 上.</p><p>总之, 分代 GC 可能仍然可以为 Go 带来显著的价值, 即减少并行 GC 时的工作量. 这是一个需要测试的假设. Go 当前的 GC 工作实际上正在密切关注一个相关但不同的假设: Go 程序可能倾向于按请求分配内存. <a href="https://docs.google.com/document/d/1gCsFxXamW8RRvOe5hECz98Ftk-tcRRJcDFANj2VwCB0/view" target="_blank" rel="noopener">这里</a>有一个描述. 这项工作正在进行中, 现实情况是否有利还有待观察.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
            <tag> gc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go Range 循环内幕</title>
      <link href="/post/go-range-loop-internals.html"/>
      <url>/post/go-range-loop-internals.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p=""><a href="https://garbagecollected.org/2017/02/22/go-range-loop-internals/" target="_blank" rel="noopener">译文</a>版权@归原文所有.<p></p><p>虽然他们非常方便, 但我总是发现 Go 的 Range 循环有点神秘. 我并不是第一个:<br><a id="more"></a></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://bit.ly/2CXC1Ob 来自 Dave Cheney.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> v &#123;</span><br><span class="line">v = <span class="built_in">append</span>(v, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我可以把这些事实记录下来, 但是我很可能会忘记. 为了有更好的机会记住这个, 我需要找出为什么 range 循环会这样. 所以我写了这篇文章.</p><h2 id="Step-1-读手册-RTFM"><a href="#Step-1-读手册-RTFM" class="headerlink" title="Step 1: 读手册(RTFM)"></a>Step 1: 读手册(RTFM)</h2><p>我们首先应该去读 range 循环文档. Go语言规范文档在 <a href="https://golang.org/ref/spec#For_statements" target="_blank" rel="noopener">for 语句</a>部分的 <em>For 语句和 range 子句</em>描述了 range 循环. 我不会在这里复制整个规范，我会总结一些有趣的部分.</p><p>首先, 让我们提醒自己我们在这里看到什么:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Range-变量"><a href="#Range-变量" class="headerlink" title="Range 变量"></a>Range 变量</h3><p>你们中的大多数人会知道, 在 Range 子句的左边(上面的例子中的 i), 你可以这样分配循环变量:</p><ul><li>分配 (=)</li><li>短变量声明 (:=)</li></ul><p>您也可以选择完全忽略循环变量.</p><p>如果使用短变量声明样式分配(:=), 则 Go 将在循环的每个迭代中重用变量(仅在循环内的范围内).</p><h3 id="Range-表达式"><a href="#Range-表达式" class="headerlink" title="Range 表达式"></a>Range 表达式</h3><p>在 Range 子句的右边(上面的例子中的 a), 你可以找到他们称之为 Range 表达式的东西. 它可以包含任何表达式, 其计算结果如下:</p><ul><li>数组(array)</li><li>指向数组的指针</li><li>切片(slice)</li><li>字符串(string)</li><li>字典(map)</li><li>允许接收的管道(channel), 如: chan int 或者 chan&lt;- int</li></ul><p><strong>Range 表达式在开始循环之前只计算一次</strong>. 请注意, 这个规则有一个例外: 如果 Range 一个数组(或指向它的指针), 你只能分配索引：那么只有 len(a) 被计算. 仅计算 len(a) 意味着可以在编译时计算表达式 a, 并由编译器用常量替换. <a href="https://golang.org/ref/spec#Length_and_capacity" target="_blank" rel="noopener">len 函数规范</a>解释如下:</p><blockquote><p>如果s的类型是数组或指向数组的指针并且表达式 s 不包含通道接收(channel receives) 或(非 常量) 函数调用, 则表达式 len(s) 和 cap(s) 是常量. 在这种情况下 s 不被计算. 否则, len 和 cap 的调用不是常量, 而是被计算.</p></blockquote><p>那么 “计算(evaluated)” 究竟意味着什么呢? 不幸的是我不能在规范中找到这个信息. 当然, 我可以猜测, 这意味着完全执行表达式, 直到它不能进一步减少. 在任何情况下, 这里的高位是 Range 表达式在循环开始之前计算一次. 你如何只评估一个表达式仅一次? 通过将其分配给一个变量! 这可能是这里发生的事情吗?</p><p>有趣的是, 这个规范提到了一些关于从 map 中添加和删除的特殊的东西(没有提到切片):</p><blockquote><p>如果在迭代过程中移除尚未到达的 map 项, 则不会生成相应的迭代值. 如果迭代过程中创建 map 项, 那么可能会在迭代过程中生成该项, 或者可能会跳过该项.</p></blockquote><p>我稍后会回到 map.</p><h2 id="Step-2-Range-支持的数据类型"><a href="#Step-2-Range-支持的数据类型" class="headerlink" title="Step 2: Range 支持的数据类型"></a>Step 2: Range 支持的数据类型</h2><p>如果我们假设 Range 表达式在循环开始之前被赋值了一次, 那么这是什么意思? 答案是它取决于数据类型, 所以让我们仔细看一下 Range 所支持的数据类型.</p><p>在我们这样做之前, 请记住这一点: <strong>在 Go 中, 您分配的所有东西都被复制</strong>. 如果您分配一个指针, 则复制指针.如果你分配一个结构体, 则复制结构.将参数传递给函数时也是如此. 无论如何, 这里是:</p><p>// TODO</p><p>请参阅本文底部的参考资料, 了解更多关于这些数据类型的内部结构.</p><p>那么这是什么意思? 这些例子突出了一些差异:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// copies the entire array</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">acopy := a</span><br><span class="line"></span><br><span class="line"><span class="comment">// copies the slice header struct only, NOT the backing array</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">scopy := s</span><br><span class="line"></span><br><span class="line"><span class="comment">// copies the map pointer only</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">mcopy := m</span><br></pre></td></tr></table></figure><p>所以如果在一个 Range 循环的开始处, 你可以将一个数组表达式赋值给一个变量(以确保它只能计算一次), 那么你将复制整个数组.</p><h2 id="Step-3-Go-编译器源码"><a href="#Step-3-Go-编译器源码" class="headerlink" title="Step 3: Go 编译器源码"></a>Step 3: Go 编译器源码</h2><p>(未完待续)</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017 已逝</title>
      <link href="/post/2017-has-passed.html"/>
      <url>/post/2017-has-passed.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h3="" id="2017-的目标实现了吗"><a href="#2017-的目标实现了吗" class="headerlink" title="2017 的目标实现了吗"></a>2017 的目标实现了吗<a id="more"></a><p>先回顾一下 2017 年的目标:</p><ul><li><p><em>Go</em> 语言继续趁手</p></li><li><p><em>Kotlin</em> 修炼, 捎带 <em>Java 8</em></p></li><li><p><em>Python 3.6</em> 特性加持</p></li><li><p><em>OCaml</em> 把玩</p></li></ul><p>除了 Go 语言继续趁手, 其他的真的没所谓了.</p><h3 id="现实会给你以教训"><a href="#现实会给你以教训" class="headerlink" title="现实会给你以教训"></a>现实会给你以教训</h3><p>2017 年不管对于工作还是生活真的让我涨见识了;</p><ul><li><p>好好活着;</p></li><li><p>走出舒适区;</p></li><li><p>野心需要技能匹配;</p></li></ul><h3 id="2018-年做好自己"><a href="#2018-年做好自己" class="headerlink" title="2018 年做好自己"></a>2018 年做好自己</h3><ul><li><p>简单与优雅正交, 写清晰的代码, 做简单的事, Go 继续趁手;</p></li><li><p>认准的事情就干, 不骄不躁;</p></li><li><p>逼一下自己;</p></li></ul></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go 服务优雅重启</title>
      <link href="/post/golang-graceful-restart-server.html"/>
      <url>/post/golang-graceful-restart-server.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">很多时候对于服务升级的做法简单粗暴, 就简单的杀进程启动新的进程.<br><a id="more"></a><p></p><p>还有的好一点就是多个相同的服务依次升级, 保证有服务可用. 但是公平的说这两种都会丢失请求中的连接. 鉴于这种情况, 在现实中我们可以使用优雅重启来搞定这个问题. Golang 实现优雅重启的原理也很简单:</p><ul><li><p>监听 USR2 信号;</p></li><li><p>收到信号后将服务监听的文件描述符传递给新的子进程;</p></li><li><p>此时新老进程同时接收请求;</p></li><li><p>父进程停止接收新请求, 等待旧请求完成(或超时);</p></li><li><p>父进程退出.</p></li></ul><p>对于上面的原理看似简单, 其实是分成了两个大的要点:</p><ul><li><p>新老进程同时监听同一端口, 这个很简单, Go 很早就支持;</p></li><li><p>如何等待旧的请求完成, 这个在 Go 1.8 (新增了Server.Shutdown) 之前是需要费一番功夫的.</p></li></ul><p>我们搞定了上面的原理之后, 加上 Go 1.8 的完美等待旧请求的实现, 我实现了一个简单的优雅重启库: <a href="https://github.com/douglarek/zerodown" target="_blank" rel="noopener">https://github.com/douglarek/zerodown</a>.</p><p>zerodown 完美兼容基于 Go 标准库 Server 监听服务. 对于标准库的使用, 我们可以象下面一样使用:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/douglarek/zerodown"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">fmt.Fprintln(w, <span class="string">"Hello, World!"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">log.Fatalln(zerodown.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure><p>对于第三方库 Gin 我们可以:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/douglarek/zerodown"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := gin.Default()</span><br><span class="line">router.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">c.String(http.StatusOK, <span class="string">"Hello, World!"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">log.Fatalln(zerodown.ListenAndServe(<span class="string">":8080"</span>, router))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Gin-Gonic 框架中间件原理与应用</title>
      <link href="/post/gin-gonic-middleware-theory-and-apply.html"/>
      <url>/post/gin-gonic-middleware-theory-and-apply.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">在 Go 的世界里, web 框架简直多如牛毛.<p></p><p>前有自带电池的标准库(net/http), 后有简洁优雅的 Gin-Gonic(以下简称 Gin), 再有全栈开发一枝花 Beego, 等等不可胜数.</p><p>使用 Go 有一段时间了, web 开发一直用的 Gin. Gin 的思想和 Python 框架 Flask 有颇多相似之处, 可以称作 <em>微框架</em> .<br><a id="more"></a></p><p>Gin 包括以下几个主要的部分:</p><ul><li>设计精巧的路由/中间件系统;</li><li>简单好用的核心上下文 Context;</li><li>附赠工具集(JSON/XML 响应, 数据绑定与校验等).</li></ul><p>本文意在探究 Gin 中间件的执行原理. 我们先看如下的 Hello World 版 Gin 程序：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">"/ping"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.String(http.StatusOK, <span class="string">"%s"</span>, <span class="string">"pong!"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := r.Run(<span class="string">"0.0.0.0:8080"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个简单的 Gin 程序默认启用了两个中间件, 分别是 Logger() 和 Recovery().我们之前说过, Context 是 Gin 的核心, 它的构造如下:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">writermem responseWriter</span><br><span class="line">Request   *http.Request</span><br><span class="line">Writer    ResponseWriter</span><br><span class="line"></span><br><span class="line">Params   Params</span><br><span class="line">handlers HandlersChain</span><br><span class="line">index    <span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line">engine   *Engine</span><br><span class="line">Keys     <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">Errors   errorMsgs</span><br><span class="line">Accepted []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 handlers 我们通过源码可以知道就是 []HandlerFunc. 而它的签名正是:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(*Context)</span></span></span><br></pre></td></tr></table></figure><p>所以中间件和我们普通的 HandlerFunc 没有任何区别对吧, 我们怎么写 HandlerFunc 就可以怎么写一个中间件. 那么问题来了, 我们怎么解决一个请求和一个响应经过我们的中间件呢? 我们来写个简单的中间件分析一下:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.Use(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">log.Println(<span class="string">"Request in"</span>) <span class="comment">// ①</span></span><br><span class="line">c.Next() <span class="comment">// next handler func</span></span><br><span class="line">log.Println(<span class="string">"Response out"</span>) <span class="comment">// ②</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>神奇的语句出现了, 没错就是 c.Next(), 所有中间件都有 Request 和 Response 的分水岭, 就是这个 c.Next(), 否则没有办法传递中间件. 我们来看源码:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Next</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.index++</span><br><span class="line">s := <span class="keyword">int8</span>(<span class="built_in">len</span>(c.handlers))</span><br><span class="line"><span class="keyword">for</span> ; c.index &lt; s; c.index++ &#123;</span><br><span class="line">c.handlers[c.index](c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个请求过来, Gin 会主动调用 c.Next() 一次. 因为 handlers 是 slice , 所以后来者中间件会追加到尾部. 这样就形成了形如 m1(m2(f())) 的调用链. 正如上面数字① ② 标注的一样, 我们会依次执行如下的调用:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m1① -&gt; m2① -&gt; f -&gt; m2② -&gt; m1②</span><br></pre></td></tr></table></figure><p>我们用下面一张图来来总结这种关系:</p><p><a href="/static/images/gin-middleware.png" title="middleware stream" class="gallery-item"><img src="/static/images/gin-middleware.png" alt="middleware stream"></a></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> gin </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL 10 JSON 全文检索</title>
      <link href="/post/postgresql-10-full-text-search-support-for-json-and-jsonb.html"/>
      <url>/post/postgresql-10-full-text-search-support-for-json-and-jsonb.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p=""><a href="https://www.depesz.com/2017/04/04/waiting-for-postgresql-10-full-text-search-support-for-json-and-jsonb/" target="_blank" rel="noopener">译文</a>版权@归原文所有.<p></p><p>这是对 JSON 数据的又一个很酷的补充. 现在我们可以轻松地添加 json 值的全文搜索.<br><a id="more"></a></p><p>一个它如何运作的快速例子:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">select</span> <span class="keyword">id</span>, jsonb_pretty(payload) <span class="keyword">from</span> <span class="keyword">test</span>;</span><br><span class="line">id |                                                jsonb_pretty</span><br><span class="line"><span class="comment">----+-------------------------------------------------------------------------------------------------------------</span></span><br><span class="line">  1 | &#123;                                                                                                          +</span><br><span class="line">    |     "glossary": &#123;                                                                                          +</span><br><span class="line">    |         "title": "example glossary",                                                                       +</span><br><span class="line">    |         "GlossDiv": &#123;                                                                                      +</span><br><span class="line">    |             "title": "S",                                                                                  +</span><br><span class="line">    |             "GlossList": &#123;                                                                                 +</span><br><span class="line">    |                 "GlossEntry": &#123;                                                                            +</span><br><span class="line">    |                     "ID": "SGML",                                                                          +</span><br><span class="line">    |                     "Abbrev": "ISO 8879:1986",                                                             +</span><br><span class="line">    |                     "SortAs": "SGML",                                                                      +</span><br><span class="line">    |                     "Acronym": "SGML",                                                                     +</span><br><span class="line">    |                     "GlossDef": &#123;                                                                          +</span><br><span class="line">    |                         "para": "A meta-markup language, used to <span class="keyword">create</span> markup languages such <span class="keyword">as</span> DocBook.<span class="string">",+</span></span><br><span class="line"><span class="string">    |                         "</span>GlossSeeAlso<span class="string">": [                                                                  +</span></span><br><span class="line"><span class="string">    |                             "</span>GML<span class="string">",                                                                         +</span></span><br><span class="line"><span class="string">    |                             "</span><span class="keyword">XML</span><span class="string">"                                                                          +</span></span><br><span class="line"><span class="string">    |                         ]                                                                                  +</span></span><br><span class="line"><span class="string">    |                     &#125;,                                                                                     +</span></span><br><span class="line"><span class="string">    |                     "</span>GlossSee<span class="string">": "</span>markup<span class="string">",                                                                  +</span></span><br><span class="line"><span class="string">    |                     "</span>GlossTerm<span class="string">": "</span>Standard Generalized Markup <span class="keyword">Language</span><span class="string">"                                    +</span></span><br><span class="line"><span class="string">    |                 &#125;                                                                                          +</span></span><br><span class="line"><span class="string">    |             &#125;                                                                                              +</span></span><br><span class="line"><span class="string">    |         &#125;                                                                                                  +</span></span><br><span class="line"><span class="string">    |     &#125;                                                                                                      +</span></span><br><span class="line"><span class="string">    | &#125;</span></span><br><span class="line"><span class="string">(1 row)</span></span><br></pre></td></tr></table></figure><p>正如你所看到的, 我有一个相当嵌套的 json 结构. 现在我们需要 tsvector 数据来构建一个索引. 我们可以这样:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">select</span> to_tsvector(<span class="string">'english'</span>, payload) <span class="keyword">from</span> <span class="keyword">test</span>;</span><br><span class="line">                                  to_tsvector</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line"> '1986':8 '8879':7 'creat':21 'docbook':26 'exampl':1 'general':35 'glossari':2.</span><br><span class="line">. 'gml':28 'iso':6 'languag':18,23,37 'markup':17,22,32,36 'meta':16 'meta-mark.</span><br><span class="line">.up':15 'sgml':4,10,12 'standard':34 '<span class="keyword">use</span><span class="string">':19 '</span><span class="keyword">xml</span><span class="string">':30</span></span><br><span class="line"><span class="string">(1 row)</span></span><br></pre></td></tr></table></figure><p>很好. 它找到了 json 数据值中的所有单词(它没有索引对象的键).</p><p>还有与之匹配的 ts_headline 函数.</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">select</span> jsonb_pretty(ts_headline(payload, <span class="string">'sgml'</span>::tsquery)) <span class="keyword">from</span> <span class="keyword">test</span>;</span><br><span class="line">                                                jsonb_pretty</span><br><span class="line"><span class="comment">-------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> &#123;                                                                                                          +</span><br><span class="line">     "glossary": &#123;                                                                                          +</span><br><span class="line">         "title": "example glossary",                                                                       +</span><br><span class="line">         "GlossDiv": &#123;                                                                                      +</span><br><span class="line">             "title": "S",                                                                                  +</span><br><span class="line">             "GlossList": &#123;                                                                                 +</span><br><span class="line">                 "GlossEntry": &#123;                                                                            +</span><br><span class="line">                     "ID": "&lt;b&gt;SGML&lt;/b&gt;",                                                                   +</span><br><span class="line">                     "Abbrev": "ISO 8879:1986",                                                             +</span><br><span class="line">                     "SortAs": "&lt;b&gt;SGML&lt;/b&gt;",                                                               +</span><br><span class="line">                     "Acronym": "&lt;b&gt;SGML&lt;/b&gt;",                                                              +</span><br><span class="line">                     "GlossDef": &#123;                                                                          +</span><br><span class="line">                         "para": "A meta-markup language, used to <span class="keyword">create</span> markup languages such <span class="keyword">as</span> DocBook.<span class="string">",+</span></span><br><span class="line"><span class="string">                         "</span>GlossSeeAlso<span class="string">": [                                                                  +</span></span><br><span class="line"><span class="string">                             "</span>GML<span class="string">",                                                                         +</span></span><br><span class="line"><span class="string">                             "</span><span class="keyword">XML</span><span class="string">"                                                                          +</span></span><br><span class="line"><span class="string">                         ]                                                                                  +</span></span><br><span class="line"><span class="string">                     &#125;,                                                                                     +</span></span><br><span class="line"><span class="string">                     "</span>GlossSee<span class="string">": "</span>markup<span class="string">",                                                                  +</span></span><br><span class="line"><span class="string">                     "</span>GlossTerm<span class="string">": "</span>Standard Generalized Markup <span class="keyword">Language</span><span class="string">"                                    +</span></span><br><span class="line"><span class="string">                 &#125;                                                                                          +</span></span><br><span class="line"><span class="string">             &#125;                                                                                              +</span></span><br><span class="line"><span class="string">         &#125;                                                                                                  +</span></span><br><span class="line"><span class="string">     &#125;                                                                                                      +</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">(1 row)</span></span><br></pre></td></tr></table></figure><p>请注意上面 SGML 字符串两边的 <b>.</b></p><p>讲真 - 我认为 JSON 被应用程序开发者滥用了很多, 但是这绝对是一个很好的补充, 非常感谢 Dmitry 和 Andrew.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> translation </tag>
            
            <tag> database </tag>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>逝去的 2016</title>
      <link href="/post/the-past-2016.html"/>
      <url>/post/the-past-2016.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">2016 年转眼间过去了, 不知不觉, 匆匆忙忙;<br><a id="more"></a><p></p><h3 id="学习一门新语言"><a href="#学习一门新语言" class="headerlink" title="学习一门新语言"></a>学习一门新语言</h3><p><em>Kotlin 1.0</em> 正式发布, 简洁, 实用, 不失优雅;</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Hello, world!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Kotlin 1.0.x</em> 可以看作是 <em>Scala</em> 简版; <em>Kotlin 1.1</em> 将是大放异彩的版本, 届时将迎来 <em>Coroutines</em>, <em>Type aliases</em> 等重大特性;</p><h3 id="学习一门新框架"><a href="#学习一门新框架" class="headerlink" title="学习一门新框架"></a>学习一门新框架</h3><p>随 <em>Kotlin</em> 再次回到 <em>JVM</em> 世界, 学习 <em>Spring Boot</em>(以下简称 <em>SB</em>) 框架;</p><p><em>SB</em> 是 <em>Spring</em> 社区推出的微服务框架, 在 <em>Spring</em> 的基础上封装了微服务的要素, 是一个值得学习的微服务框架;</p><p><em>Spring</em> 的依赖注入到达崭新的高度, 配置强大, 灵活, 社区活跃, 2017 <em>SB</em> 将继续攻城略地;</p><h3 id="放弃的语言"><a href="#放弃的语言" class="headerlink" title="放弃的语言"></a>放弃的语言</h3><p>本打算深入 <em>Rust</em> 语言, 一方面自己没有偏系统底层的工作; 其次是这门语言的语法噪音太高了;</p><p><em>Perl</em> 被戏称为自带加密的语言, 于我而言 <em>Rust</em> 在这方面可与 <em>Perl</em> 匹敌了.</p><p>一门语言如果在语法噪音方面无法节制, 我想我是无缘了.</p><h3 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h3><ul><li><p><em>Go</em> 语言继续趁手</p></li><li><p><em>Kotlin</em> 修炼, 捎带 <em>Java 8</em></p></li><li><p><em>Python 3.6</em> 特性加持</p></li><li><p><em>OCaml</em> 把玩</p></li></ul></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python dynamic class</title>
      <link href="/post/make-a-dynamic-class-in-python.html"/>
      <url>/post/make-a-dynamic-class-in-python.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">Sometimes, we hope a class can be dynamicly created in python runtime.<br><a id="more"></a><p></p><p>Take this scenario, we have two Django model classes:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Musician</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    sex = models.IntegerField()</span><br><span class="line">    instrument = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_sex</span><span class="params">(cls, id, sex)</span>:</span></span><br><span class="line"><span class="keyword">if</span> cls.objects.filter(pk=id).update(sex=sex) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># update Redis</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Album</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    release_date = models.DateField()</span><br><span class="line">    num_stars = models.IntegerField()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_name</span><span class="params">(cls, id, name)</span>:</span></span><br><span class="line"><span class="keyword">if</span> cls.objects.filter(pk=id).update(name=name) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># update Redis</span></span><br></pre></td></tr></table></figure><p>Ok, what if we just need Redis key-value cache, how can we design our Redis class ? Most of all, we think about two same like classes like this:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMusician</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_sex</span><span class="params">(cls, key, sex)</span>:</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_sex</span><span class="params">(cls, key)</span>:</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RAlbum</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_sex</span><span class="params">(cls, key, sex)</span>:</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_sex</span><span class="params">(cls, key)</span>:</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>This may be very ugly ! But we can make things better in Python:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_class</span><span class="params">(cls, *fields)</span>:</span></span><br><span class="line">    RedisFactory = type(<span class="string">'RedisFactory'</span>, (), &#123;<span class="string">'r'</span>: redis.Redis()&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_x</span><span class="params">(key, x)</span>:</span></span><br><span class="line">Redisfactory.r.set(key, x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_x</span><span class="params">(field, key)</span>:</span></span><br><span class="line">x = Redisfactory.r.get(key)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">    obj = globals()[cls].objects.filter(id=key).first()</span><br><span class="line">    <span class="keyword">if</span> obj:</span><br><span class="line">x = getattr(obj, field)</span><br><span class="line">set_x(key, x)</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> fields:</span><br><span class="line"><span class="comment"># setattr(RedisFactory, 'get_&#123;0&#125;'.format(f), classmethod(lambda kls, key: get_x(f, key)))</span></span><br><span class="line"><span class="comment"># setattr(Redisfactory, 'set_&#123;0&#125;'.format(f), classmethod(lambda kls, key, x: set_x(key, x)))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RedisFactory</span><br><span class="line"></span><br><span class="line">RMusician = make_class(<span class="string">'Musician'</span>, <span class="string">'sex'</span>)</span><br><span class="line">RAlbum = make_class(<span class="string">'Album'</span>, <span class="string">'name'</span>)</span><br></pre></td></tr></table></figure><p>That’s it.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Emacs is A Habit</title>
      <link href="/post/emacs-is-a-habit.html"/>
      <url>/post/emacs-is-a-habit.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <h3="" id="What-is-Emacs"><a href="#What-is-Emacs" class="headerlink" title="What is Emacs"></a>What is Emacs<p>EMACS may stand for <em>Editing MACroS</em>, but it has some more creative <a href="https://www.gnu.org/fun/jokes/gnuemacs.acro.exp.html" target="_blank" rel="noopener">definitions</a>. Here they are.</p><ul><li><em>Emacs Makes A Computer Slow</em></li><li>Emacs May Annihilate Command Structures</li><li>Evenings, Mornings, And a Couple of Saturdays</li><li>Ever Made A Control-key Setup?</li><li>Elephantine Memory Absolutely Considered Sine que non</li><li>Emacs Makers Are Crazy Sickos</li><li>…</li></ul><h3 id="My-road-to-mutiny"><a href="#My-road-to-mutiny" class="headerlink" title="My road to mutiny"></a>My road to mutiny</h3><h4 id="Interactive-Mode"><a href="#Interactive-Mode" class="headerlink" title="Interactive Mode"></a>Interactive Mode</h4><p>Before Emacs, I used Vim for three more years, so I think I’m very familiar with it.</p><p>For Vim users (including me), a small detail is they often restart vim. they open a file, edit it , exit vim; then another, and so on. One reason may be Vim really starts very quickly, but the most important is that Vim lacks interactive mode.</p><p>Compared with Emacs’s super-charging completion engine and Ido Mode, Vim is a bullshit in doing things interactively.</p><p>Of course, Ido Mode in Emacs is off by default, you can enable it like this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(setq ido-enable-flex-matching t)</span><br><span class="line">(setq ido-everywhere t)</span><br><span class="line">(ido-mode 1)</span><br></pre></td></tr></table></figure><p>It’ll enable basic Ido support for files and buffers and the very useful <em>flex matching</em> as well.</p><h4 id="Package-management"><a href="#Package-management" class="headerlink" title="Package management"></a>Package management</h4><p><a href="http://wikemacs.org/wiki/Package.el" target="_blank" rel="noopener">Since Emacs 24</a> (2012), It (package.el) became part of Emacs. But util now, <a href="https://github.com/gmarik/Vundle.vim" target="_blank" rel="noopener">Vundle</a> is still a plug-in manager for Vim.</p><p>What does it mean ? It means Emacs has an official maintained package repository (<a href="http://elpa.gnu.org/packages/" target="_blank" rel="noopener">GNU ELPA Packages</a>) while Vim not. So What Vim missing ? It is Software Reuse.</p><p>Ok, You maybe justify that Vim is just an editor not an OS; so package is meaningless for Vim; and Emacs is an OS that a package can be installed in it. For me it is a meaningless excuses.</p><p>Either Emacs or Vim, They both have a runtime environment to ensure that plugins or packages run. But on top of Emacs runtime, there is a library layer. Maybe it is the important difference between Emacs and Vim runtime environment.</p><p>End result, in Emacs, either a library or plug-in like package, they are treated equally; and a plug-in like package can reuse a library package.</p><p>Relative to Vim, I’m more optimistic about <a href="https://github.com/neovim" target="_blank" rel="noopener">Neovim</a>, I hope it can be better than Vim in plugin system, and I donated <em>$15</em> to it.</p><p>Emacs package interface is very good, you can not only use <em>GNU ELPA Packages</em> but also third ones.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(require &apos;package)</span><br><span class="line"></span><br><span class="line">(add-to-list &apos;package-archives &apos;(&quot;melpa&quot; . &quot;http://melpa.org/packages/&quot;) t)</span><br><span class="line"></span><br><span class="line">(when (&lt; emacs-major-version 24)</span><br><span class="line">  ;; For important compatibility libraries like cl-lib</span><br><span class="line">  (add-to-list &apos;package-archives &apos;(&quot;gnu&quot; . &quot;http://elpa.gnu.org/packages/&quot;)))</span><br><span class="line"></span><br><span class="line">(package-initialize)</span><br></pre></td></tr></table></figure></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> emacs </tag>
            
            <tag> editor </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL Aggregate Functions</title>
      <link href="/post/postgresql-aggregate-functions.html"/>
      <url>/post/postgresql-aggregate-functions.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">Sometimes, when we use <em>SQL</em> aggregate functions, we hope to collect all primary keys in each column group.<br><a id="more"></a><p></p><p>Take below for example:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> date_trunc(<span class="string">'day'</span>, create_time) <span class="keyword">AS</span> <span class="built_in">date</span>,</span><br><span class="line">       <span class="keyword">count</span>(<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">FROM</span> s_table</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">date</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">date</span>;</span><br></pre></td></tr></table></figure><p>In this sql code, we can just get columns grouped by or aggregate results; we can not get id columns (or others) in each row.</p><p>But how can we get that ? We can use <a href="http://www.postgresql.org/docs/9.3/static/functions-aggregate.html" title="Aggregate Functions" target="_blank" rel="noopener">string_agg</a>:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> date_trunc(<span class="string">'day'</span>, create_time) <span class="keyword">AS</span> <span class="built_in">date</span>,</span><br><span class="line">       <span class="keyword">count</span>(<span class="keyword">id</span>),</span><br><span class="line">       string_agg(<span class="keyword">cast</span>(<span class="keyword">id</span> <span class="keyword">as</span> <span class="built_in">text</span>), <span class="string">','</span>)</span><br><span class="line"><span class="keyword">FROM</span> s_table</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">date</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">date</span>;</span><br></pre></td></tr></table></figure><p>Maybe you have noticed a comma <em>,</em> as sting_agg’s second parameter, It is just a delimiter, you can use any one you would like.</p><p>So you maybe get some records as below:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2015-01-17 00:00:00+08 | 5 | 1461491,1461508,1461482,1461483,1461509</span><br></pre></td></tr></table></figure><p>It is very Excited !</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PostgreSQL Conditional Expression</title>
      <link href="/post/conditional-expressions-in-postgres.html"/>
      <url>/post/conditional-expressions-in-postgres.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">A simple example from Postgres offical documents:<br><a id="more"></a><p></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line"> a</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> 1</span><br><span class="line"> 2</span><br><span class="line"> 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> a,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> a=<span class="number">1</span> <span class="keyword">THEN</span> <span class="string">'one'</span></span><br><span class="line">    <span class="keyword">WHEN</span> a=<span class="number">2</span> <span class="keyword">THEN</span> <span class="string">'two'</span></span><br><span class="line">    <span class="keyword">ELSE</span> <span class="string">'other'</span></span><br><span class="line">       <span class="keyword">END</span></span><br><span class="line">    <span class="keyword">FROM</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line"> a | case</span><br><span class="line"><span class="comment">---|-------</span></span><br><span class="line"> 1 | one</span><br><span class="line"> 2 | two</span><br><span class="line"> 3 | other</span><br></pre></td></tr></table></figure><p>It is based on this form:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CASE WHEN condition THEN result</span><br><span class="line">     [WHEN ...]</span><br><span class="line">     [ELSE result]</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>It is very convenient in aggregation functions, just think table <em>foo</em> below:</p><table><thead><tr><th>id</th><th>sex</th></tr></thead><tbody><tr><td> pk</td><td>0/1</td></tr></tbody></table><p><em>id</em> is table’s primary key, <em>sex</em> is 0 or 1, it stands for male and female.</p><p>Now, how can we lookup how many males and females at the same time ?</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sum</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex=<span class="number">0</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> total_male,</span><br><span class="line">       <span class="keyword">sum</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex=<span class="number">1</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> total_female</span><br><span class="line"><span class="keyword">FROM</span> foo;</span><br></pre></td></tr></table></figure><p>That’s it.</p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> postgres </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Coleslaw, A Lisp static blog generator</title>
      <link href="/post/rock-with-coleslaw.html"/>
      <url>/post/rock-with-coleslaw.html</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css"><div class=".article-gallery" <p="">A long time, I used <em>jekyll</em> as my static site generator. But now I will play some lisp, so Coleslaw comes.<p></p></div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {        var options = {            selector: '.gallery-item'        };        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);        }</script>]]></content>
      
      
        <tags>
            
            <tag> lisp </tag>
            
            <tag> coleslaw </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
